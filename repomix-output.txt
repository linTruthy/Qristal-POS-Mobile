This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.idx/
  dev.nix
qristal_mobile/
  .git/
    logs/
      refs/
        heads/
          main
        remotes/
          origin/
            main
      HEAD
    objects/
      01/
        c2e41511f965e6c91a9c77f2995f75df784f9e
      02/
        6222d2141befe9f14d0cb9463473c665807926
      03/
        67753a51be5083a8305ecc1f67d041f895282d
        f41c8d541710c42fabb2007d31fdd6abc4c986
      04/
        1312bb4bab9b838e144d86a5c7d26cdc710d08
        ef206c8607696ac2bb082bb1b46afe648f59f7
      05/
        8ec426c4d30f74356aeffd68596a986f95b70b
        a8ab4423b79921abb08a68caccbb40166ebe5f
      06/
        71c377abf9df36d6e1daa03907f8a77885c30d
        952be745f9fa6fa75196e830d9578eb2ee631d
        bc51d48d6fc644330da54aa9bc043cc21b13e6
        ce3b9b9333c0e6101b9e1f4a9ec685b7ee726d
        fcdf7fc11c36b059a5b106554819968c82f1f6
      07/
        20b4661a79bf180d68f29108539eb411d8ca7b
        295568f45433f62ff7c15ff6a88384302f368b
        2b762b162da4ccbe00cd4286712a41472e5535
      09/
        868a604f44b9542aa681045cd66edf835e730f
        d4391482be68e9e4a07fab769b5de337d16eb1
      0a/
        e41164ae98009bee3a65c88d2064a5a67e7936
      0b/
        30335dbede6beddefd41f0d94093f122f12b54
        c7c29ec5806727962e1a7d6e4fd43217114e2b
      0c/
        507538547f58e428ce2941d02b3d53db7bf853
      0d/
        2902135caece481a035652d88970c80e29cc7e
        3e9af889877d49fa1539e55b8928dbf2c10270
      0e/
        8cad48119d4da2306e37f37db3b88b7888b552
      10/
        fc6fb5600d1669f2ce57727c104e44e94c4d62
      11/
        11621b37bd82acf265f31d8fa7f4b68aef931e
        8909b51742ef9b7ab2cc697cc34115a6bfc60c
      12/
        76453cd657ebf8fa6c71a5689a6dffce40c77c
        76ddc569725e4f5d7d705b457a58231b922b1b
        d10090de5f7bfed5590b7b50ba3494acffcb96
      13/
        330d0adf3cfebba0e8098141d61c94e0a4c165
      14/
        8da3098986ea6c098d5a7b1f8e9cbf6b427b56
        d8658e6ae911d0673b23f723c99fc9bc4ea33f
      15/
        5950dcd8af6f81c4353b4602ab1789303e005a
        bbaec9e554127f82ec0fc06d8d3b149c154b3d
      17/
        2f84f70490c5a29036fa1cf38ecd2bf139b6ff
        40d7a5da95ebc7911ed428fb3d6bdcac0cb442
        987b79bb8a35cc66c3c1fd44f5a5526c1b78be
      19/
        669488f1b2f9321fa4d25c1334bc323c92fbb2
        eb62b7a1dcd6b16d4d12cb777b7aa4d30629ff
      1a/
        23f4bf84f7a690d9d2904e9aa0bc38fe423051
        d8fb9c3a408103d67e0e2d0de39ba5a40d9151
      1b/
        5a2d4d7b1335598eb1dc16a71977bfb18f42e6
      1c/
        4cfdd96a89b0095dbd29a6ca194e41ad77b4fd
        4e9d2f5e2350f5750acb62a2c6f11cf79d63b0
        7391735845954fc8498cc88ccf812d156d0c75
        8868074a5397f9e5bb816e47d6d012f16cfab7
        eda876a4967c937ce2f7db7035d643f2f2b750
      1d/
        c8932fa26ab4f80492ee6ae321eaafdbfa2cd5
        f452be6f3677b874f368bc6ea4eec8d7c6d02b
      1e/
        5bdac6eb3d095e53dfa90afdec84d34834e7e9
      1f/
        1c27150dd73d931dbbac00aebc96156d87bf57
        b7db46a35ec18854f47c10a07507825993049d
      20/
        0b612c86c6a26b51c1040618492792dbd6e614
      21/
        b0a5a1e6fcc3a519c1b4cc1ef0a7b4e2eccfb6
        c6e74c9ca13b40534f6ca0a4af0ed4850ddc9e
      22/
        2151a1c25d31bdbc2fee55e5397f7c0364cedd
      25/
        e46bd3e50d038c01e5e3981c69f2283573f7be
      26/
        c3c93befc1ec977bad3b6b520cb5ebe02e0b44
      27/
        d93e9f189ddd2cdc5dcf406f71cee2f4754963
      28/
        df5b5aa8d6e9c95fb2f2aa53e10f88c0f7cd3a
      29/
        57955257931c7c62640b0274a0c931d851c127
        6ac0e6b97b0ac02d6dd7f4b73f944ae08f9915
        a3a5017f048d6d8e6a450eef64435ddee44fb7
        e92a985a3ddf0c1084d06e8bb868e23a6fb314
      2a/
        21e9c25a41abec82db318a5ec9e1437e787260
      2d/
        431f89a29f3a9000c1fade6f0899e6a1af947d
      2e/
        06d6b3da31ce1d69ab144bce986e21d3cd1669
        36aaed6d40ca54d241c6f56a3a91da8be9b9d8
      2f/
        e1f1aebe6f147c6501d4cb05946ba5f6b7333a
        f99644512e3287ba21c9d40ecef75e535a82a3
      30/
        4732f8842013497e14bd02f67a55f2614fb8f7
      31/
        d3be2f4d8c08b67a0ed2f9509d7a53bd69bada
      32/
        76f48b656e55bd96d4e35632f7a9610dfd7151
      33/
        8cc51737f729a7abcb7efa192fb1301e51e13a
      34/
        16d5052b717fbc8b4b28e6e886285efa24bf86
        5888d26e662baa7c5ae78589829dca8cf5b4f0
        7a376bc4a063745fd76d1b8a38c715cb39681a
        a0ad927c6f2547c3b19544ab230797976cd944
      35/
        29b0c7215ff167ea14136c88f8ad8b74516f55
      36/
        0f5bac5dc1da653e9c28a7e385c5cbe841d4ff
        58fcb3e2958822673ad87131356f055fd80710
        741204d08d2a252efc53e0413567a5dc44f3a2
        cbce676bcfbddfa689b9d0abf23ac40fd2e60b
      38/
        0685b91b0aaeeec4f44f714076565cd1b56e0f
        79d54755798567f0f318d63340508d5668eb96
      39/
        2033205d2d980073d8ab30cd0900608c25a9ca
        3f8fa1d96e568dbec482efe0c4d73bc82567fd
        4917c053a04daa76d8b94f0a02db0bd99e1034
        9f6981d5d35475eb18e6068ae67cdd7c731978
      3a/
        0b46511a71b464dac72d693faae6ea0f7e3b2e
        c3f5dfe724d146fd06c00358df974b51512ca9
        f656343f656c262ffdcec97d117c1a70a9e114
        f93b882364ddc13fefa4826038d2c851bf5ea1
      3b/
        5b324f6e3f162acfb54a7c423f4566fe04bae1
      3d/
        a750e3e1ff190bf166ead96a6085776ac92c45
        af928f19f5b1db801a373bb01a5ded373ec7fb
        f3d1a91dec9f419bbf32c7dbd7ffe3049577b7
      3e/
        7224e89ae61c45054015b1dc4a7e4aa19c78a8
        8389f5ca955ef95673f66c759820db32ed6e34
      3f/
        80d81d42f7f9cc0868606004400e9dfa7c3f4b
        e80ca2248615bf05e77cc6a3705922f32cb4b4
      40/
        201bba5e042234a9f11eca5f607aec989ac72d
        4fa28e3d63db2afcb5a23fc16423b41f3e8b41
        fc422ae526f8ece050736cb2d43c8fe957f605
      41/
        2401e3cc87eaf97c4aea06b769faf3c1a53e55
        5b3d6f9705e47fef6b61050d7b48a088b9e550
      42/
        40668152c9891a007d4fc89025e54f4f0d5aa8
        6135bc5c411bb999129a882de1bfeeb1aee0d1
      43/
        e3b1f50d52819e6e5564fb3b64ab9a87ed1697
      44/
        ae72e37f8a7479fc3ba0b20caf198447964af3
      45/
        1370455e98e74492378df2a8625b65fdce6cb6
        2551af945e3aaff7ba3967e492f9f45418791e
      46/
        52004f5365d5082dcf2a2a58432ffbe93d7a4d
        b726bd53d47e61ba941eb355b9c8633ebbaa20
      47/
        4d17a22061a85ba8ad7aa7c8068bdd9c33c712
        e27f0765677e0f65d5445e75817888cbde5dac
      48/
        0d678dfd14469f88988005f9ddf3a41bbeeb48
      49/
        3b9c20fa255914b976cdcc5d87f45586669ac6
      4a/
        a62a7b9582f01d91db86ed2486aa7003ebaaa5
      4b/
        92aaf1eaa7670c82f40894e4b17632eec33885
        e6e0cc8907b2c4b6e40f1c44285fee3c1067da
      4c/
        5f05e280ceb6ab20b4ad0f02ff8240d5cc4150
        fbecaef47673ada4e2c5369c11300b2f07e5c4
      4d/
        495eb53181025548a20fb6dd06378b37798a5f
        6372eebdb28e45604e46eeda8dd24651419bc0
        82564480fca437ab426265a4dd6b7944e2991f
        b65733a2b8324351427cf5492517082af2e805
      4f/
        42d19813572dd6cc576c8254b8adfb4b7dd199
        a0e342ee070474ff8a51331436e28bcc293f2c
        c759c48f3a6c17b7c98daf0d5f90949305074c
      50/
        28d815ad66bc736a32606d9db0d6a5b1ec9a72
        3fdd063fb17406960ad48c1216048ec675f48d
        7d1681c95d1a91c763edfb7d0f2be450b50f7e
      51/
        2c0da9951a1f243719ff55c6ac9b418147b598
        71170e2e4f9da20fe77acea870819bfdfa7f70
        8254fd784f88bb6083c8fdea803d57c5e2c33d
      52/
        0c14b7a6daa875e065c2f5002fde9e5db95a9b
      53/
        6165d35a42ac4ce974f9cf7ac24a9ba0645acd
      54/
        5b3d99ffdd8deebe1723e72daf45d719c02d08
        875db42a0439462d3d65724b6d2619ad1e4d8b
        a08096d5ef364cba7f6e9209c7fe416f97710a
        b3fbc2b298623aedbe84a05f837984df792d98
      55/
        572155ebde1fc96576a49efad6513acf8465b0
        d7a722ea49994fbabff87829031f3f34e314f0
      56/
        a9f958af51f32960d9da1d041890baa6f0067f
      57/
        1d67ecb1fca35475c94f2ca84118ade9c47e9f
        e361193762e37b1a59702eb35d36cfb761e37c
      58/
        943abb1b9942f5c23c6253fc72f549942fcc5d
        e115fa2f58ecf5b59bf208b1f8f8a9b6366ccf
        f29ffcbe11fe951ffbb47cb29842bd3659f5b2
      59/
        241ad55e5692adb0154eef52d7a2ba246f798b
        aa6594e7c539a8ab244ac051bdab3ac7206835
        e7353c02359fc103b9bced081308a0ff45a7c3
        ec19e91085dbb9b7c1ac35931f4fb2cde2ae84
        f1bd062cb2dc18d0b2c0fd794dec4117f1fc05
      5a/
        2047a1728fc6473e3b46e4682ea8888b501718
        88276a7b36980d2efa2689a410aebb67aa65b8
      5b/
        57b8e3184d29d5723f7feb65ee4a9eb7d1dd03
        65547313277f7c52a64e125c2164dbb49f73de
        6f158480d225f24d1dff9c781ddd7ae1e59ad4
        71ac2cd44f1b49ab2a0a9b587b432e995b4a3b
      5c/
        17b58426d1736a340f4b9b679a573db02428c9
        894dd11d0b6860004e1057f5d931e56c10879f
      5d/
        5f80da6bb9177da48965b4acf5a1a37c99498d
      60/
        537c675a7a57e4891a6f9d39b5ab6a6e8848f8
        608d0fe5bff3a7a7e05d5a232944a1a8effe5f
      61/
        3c5e57633e095d160819bd3936fe79c80ec4cc
        ba44c21f2a9c553725aee9e6eff45576514a08
      65/
        16e4e403e42793029cb71ad6a249a90bdd7292
        26e9a6128b3a9bc617c9b6313855c563e8c24b
      66/
        a5487a223c9db9c415a840b4451379ec15b214
        a65d1e4a79f230031ec0e0959a721039e7282f
      67/
        d0990db8495d5f484d603d21099768201452df
      68/
        2ab3f2e515c3bbb8897b4de23eeae2c0b6a214
        58e4fe76c1f898fd16fdcadc364e9c80998f27
        c29e1f804056b19238714beb7867df4dc1f708
      69/
        05a4f74b895d01ef0f36a4c537b2e768def132
        0dbba97f29a0d912cb5f24e1591c2883d489da
        4eeb1bfd6dfbedbee6941301f3151b30b512b5
        9335599c17313e17d675ff31c04a227e74264f
        f976c171dca37bbe3734e3204ab7590199c6d1
      6a/
        32ac78ce5363d572f7f0a13e1151769979ec57
        4c0a3a1a57cf7b4af04677553b39023783001b
        b35b56e74e4306f7408983b0bbf99df720544e
        f2bf54493678530aa6fd04e1b0dd62cc84d949
      6b/
        c96bc2788e4751e7f822eeae95607b1caf2449
      6d/
        4974a84f24c466cd9faed7b1fd9da407095a81
        a0652f05f28fc6950cec20ebdfbae89b665479
      6e/
        62d3deb98db483fce41de65d599e5bbfaa2b28
      6f/
        568019d3c69d4966bb5a0f759980a1472afc1e
      70/
        59dd3ea6b784fcea690e408a80e2a496673f1d
        65be3d9d6b263c7927961691f2ba2515eb7c93
      71/
        7043dc58c5060036c2961b624faa2e9188200e
      72/
        3bf4f92c25fa89313d91e8774d256c99edd681
        488e07c20a9713788927da0670c8cf156081da
      73/
        ecda3236495a1f02da3c08f2d10ce2ce0fff4f
      75/
        025cfd5ccc1702d5ada42072626e319bca6cbe
      76/
        e1789b06850f063df87b763f25be27996e1488
      78/
        55942c16423d0eab406740a18b3942f834356b
      79/
        0cf70d61bd9426fd9d7ce4b0dc39976ca752cc
        773035ef027d2910b612cfbf16a085c45ea3cb
      7b/
        1d8732f6a4a9d54651173ffe0a40c5104b0379
        1f60f16987562b703e8152a323555e15ced249
        81d9c4c1b12d390429d334b589028ddd687164
      7c/
        00988eeda82d1a6277a59ba29aa37b5a435766
        0b1dc07900bad63286a0f92dd42651713587de
      7d/
        da575e781ddc272fa76e0b892e712ee869a8da
      7e/
        205addc870742944315023df9f1a57d1313399
        5196552357806e2cee606ab327fb9473d30466
      7f/
        2907cb0b5cb0a6932a8413e7cfc7a93485339e
        a4f47c5952ed47a8f19fadd2f10ad368a837db
        c07dddf956ceb6a3f3b6342cc51f9d29d8fed6
      81/
        d44c4d4f90e501507b5c1da5d0549e9dddd3a1
      84/
        4c7cc646502c41d7ea3df37eff7e06b7fb1307
      87/
        05903564b9194cf947a386669a492e1f8ff987
        7e54146adce65f8fe24827c5fa85bb023a492a
        b096d5d4b16d2224655e8aa507e14d00fa835e
      88/
        37ef0019e7728c118161636ac6423cd1a4575b
        b2a914f61edb6dfa511ca0d2190a404c1b885b
        cfd48dff1169879ba46840804b412fe02fefd6
        e04f233c60fe9c4078fa898d83673bd6d7bfc1
      89/
        d7db5ffb93ff5c046be5769c00052371ad4d10
      8a/
        99ba2445a76bbc5e449d765b2f3f6795478cae
        aa46ac1ae21512746f852a42ba87e4165dfdd1
      8b/
        0780a50ddfa66d62d589017e5f9ae3b5c541aa
        d06bdf095c809f80d639847440b06b0199a88c
      8c/
        7ac95dbc00286baf88aa2636870c92bd0954d1
      8d/
        250879640cb7d93b8273edff4e6ecf38a0d1a7
        9dfff0af6c165f8e46121e892e902ab61c6c29
        b5755ab6ef521a8966da1cb049fbda5ff88070
        dba704df04d6566bfd707be243be9b01184b82
      90/
        3f4899d6fced0eb941e159f7322b21b320c40c
        b076df5dc3f7abf095e0ae3a9bfa3842289c5f
        f8fac98e76927c81a07c10a618a6a37ec22990
      91/
        61be87219d0583d19c271ddfb838f10941a5d7
        a6529dc9f0a6df21c6558c5d5c6e5e80f8c68b
      92/
        765696cd9db09f7ec48474176830efc9483494
      94/
        6fe572ba3d58478f427f0d0e1ac5a7d72214b8
      95/
        41b6d6bf04f73ee0fef4b1e66dd11b3f1908d1
        5ee3038f988929fac2dedb6a307ebd45dfcfd7
      96/
        76d84e4fa049a659bae8ec68f72ee09493eb66
        8e5444a110206234b78c551d62c8948f0fc27b
        a1f99120e799d2203720499f287f2c42bb1619
      97/
        560222f65ecdcc75721e6cf8afa4825bad4a8d
        84f16c882653abeb055d62e5e36fc0fa0da47d
        dfa15b6df14d186dfb08a5310c0f249303ded7
      98/
        1556b54d30f343313e2ab4200db771a537f14b
      99/
        57e51300b80d5c7da471573239e5a37c5b5e8f
      9a/
        142d5c537cba96f0fd65044abe2b71cd0f6c34
        3221fd7d592094e43f448b086102c7be184059
        87b90cbb83bd2fc5847785f258783f562b9936
        cab57ed1460e33dd57ff7667effcca4dc69694
      9b/
        924a3ec3352d9a9139a9adbf25d45f1e3b02a4
      9c/
        51a9e7f1f45fc3cae4f90c69f3ca63cab38fb9
        6b7c04713014538dcd1687b26813fb1a051377
        92e4f92fe09052c0a97ac82ca22ce578c58184
      9d/
        4a2ce0caa1888ff1e8099599fa7371ed96a027
        4d39b1ca34cb76b0924d1b1a35a5e6158489c7
      9f/
        43e824c8d823794b30d64c2b4b999f9af9ed2b
        d49b80a6b18979f26bb46d86e32d0cff05f7b4
        fc2270a817b01fca3909fecfecb8b599b21650
      a0/
        1e3c1276e409cc99b08de745cb9a3138844f66
        5a5cde120d48bf99c5260ef8b2e407bb30f55c
      a2/
        3f4e5707a9d77dc23fb3d5ece597bde7e8e8bd
      a3/
        2841fc99ffb00133565bb6c0506c4f59a55dc3
      a4/
        2ea7687cb67e55af955dc8874a072e087ce3ed
        f7e434d3b1326d885fafc1f2a6d008871f1701
      a6/
        368af0ee7628fa194ef8fe3bbe4523113d6e05
      a7/
        54a53182fb6f3944b9101a4aaf731924bdfc3d
      a9/
        29a54a82df047058ac6f94ef21385519f9d0eb
        4d35563428b2f3dd24c373cf88a008536ac36e
      aa/
        126555149853dcbcfc1bfcdf5644bf80bed643
        ef06e9a594bdd16833d0470ad108ff02528b5e
      ac/
        3b47926ee56b0efc39cbff3c532918abbf953f
        7f762d6c855ca5e8a145047d9b73c100e4b919
      ad/
        4361447e91e38c7ceff3a3a9f4975bc7f8597a
      ae/
        4c0ac90f62ab7d9b760f83b18f78e931b97ed6
        665c94faf6eeda8a4c64c8694b997ffc1e19fb
        a9a5a2de10b6532baba5b7ecf25a54c4933786
        ba7933805bb49ebbda873201878731a13fc0d0
      b0/
        977602f6a5063e9b2aece0c86fbc137d236bec
      b1/
        be1a14550d37f092425b13733d128f93eacb72
      b2/
        4bf04236b9fa28018fcfe817cce23bda8040e9
      b4/
        9bec4f4c87b797538d2bf845bf25728191a8e4
      b5/
        17523c058e83cb0914007e3649efb7aea0a32c
        552642349b20be84a0c7155baf6f34ef65f48f
      b6/
        88b8b3432f6c4e338c29850032963a7ee9c46d
        cf065d9edb7ae14c0b05dec45a6e6d7b696eff
      b7/
        1ffefb93e9542762c7650931fd2406fd329e97
        49bfef07473333cf1dd31e9eed89862a5d52aa
      b8/
        bc430523ddc78fee6f5dffe2b8ffa9388e5c28
      b9/
        2a0d854da9a8f73216c4a0ef07a0f0a44e4373
        2cbbe938e418b2aaab93e3b538997087540341
        b21f4bdcf61b1bf95792f05620a00cd869b216
        ccbe70af97c9d8b78c64c2c53b70636b18f7b5
        f0433b76c11c75c504e777a57bdaac7dd858e4
      ba/
        2b3747bd2ee9d634a7990b8b885703634b7181
      bc/
        628a1d4330652bbd0b4134d01ee5304bbb79ed
        fd96733948ed2296e9663f710a9c5e9eef4af1
      bd/
        8e4349abce674d8a68919ea0004d18656c3033
        ef50f99f555728265e86a92692c02cfbdb2fcd
      be/
        3943c96d8eed92e2a329ce8327616d5e7dc440
      c0/
        15ed6c5dc76e1b13704229b2b500b61d4a3ddc
        4e20caf6370ebb9253ad831cc31de4a9c965f6
        8349999381637984924ab9f7ec65b05a09efa9
        e5719eee96f12bbd26c6a315dc1b5ad68b8fbc
      c1/
        0860148615d34453ee6d10190bb895c7e5ecdc
        a4f929bc2bf4ff1297c6f31007860e019f4d31
      c3/
        f99d77557ae95cafddb29e84ef93cd336d7ed9
      c4/
        4e8e7b6eb59b03b73f4902841857fcbfde9c02
        6cbce54cc1d6bbd668510368072d5947033f00
        d7fbc684ac50d980d50acab435359266cec358
      c6/
        03874bc52aaf7bc693b59122f50bab225204d9
        3e5bc6c6ee924c0eaa2c14a40cb90fbae93aeb
      c8/
        ded4c8aee041d90a8dbe0e311604a22c0faec5
      ca/
        959f521e4522843b469e8a8e7375381c361a7d
      cb/
        1ef88056edd1caf99a935e434e7ff6943a0ef6
        392f3f3f289e0955e74ea297a3a20f7388cf8f
        ec4d3234da9f79cf5cd4f64c0108b040ee0327
      cc/
        040f7aba55591b0f70f2143714d1a1fdb8b17e
        9ebabe71f55803ca2ae63c9d33b6a344c2a2ed
        fb5d6212bc120deb57fabb3a261299d992eee2
      cd/
        114dea6b23f0cb00b6038549bc938e60163c59
        7d6ddac505be6d0b101b9f5a1297b96b5eb312
        cad689a11b513f9e5af4fc9796139599818515
      ce/
        50a609e6c9c42ed7f311bf709f73ce0fd585d7
        79d29767f19a06a2ef1e5af2c0a1727e131ae8
        f8b4d40185846f74dfc3b3be1d8e1e3b919666
      cf/
        50ef39d1fb2f5873c5ee6eae490a21a1d4daa0
        9b9885bb4d65a722db2731e8bb34b5ce775385
      d1/
        e9e2b1b91f9dfc5f430ecdd9437fd9a0e3ec24
      d2/
        1f69e44c337e9b9948a421d624121b5f99639f
        d33de9aa9ec1e9d80252ea38c94139477f514a
        ffbffa4cd251cc00b2b93a5efc2a0213460220
      d3/
        445c1f9cdc6af9a0b1218fc994c4fe95d10e93
      d4/
        92d0d98c8fdc9f93ad2543bb4f531803e9df72
      d5/
        f1c8d34e7a88e3f88bea192c3a370d44689c3c
      d6/
        233034165902aa230956985cea2568d4034126
        9c56691fbdb0b7efa65097c7cc1edac12a6d3e
        e6675a2f3039f6cb008cc6d9b80c382e6c3d25
      d7/
        61c53178cc135119f252e047fb2f6e08512ed0
        c94b97c62192a138b7e062327ffe64b9341444
      da/
        005db14b58a4846aab97ecd9cf74bbc109a8a5
        45e764751f21599d9044bd567d6df24a0f3db1
      db/
        334c5cfe8d5f98491528e4688f22dfaca3c943
        77bb4b7b0906d62b1847e87f15cdcacf6a4f29
        ee657bb5b9158516486b3a1b47ef8b6fc72a2a
      dc/
        139d85a93101cc0f6e9db03a3e1a9f68e8dd7e
      dd/
        1bab2e07ab3c8b4ffda4426a45e8c14625e46d
      de/
        1218efbe4dac2cbe41269c900d9bd1470776a7
        3aa829e1d647605db3aea7930d9c072dff18d2
      df/
        7ac9b59bc592623633a43026841655ba6c97b3
      e0/
        11f6f3be5fa2f2474908bcec80c776e0c9c9ee
      e1/
        2708b14172f2d2e34899f091389662f939c97c
        6d68cb1e28a011ea74dcb0d5ad3ed1e9a49937
        c2edc65780ba865710f12c74d463243a9347a1
        ca574ef017c1bc00556b96ea372e2c07948771
      e2/
        ab4cb486a971c90a1d38070ebd382dd6c51502
      e3/
        3a057f41ba26268ef3d9d3aa1fe167a0f218bb
      e4/
        78dba5f9be8a55bdc4b177384bd815df5d6641
        88ad63f0f124f55c57e1b7718287730fed2cd2
        9f7e0024bded668e289f333001ab323faa7476
      e5/
        64453265576d5deba1e82827411a1639e4db8d
        d0872a4d9e3b5d48b9197ab2a3263d01582848
      e6/
        97629470cb468cd298313d7de0c90f8ab6972c
      e7/
        09d6e10744167a833ee9fcb2647037714d2bb1
        20d87c94bc7abe31900b38b667730c438410c2
        64b89c2e2128e0474fb934c3de1c93daaed640
        8d4bb5d20aff02f11f8ee2e27108d27da00564
        a5cad249c7848e337d1d706f79eb3ffc8c1acc
        a6da767d34017e590088e77a507764df4ae87b
      e9/
        01dde684ea8ba25c50ea5dc7d5900da31a30d4
      ea/
        04c90694bbd1b7a2ff77f5af261e0585d92f59
        076e1c6416c3eb9ccc2532629b13a717baa4ec
        1ea1a622653cd442fda33b7b1b2fe8f34c77be
        2e70c5eca35b48b30635d7997f4e2fb93a70c8
        cce41b9467915c09dcd6bfdf34177a1fe04f27
      eb/
        9b4d76e525556d5d89141648c724331630325d
      ec/
        7bb6a0a2b7b6e030449d01636f09b1f9e20f63
      ed/
        1a3b578f50d6916db58368d066ad92e41aa27e
        5e8ce7a616d368269aa58a7892e2588961b8a7
        edda50ab05286799656bcdbf4e26d41389e763
      ee/
        6a0bd8f610bc39855162dd350b7bd4696ded8e
      ef/
        73e28ba971f93be6e17ee6b9f6bd1d1907ff57
      f0/
        158da787bed545d071d93b49e5c4884867b8d7
        18a61817f55e78bb92ce8df2dda423ec570a4a
      f1/
        697a692d7a381447d7d7ba1d47285708a306cc
        7e7ae4ab401c7c0f6289e1b96769e1036765b6
      f2/
        0042b264eb6f196bfdf14779cedd3cbff3502b
        598e9efa754d1da9e6de4d430a0f9d7dff7e11
        8a6a455eb55eea01d6527f80dc2f1f27febbbe
        fb9a9a2228ae23a697201bea3abc7e84a4fc7a
      f3/
        624f836b90facbc721727156f5211c3dc7ade8
      f4/
        f47a9398d210f3701c54e70446bae6a7a0e8ba
      f5/
        12e2600760c43b747b9fac1ebfc957084a9944
        80e4a7a17e9200c44c15be87476e1eccce7612
        ce41a2f27c741b615a15fa5d06fa70c1404e85
      f6/
        d575a07e57adb58513783af885c7e98b58c501
      f7/
        4085f3f6a2b995f8ad1f9ff7b2c46dc118a9e0
      f8/
        b20b7eeb9cc32bb505af40147f20752f6ded9c
      f9/
        fa0d5265dee97a53a9e9ac08665dda4e38848e
      fb/
        45b19e80d47b2e92fb969e4d6bacb025d4fc71
        58b37f4d61657a0521a647aa5c9fb580298422
        605bc840f7bb713a721358bd422dd94c0755c2
      fc/
        0c98b4b780c32fb2b4557dee193fc8d01113d7
        1131dfdf1d70ddcdacc4f1aff9ec7d8a21a810
      fd/
        13b83b8f7735749a5394b558094bace2bff589
        252da164ec9462ab6576139adbc6e2ad0fcd43
        8bc9e627016baf62450a93213a304c1a433fc1
        c7b2b8d66f47f9ac29f7163af22bf066cd918e
        f167002c3274417ba8d6a3e3efcdb94ed53007
      fe/
        99971fe070adf452e27e8ac341d5702d68cc22
      ff/
        66ce6a85058b6ecefa644dd0242fe4cafc1d9c
        72050d17cff2656b9baf3a6b9f5d2b4eb93440
    refs/
      heads/
        main
      remotes/
        origin/
          main
    COMMIT_EDITMSG
    config
    FETCH_HEAD
    HEAD
    index
    ORIG_HEAD
  .idx/
    dev.nix
  android/
    app/
      src/
        debug/
          AndroidManifest.xml
        main/
          kotlin/
            com/
              truthysystems/
                qristal_mobile/
                  MainActivity.kt
          res/
            drawable/
              launch_background.xml
            drawable-v21/
              launch_background.xml
            mipmap-anydpi-v26/
              ic_launcher.xml
            mipmap-hdpi/
              ic_launcher_background.png
              ic_launcher_foreground.png
              ic_launcher_monochrome.png
              ic_launcher.png
            mipmap-mdpi/
              ic_launcher_background.png
              ic_launcher_foreground.png
              ic_launcher_monochrome.png
              ic_launcher.png
            mipmap-xhdpi/
              ic_launcher_background.png
              ic_launcher_foreground.png
              ic_launcher_monochrome.png
              ic_launcher.png
            mipmap-xxhdpi/
              ic_launcher_background.png
              ic_launcher_foreground.png
              ic_launcher_monochrome.png
              ic_launcher.png
            mipmap-xxxhdpi/
              ic_launcher_background.png
              ic_launcher_foreground.png
              ic_launcher_monochrome.png
              ic_launcher.png
            values/
              styles.xml
            values-night/
              styles.xml
          AndroidManifest.xml
        profile/
          AndroidManifest.xml
      build.gradle.kts
    gradle/
      wrapper/
        gradle-wrapper.properties
    .gitignore
    build.gradle.kts
    gradle.properties
    settings.gradle.kts
  lib/
    core/
      constants/
        api_constants.dart
      providers/
        database_provider.dart
      theme/
        app_theme.dart
    database/
      database.dart
      database.g.dart
    features/
      auth/
        providers/
          auth_provider.dart
        screens/
          login_screen.dart
        services/
          auth_service.dart
      hardware/
        screens/
          printer_settings_screen.dart
        services/
          printer_service.dart
          receipt_generator.dart
      kitchen/
        screens/
          kitchen_screen.dart
      pos/
        models/
          cart_item.dart
        providers/
          cart_provider.dart
          menu_provider.dart
        screens/
          dashboard_screen.dart
        services/
          order_service.dart
        widgets/
          payment_modal.dart
      sync/
        providers/
          sync_provider.dart
          sync_queue_provider.dart
      tables/
        screens/
          floor_plan_screen.dart
    services/
      sync_service.dart
      websocket_service.dart
    main.dart
  test/
    widget_test.dart
  windows/
    flutter/
      CMakeLists.txt
      generated_plugin_registrant.cc
      generated_plugin_registrant.h
      generated_plugins.cmake
    runner/
      resources/
        app_icon.ico
      CMakeLists.txt
      flutter_window.cpp
      flutter_window.h
      main.cpp
      resource.h
      runner.exe.manifest
      Runner.rc
      utils.cpp
      utils.h
      win32_window.cpp
      win32_window.h
    .gitignore
    CMakeLists.txt
  .gitignore
  .metadata
  .repomixignore
  analysis_options.yaml
  pubspec.lock
  pubspec.yaml
  README.md
  repomix.config.json
qristal-api/
  .git/
    objects/
      00/
        c6138f89527d92656ccfc3f06bee461abc5fae
      02/
        8dbeb2508274828222ddd9085a4fb6ef7e9b70
      05/
        620d571635c7e93971ad86a425ec9fe47fb0e2
      06/
        3fcbbf3ee334cffab469cf3a7ae7903207be9f
        aa7b41cd43b11e54ef7303e76049c88dcfcbb6
        e6b86fc3281c4b92db8810bef7b1032396c427
      07/
        f2bf7d899a209cdafde40de4a7294bdaf39d1f
      0d/
        30efa827f0729acc637b518f90ddfff17c1285
        c80c32c638340b48e5c4c942d522b37f2b4a0e
      0f/
        53758589e7d8374bd6a4e0e2ebf31ca33b4237
        ec3c4407d8f27a08a07c2018d4a4223b9107b8
      11/
        28e976856e0d7ec7831b6df0e16fe635db63d9
        db421092e317626b5dbe156e0e3cc1bffa7c31
      1a/
        ef83e625d98bd39a64a0f2c52a50951dc2e440
      1b/
        5a80d5aa1405879d008f8067b7211ef2eea4b1
      1c/
        6831129229b1729a737abbf5f2122fc64e1f44
      1d/
        e4e28972a9069040e0bb245de099b62364bde6
      1e/
        0782659d8177ec7b09152200aa2a6497850ea9
      1f/
        e8c982e0af978ca5e821965cca8d9c53957327
      23/
        bb30d8f2bab854fbdd6e470223b23dc377d120
      25/
        f47cb74b57568a5a048253ed5092cce9c2a600
        fda5bcf5ff3ee2e401b2f5f0f35d945ee4c3ce
      27/
        a31e61857ab14593aae0e42299217c014976a4
      28/
        3a85374bc4cdfe2a301eb65d980babcff1a9cc
      29/
        771b02c69305139cafcf47f7ec8ff9c908c19b
        dad34eaa6471bc3dfc75954f660b04ff748f2a
      2d/
        7f31d65b81544bfa995db5e8edd148d8799279
      30/
        8a770a1d6815830a58264b21175cae442a4ef0
      31/
        5c20b2470d96564cf3d1820f3e7a89532f8cc2
      33/
        d56b5ae1363efe30abd1341c1ec25f55239eb4
      35/
        96eb7f30738556a86879f48a65f2b93d6a3c7d
      36/
        852c54f010731b3658b7c99407e42994c68cf6
      39/
        75547abf3c770283ed1f95c9891fef2a7e6ee8
        fac0719815aea49a5349246de1d7b0425a2eaf
      3c/
        e0681e1f4cc2f18588f39ef811aec1a9c728a7
      3e/
        1472d4c46a635989af9f937c8fb8c16d176967
      3f/
        cd7d02499672f80fc0de114155142143e177d1
      41/
        9d11a1614e3cac4d0f9a62dde66ca36fe70511
        ebf0b8b3194e4c580f69f095fd5697303249c5
      42/
        e09b1e0c716a6e971d5155b2ca81fbd101aa47
      43/
        d183bd73b5ebda0ba1f10b48b0febc736566c3
      44/
        b8ef12f5185ceea2d22b8212c42ca97b097162
      48/
        f97c81497fac88d0cc19592491d275c59a08b0
      49/
        9a35f43c61437d640138eef9e074f95c2b3d36
      4e/
        9f8271c9879f43729f921e83506d3c57590c94
      4f/
        35f075139b3f1fc6c80fbeb45196ea18b81be2
      53/
        d349d9de8c8b0fddd6abcdc5cb3a4ce48a0402
      58/
        3603356740562f4e3e7774cda70a751afb78d8
      5b/
        7ab16898855c6a76ce1fc1838f38e5c356fa85
      5d/
        0638e090a30e5c35551a28a53505c3390f6a38
        6626484133c9a7212475f77d36c9f8cbc33b9d
      64/
        f86c6bd2bb30e3d22e752295eb7c7923fc191e
      69/
        bdf0bb296962940e4122ad4ddfc701bd9e6d2f
      6a/
        6277cadbfb71a47b094b3756e16b2e31f7f957
        d10f84b9edac946876d0b562fd5ef5c8f7523c
      6b/
        696529b1dee31abeffc23aa184bd88b7d55cac
      6e/
        13a9b4a62f3a6379663251d8a97ccd17deb9f6
      72/
        03a5b0e712a72f8564f432600cfe7310f66974
      75/
        295c643c8a1d14b1ebc8b6f52f5cca7cbca3c2
      77/
        b673d0550caf8c2bc57a1874cf4df8ce35beee
      78/
        cff2123db3e950574e0b580d9740f26fa6c2c0
      7a/
        05103cbb9951b05eef4184ae0ffbfece3a9c40
        aeba435465ad91b61848e9638c0cdbdc959b1b
        b239d8222c41dd98766a5085f2c18d4b63648a
      7f/
        36845c8062333f9c13d2ed422a086f936db5b9
      80/
        0ab6626a93cf841dafe1a987bdd34a3da7fcf3
      85/
        6d68300b15b099bce1d64a53c6db5e23cdffe2
      88/
        9b827f17a5d46a9525189561fbf33267e2b13d
        a5213d7c9c919920045fdca1405769e76dd198
      8b/
        cc7a8b4a0a8a69dd4194b5a18c0a6f92365e46
        e261e1630d761fdc1d0bbdf6969c4b93e48312
      8f/
        0f65f7e7f7a77781af65d82501109530d444f4
      91/
        904e15c73a5fb9cf3c08b806b15887fbc8b29a
      92/
        276750286b662ea06911a176cfa104e7dee93b
        7d7cca0badb13577152bf8753ce3552358f53b
        da18302ce61495039fcc54114578a8b3a40b19
      97/
        4cdab707e9cee022a599dbc2afaa41a852eb2e
      9a/
        142d5c537cba96f0fd65044abe2b71cd0f6c34
      9b/
        916683e99d583cc7b66fd5d74a66d29991eb9a
      a1/
        b07a2197b0b9db073ffe62c35c664a18463e12
      a2/
        0502b7f06d848452da0d93ce8830c1d86b05dd
        5da448f269f21de7990a231ecc880c5e964298
      a4/
        aebe19c3863d8a0c1af146a6f15a84f473e993
      aa/
        8d073aa454965dae05f1de14666f1222f4d88a
        8da494772426189aa578f2824228c5cee5e181
      ab/
        a29b0e7fc2bf29ccdb90b6e28aea6b11e60167
      ad/
        30fab2e80debb8fedbb99c35512accd1342259
      af/
        92bb2ec6e04092ffb4a6a372759f5077865740
      b3/
        e39f77582a325f92c2be8a3f7527f9b853a314
      b4/
        5d7e03dfb8d83041ed9ebecf49785365252b15
      b9/
        7c3456843d3c3b2f851c870a8d9238b3ad0f5c
      be/
        67cf0c6e1dc2bfbbacb710239af561cad7aa0a
      c0/
        0f91911c740592305583132abac37d873dc38e
        33b5cf302816c1dedf79eb93823eda7dd44d7b
        81dc1de96dcd915e17b0812b1cfd61dd669cbf
      c2/
        8d164cb5b4b06398c49158f85254d1cd99c5f9
      c3/
        026b301bbaa7f7ae3b33d8dae7c559969446a9
      c4/
        1668fcd79a4394f9fc4374a45410388b13e985
        50b32439ff88e6abc0635f134d101bef22f878
      c5/
        7a21ac9b2e78f7941d3a4dc155efd0ab52daf4
      c6/
        3e5bc6c6ee924c0eaa2c14a40cb90fbae93aeb
      cc/
        e879ee622146012901c9adb47ef40c0fd3a555
        ffa102188683c98e36b959e0c3a6cdc75d0f3c
      d2/
        2f3890a380cea30641cfecc329b5c794ef5fb2
      d3/
        bd21e287dbcd62006fdd2c208d19b651bb7f3c
      d5/
        182a9319dfecc277a81012480c8a4205855375
      d7/
        ec36458c8b77fba81a3e598d6d81d1487619de
      d8/
        053b565dd413b8e9852e6266eb3fdc52460282
      da/
        9d98c69e549cb1a25aa823dff5bc5e9f80858e
      dd/
        843ed072e6ab991190c9fba649e48bf924479e
      de/
        9974b9a80ae6b148b732c4abdf69a9910d0ce9
      e1/
        3aa2d180b26308fa1b5512663d569c36124507
      e2/
        b3a3855138f721e31b087a524f9238ddbe561b
      e6/
        9679f123df6e62bd6e8feeeeb248af3fb848aa
      e9/
        d912f3e3cefc18505d3cd19b3a5a9f567f5de0
      ea/
        a2a3068581bed92e1ada731bb86420ac1b3fa3
      ed/
        27605651a9d7fa8c7f174985318748dfc81519
        d3737cf2070c776e4e96a5f65ba78bdeff7c2c
      ee/
        2c9c64ad22c81d2c70f1700ee3a0f43a9f2ec1
      f0/
        0769eb50b4c25e40e769039228ef3a74b1b764
        4aafff8309c0655bd7883696bdddc3b97584b5
      f1/
        7cf2acd16d7496c05fa404ce4f26a123504dac
      f3/
        f5e7bd4738530ea3ad716f3b6bee0b7f67773c
      f4/
        118aa73623af0d0602ead2907eccf01e6aba45
        42377b9c392f5cca986c7f0754f6805857f63e
      f5/
        7c48593ff3eb0960652603d16ef6445ac80be2
      f7/
        6bc8d977be694622d923320f3d08d0fbb66e12
        9e5419b85b3e53733830728635f2fcdb673e0a
      f9/
        aa683b1ad5cffc76da9ad4b77c562ac4c2b399
      fb/
        4cdfee1282f2b735abc70f72db29ac7819c150
        ffa92c2bb7c748d6fc78f9f9dcac604dabb87d
      fd/
        1d96394ac4728a647611c5cd83db676866a5c2
      ff/
        4e3a45578919dc3c910b89b50185c41f94cdd3
    refs/
      heads/
        main
      remotes/
        origin/
          codex/
            fix-module-not-found-error
          main
    COMMIT_EDITMSG
    config
    FETCH_HEAD
    HEAD
    index
    ORIG_HEAD
  prisma/
    migrations/
      20260219201451_init/
        migration.sql
      20260221192920_add_payments/
        migration.sql
      20260221210510_add_tables/
        migration.sql
      20260222111806_add_inventory/
        migration.sql
      migration_lock.toml
    schema.prisma
    schema.prisma.save
    seed.ts
  scripts/
    create-main-entry.cjs
  src/
    auth/
      auth.controller.spec.ts
      auth.controller.ts
      auth.module.ts
      auth.service.spec.ts
      auth.service.ts
      jwt.strategy.ts
    events/
      events.gateway.spec.ts
      events.gateway.ts
      events.module.ts
    inventory/
      inventory.controller.spec.ts
      inventory.controller.ts
      inventory.module.ts
      inventory.service.spec.ts
      inventory.service.ts
    prisma/
      prisma.module.ts
      prisma.service.ts
    sync/
      sync.controller.spec.ts
      sync.controller.ts
      sync.module.ts
      sync.service.spec.ts
      sync.service.ts
    app.controller.spec.ts
    app.controller.ts
    app.module.ts
    app.service.ts
    main.ts
  test/
    app.e2e-spec.ts
    jest-e2e.json
  .gitignore
  .prettierrc
  .repomixignore
  docker-compose.yaml
  eslint.config.mjs
  nest-cli.json
  package.json
  prisma.config.ts
  README.md
  repomix-output.txt
  repomix.config.json
  tsconfig.build.json
  tsconfig.json
qristal-dashboard/
  .git/
    logs/
      refs/
        heads/
          main
        remotes/
          origin/
            main
      HEAD
    objects/
      05/
        e726d1b4201bc8c7716d2b058279676582e8c0
      09/
        d57bcde0ea070b03d3c24f3b493e67da5e74de
      14/
        090c4d8a875b5ac4117921ee70f0619e1b99d8
      1b/
        458579e874fcc3784b0bd50df171d353b70821
      5e/
        f6a520780202a1d6addd833d800ccb1ecac0bb
      61/
        e36849cf7cfa9f1f71b4a3964a4953e3e243d3
      73/
        fcc46e9d119e19ecac53983af4edbd43b99232
      84/
        2881313bcadaa86fcf20980dfc41531782f2e1
      91/
        3e14b9dcba3d2b4d0009df64810fc99ceae522
      94/
        a829ba6d8eaaab4b4f01e0b32d361be1836b6b
      9b/
        8c158d94660fb15074dd093a1511b08da5328a
      a2/
        982fad35bbcdf73e9758aea8ae012330693d9b
        dc41ecee5ec435200fe7cba2bde4107f823774
      ac/
        3b427c8c0bc2624128c3ff6374c66766471d85
        e694768c551ac3d889bc12cee8e573a3d12cd7
      b7/
        a45f3b4dc4d8835ccd776c4959db49feef9220
      c4/
        9d11194049a8afc58cc0228b5ac0d117ac701a
      ce/
        f8b4d40185846f74dfc3b3be1d8e1e3b919666
      cf/
        9c65d3e0676a0169374d827f7abb97497789ef
      d1/
        e9e2b1b91f9dfc5f430ecdd9437fd9a0e3ec24
      e2/
        15bc4ccf138bbc38ad58ad57e92135484b3c0f
      e9/
        ffa3083ad279ecf95fd8eae59cb253e9a539c4
      f7/
        fa87eb875260ed98651bc419c8139b5119e554
    refs/
      heads/
        main
      remotes/
        origin/
          main
    COMMIT_EDITMSG
    config
    FETCH_HEAD
    HEAD
    index
    ORIG_HEAD
  public/
    logo-512.png
  src/
    app/
      favicon.ico
      globals.css
      layout.tsx
      page.tsx
  .gitignore
  eslint.config.mjs
  next.config.ts
  package.json
  postcss.config.mjs
  README.md
  tsconfig.json
README.md
repomix.config.json

================================================================
Files
================================================================

================
File: qristal_mobile/.git/logs/refs/heads/main
================
0000000000000000000000000000000000000000 f9fa0d5265dee97a53a9e9ac08665dda4e38848e truthysys <truthysys@gmail.com> 1771608288 +0000	commit (initial): first commit
f9fa0d5265dee97a53a9e9ac08665dda4e38848e f9fa0d5265dee97a53a9e9ac08665dda4e38848e truthysys <truthysys@gmail.com> 1771608288 +0000	Branch: renamed refs/heads/main to refs/heads/main
f9fa0d5265dee97a53a9e9ac08665dda4e38848e ee6a0bd8f610bc39855162dd350b7bd4696ded8e truthysys <truthysys@gmail.com> 1771608576 +0000	commit: first mobile
ee6a0bd8f610bc39855162dd350b7bd4696ded8e 97dfa15b6df14d186dfb08a5310c0f249303ded7 truthysys <truthysys@gmail.com> 1771609423 +0000	commit: gradle
97dfa15b6df14d186dfb08a5310c0f249303ded7 058ec426c4d30f74356aeffd68596a986f95b70b truthysys <truthysys@gmail.com> 1771613590 +0000	pull --tags origin main: Fast-forward
058ec426c4d30f74356aeffd68596a986f95b70b da005db14b58a4846aab97ecd9cf74bbc109a8a5 truthysys <truthysys@gmail.com> 1771672455 +0000	commit: Render
da005db14b58a4846aab97ecd9cf74bbc109a8a5 1276453cd657ebf8fa6c71a5689a6dffce40c77c truthysys <truthysys@gmail.com> 1771697606 +0000	pull --tags origin main: Fast-forward
1276453cd657ebf8fa6c71a5689a6dffce40c77c 380685b91b0aaeeec4f44f714076565cd1b56e0f truthysys <truthysys@gmail.com> 1771702997 +0000	commit: payments
380685b91b0aaeeec4f44f714076565cd1b56e0f de3aa829e1d647605db3aea7930d9c072dff18d2 truthysys <truthysys@gmail.com> 1771703488 +0000	commit (merge): Merge branch 'main' of https://github.com/linTruthy/Qristal-POS-Mobile
de3aa829e1d647605db3aea7930d9c072dff18d2 21c6e74c9ca13b40534f6ca0a4af0ed4850ddc9e truthysys <truthysys@gmail.com> 1771707545 +0000	pull --tags origin main: Fast-forward
21c6e74c9ca13b40534f6ca0a4af0ed4850ddc9e f1697a692d7a381447d7d7ba1d47285708a306cc truthysys <truthysys@gmail.com> 1771709974 +0000	commit: bluetoo
f1697a692d7a381447d7d7ba1d47285708a306cc f512e2600760c43b747b9fac1ebfc957084a9944 truthysys <truthysys@gmail.com> 1771758884 +0000	pull --tags origin main: Fast-forward
f512e2600760c43b747b9fac1ebfc957084a9944 d6e6675a2f3039f6cb008cc6d9b80c382e6c3d25 truthysys <truthysys@gmail.com> 1771763787 +0000	commit: socket
d6e6675a2f3039f6cb008cc6d9b80c382e6c3d25 ea076e1c6416c3eb9ccc2532629b13a717baa4ec truthysys <truthysys@gmail.com> 1771764744 +0000	pull --tags origin main: Fast-forward
ea076e1c6416c3eb9ccc2532629b13a717baa4ec cbec4d3234da9f79cf5cd4f64c0108b040ee0327 truthysys <truthysys@gmail.com> 1771764980 +0000	commit: seed
cbec4d3234da9f79cf5cd4f64c0108b040ee0327 72488e07c20a9713788927da0670c8cf156081da truthysys <truthysys@gmail.com> 1771767392 +0000	commit: Id cart by codex
72488e07c20a9713788927da0670c8cf156081da 222151a1c25d31bdbc2fee55e5397f7c0364cedd truthysys <truthysys@gmail.com> 1771771624 +0000	commit: Order kds fix
222151a1c25d31bdbc2fee55e5397f7c0364cedd 072b762b162da4ccbe00cd4286712a41472e5535 truthysys <truthysys@gmail.com> 1771772902 +0000	commit: Reliable sync
072b762b162da4ccbe00cd4286712a41472e5535 54a08096d5ef364cba7f6e9209c7fe416f97710a truthysys <truthysys@gmail.com> 1771780249 +0000	commit: Sync order items

================
File: qristal_mobile/.git/logs/refs/remotes/origin/main
================
0000000000000000000000000000000000000000 f9fa0d5265dee97a53a9e9ac08665dda4e38848e truthysys <truthysys@gmail.com> 1771608289 +0000	update by push
f9fa0d5265dee97a53a9e9ac08665dda4e38848e ee6a0bd8f610bc39855162dd350b7bd4696ded8e truthysys <truthysys@gmail.com> 1771608582 +0000	update by push
ee6a0bd8f610bc39855162dd350b7bd4696ded8e 97dfa15b6df14d186dfb08a5310c0f249303ded7 truthysys <truthysys@gmail.com> 1771609428 +0000	update by push
97dfa15b6df14d186dfb08a5310c0f249303ded7 c1a4f929bc2bf4ff1297c6f31007860e019f4d31 truthysys <truthysys@gmail.com> 1771613243 +0000	fetch: fast-forward
c1a4f929bc2bf4ff1297c6f31007860e019f4d31 058ec426c4d30f74356aeffd68596a986f95b70b truthysys <truthysys@gmail.com> 1771613579 +0000	fetch: fast-forward
058ec426c4d30f74356aeffd68596a986f95b70b da005db14b58a4846aab97ecd9cf74bbc109a8a5 truthysys <truthysys@gmail.com> 1771672461 +0000	update by push
da005db14b58a4846aab97ecd9cf74bbc109a8a5 1276453cd657ebf8fa6c71a5689a6dffce40c77c truthysys <truthysys@gmail.com> 1771697576 +0000	fetch: fast-forward
1276453cd657ebf8fa6c71a5689a6dffce40c77c b9ccbe70af97c9d8b78c64c2c53b70636b18f7b5 truthysys <truthysys@gmail.com> 1771701909 +0000	fetch: fast-forward
b9ccbe70af97c9d8b78c64c2c53b70636b18f7b5 de3aa829e1d647605db3aea7930d9c072dff18d2 truthysys <truthysys@gmail.com> 1771704777 +0000	update by push
de3aa829e1d647605db3aea7930d9c072dff18d2 21c6e74c9ca13b40534f6ca0a4af0ed4850ddc9e truthysys <truthysys@gmail.com> 1771707537 +0000	fetch: fast-forward
21c6e74c9ca13b40534f6ca0a4af0ed4850ddc9e f1697a692d7a381447d7d7ba1d47285708a306cc truthysys <truthysys@gmail.com> 1771709980 +0000	update by push
f1697a692d7a381447d7d7ba1d47285708a306cc f512e2600760c43b747b9fac1ebfc957084a9944 truthysys <truthysys@gmail.com> 1771758864 +0000	fetch: fast-forward
f512e2600760c43b747b9fac1ebfc957084a9944 d6e6675a2f3039f6cb008cc6d9b80c382e6c3d25 truthysys <truthysys@gmail.com> 1771763792 +0000	update by push
d6e6675a2f3039f6cb008cc6d9b80c382e6c3d25 ea076e1c6416c3eb9ccc2532629b13a717baa4ec truthysys <truthysys@gmail.com> 1771764676 +0000	fetch: fast-forward
ea076e1c6416c3eb9ccc2532629b13a717baa4ec cbec4d3234da9f79cf5cd4f64c0108b040ee0327 truthysys <truthysys@gmail.com> 1771764985 +0000	update by push
cbec4d3234da9f79cf5cd4f64c0108b040ee0327 72488e07c20a9713788927da0670c8cf156081da truthysys <truthysys@gmail.com> 1771767398 +0000	update by push
72488e07c20a9713788927da0670c8cf156081da 222151a1c25d31bdbc2fee55e5397f7c0364cedd truthysys <truthysys@gmail.com> 1771771629 +0000	update by push
222151a1c25d31bdbc2fee55e5397f7c0364cedd 072b762b162da4ccbe00cd4286712a41472e5535 truthysys <truthysys@gmail.com> 1771772908 +0000	update by push
072b762b162da4ccbe00cd4286712a41472e5535 54a08096d5ef364cba7f6e9209c7fe416f97710a truthysys <truthysys@gmail.com> 1771780256 +0000	update by push
54a08096d5ef364cba7f6e9209c7fe416f97710a 40fc422ae526f8ece050736cb2d43c8fe957f605 truthysys <truthysys@gmail.com> 1771783176 +0000	fetch: fast-forward

================
File: qristal_mobile/.git/logs/HEAD
================
0000000000000000000000000000000000000000 f9fa0d5265dee97a53a9e9ac08665dda4e38848e truthysys <truthysys@gmail.com> 1771608288 +0000	commit (initial): first commit
f9fa0d5265dee97a53a9e9ac08665dda4e38848e 0000000000000000000000000000000000000000 truthysys <truthysys@gmail.com> 1771608288 +0000	Branch: renamed refs/heads/main to refs/heads/main
f9fa0d5265dee97a53a9e9ac08665dda4e38848e f9fa0d5265dee97a53a9e9ac08665dda4e38848e truthysys <truthysys@gmail.com> 1771608288 +0000	Branch: renamed refs/heads/main to refs/heads/main
f9fa0d5265dee97a53a9e9ac08665dda4e38848e ee6a0bd8f610bc39855162dd350b7bd4696ded8e truthysys <truthysys@gmail.com> 1771608576 +0000	commit: first mobile
ee6a0bd8f610bc39855162dd350b7bd4696ded8e 97dfa15b6df14d186dfb08a5310c0f249303ded7 truthysys <truthysys@gmail.com> 1771609423 +0000	commit: gradle
97dfa15b6df14d186dfb08a5310c0f249303ded7 058ec426c4d30f74356aeffd68596a986f95b70b truthysys <truthysys@gmail.com> 1771613590 +0000	pull --tags origin main: Fast-forward
058ec426c4d30f74356aeffd68596a986f95b70b da005db14b58a4846aab97ecd9cf74bbc109a8a5 truthysys <truthysys@gmail.com> 1771672455 +0000	commit: Render
da005db14b58a4846aab97ecd9cf74bbc109a8a5 1276453cd657ebf8fa6c71a5689a6dffce40c77c truthysys <truthysys@gmail.com> 1771697606 +0000	pull --tags origin main: Fast-forward
1276453cd657ebf8fa6c71a5689a6dffce40c77c 380685b91b0aaeeec4f44f714076565cd1b56e0f truthysys <truthysys@gmail.com> 1771702997 +0000	commit: payments
380685b91b0aaeeec4f44f714076565cd1b56e0f de3aa829e1d647605db3aea7930d9c072dff18d2 truthysys <truthysys@gmail.com> 1771703488 +0000	commit (merge): Merge branch 'main' of https://github.com/linTruthy/Qristal-POS-Mobile
de3aa829e1d647605db3aea7930d9c072dff18d2 21c6e74c9ca13b40534f6ca0a4af0ed4850ddc9e truthysys <truthysys@gmail.com> 1771707545 +0000	pull --tags origin main: Fast-forward
21c6e74c9ca13b40534f6ca0a4af0ed4850ddc9e f1697a692d7a381447d7d7ba1d47285708a306cc truthysys <truthysys@gmail.com> 1771709974 +0000	commit: bluetoo
f1697a692d7a381447d7d7ba1d47285708a306cc f512e2600760c43b747b9fac1ebfc957084a9944 truthysys <truthysys@gmail.com> 1771758884 +0000	pull --tags origin main: Fast-forward
f512e2600760c43b747b9fac1ebfc957084a9944 d6e6675a2f3039f6cb008cc6d9b80c382e6c3d25 truthysys <truthysys@gmail.com> 1771763787 +0000	commit: socket
d6e6675a2f3039f6cb008cc6d9b80c382e6c3d25 ea076e1c6416c3eb9ccc2532629b13a717baa4ec truthysys <truthysys@gmail.com> 1771764744 +0000	pull --tags origin main: Fast-forward
ea076e1c6416c3eb9ccc2532629b13a717baa4ec cbec4d3234da9f79cf5cd4f64c0108b040ee0327 truthysys <truthysys@gmail.com> 1771764980 +0000	commit: seed
cbec4d3234da9f79cf5cd4f64c0108b040ee0327 72488e07c20a9713788927da0670c8cf156081da truthysys <truthysys@gmail.com> 1771767392 +0000	commit: Id cart by codex
72488e07c20a9713788927da0670c8cf156081da 222151a1c25d31bdbc2fee55e5397f7c0364cedd truthysys <truthysys@gmail.com> 1771771624 +0000	commit: Order kds fix
222151a1c25d31bdbc2fee55e5397f7c0364cedd 072b762b162da4ccbe00cd4286712a41472e5535 truthysys <truthysys@gmail.com> 1771772902 +0000	commit: Reliable sync
072b762b162da4ccbe00cd4286712a41472e5535 54a08096d5ef364cba7f6e9209c7fe416f97710a truthysys <truthysys@gmail.com> 1771780249 +0000	commit: Sync order items

================
File: qristal_mobile/.git/refs/heads/main
================
54a08096d5ef364cba7f6e9209c7fe416f97710a

================
File: qristal_mobile/.git/refs/remotes/origin/main
================
40fc422ae526f8ece050736cb2d43c8fe957f605

================
File: qristal_mobile/.git/COMMIT_EDITMSG
================
Sync order items

================
File: qristal_mobile/.git/config
================
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
[remote "origin"]
	url = git@github.com:linTruthy/Qristal-POS-Mobile.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main
[pull]
	rebase = false

================
File: qristal_mobile/.git/FETCH_HEAD
================
40fc422ae526f8ece050736cb2d43c8fe957f605		branch 'main' of github.com:linTruthy/Qristal-POS-Mobile

================
File: qristal_mobile/.git/HEAD
================
ref: refs/heads/main

================
File: qristal_mobile/.git/ORIG_HEAD
================
54a08096d5ef364cba7f6e9209c7fe416f97710a

================
File: qristal-api/.git/refs/heads/main
================
856d68300b15b099bce1d64a53c6db5e23cdffe2

================
File: qristal-api/.git/refs/remotes/origin/codex/fix-module-not-found-error
================
f57c48593ff3eb0960652603d16ef6445ac80be2

================
File: qristal-api/.git/refs/remotes/origin/main
================
856d68300b15b099bce1d64a53c6db5e23cdffe2

================
File: qristal-api/.git/COMMIT_EDITMSG
================
Logging

================
File: qristal-api/.git/config
================
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
[remote "origin"]
	url = git@github.com:linTruthy/qristal-pos-api.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main

================
File: qristal-api/.git/FETCH_HEAD
================
856d68300b15b099bce1d64a53c6db5e23cdffe2		branch 'main' of github.com:linTruthy/qristal-pos-api
f57c48593ff3eb0960652603d16ef6445ac80be2	not-for-merge	branch 'codex/fix-module-not-found-error' of github.com:linTruthy/qristal-pos-api

================
File: qristal-api/.git/HEAD
================
ref: refs/heads/main

================
File: qristal-api/.git/ORIG_HEAD
================
856d68300b15b099bce1d64a53c6db5e23cdffe2

================
File: qristal-api/prisma/migrations/20260219201451_init/migration.sql
================
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('OWNER', 'MANAGER', 'CASHIER', 'WAITER', 'KITCHEN');

-- CreateEnum
CREATE TYPE "OrderStatus" AS ENUM ('OPEN', 'KITCHEN', 'SERVED', 'CLOSED', 'VOIDED');

-- CreateTable
CREATE TABLE "users" (
    "id" TEXT NOT NULL,
    "pin" TEXT NOT NULL,
    "role" "Role" NOT NULL DEFAULT 'WAITER',
    "full_name" TEXT NOT NULL,
    "branch_id" TEXT NOT NULL,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "deleted_at" TIMESTAMP(3),

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "categories" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "color_hex" TEXT,
    "sort_order" INTEGER NOT NULL DEFAULT 0,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "deleted_at" TIMESTAMP(3),

    CONSTRAINT "categories_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "products" (
    "id" TEXT NOT NULL,
    "category_id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "price" DECIMAL(10,2) NOT NULL,
    "is_available" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "deleted_at" TIMESTAMP(3),

    CONSTRAINT "products_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "orders" (
    "id" TEXT NOT NULL,
    "receipt_number" TEXT NOT NULL,
    "user_id" TEXT NOT NULL,
    "table_id" TEXT,
    "total_amount" DECIMAL(10,2) NOT NULL,
    "status" "OrderStatus" NOT NULL DEFAULT 'OPEN',
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "orders_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "order_items" (
    "id" TEXT NOT NULL,
    "order_id" TEXT NOT NULL,
    "product_id" TEXT NOT NULL,
    "quantity" INTEGER NOT NULL,
    "price_at_time_of_order" DECIMAL(10,2) NOT NULL,
    "notes" TEXT,

    CONSTRAINT "order_items_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_pin_key" ON "users"("pin");

-- AddForeignKey
ALTER TABLE "products" ADD CONSTRAINT "products_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "categories"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "orders" ADD CONSTRAINT "orders_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "order_items" ADD CONSTRAINT "order_items_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "orders"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "order_items" ADD CONSTRAINT "order_items_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "products"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

================
File: qristal-api/prisma/migrations/20260221192920_add_payments/migration.sql
================
-- CreateEnum
CREATE TYPE "PaymentMethod" AS ENUM ('CASH', 'CARD', 'MOBILE_MONEY', 'OTHER');

-- CreateTable
CREATE TABLE "payments" (
    "id" TEXT NOT NULL,
    "order_id" TEXT NOT NULL,
    "method" "PaymentMethod" NOT NULL,
    "amount" DECIMAL(10,2) NOT NULL,
    "reference" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "payments_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "payments" ADD CONSTRAINT "payments_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "orders"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

================
File: qristal-api/prisma/migrations/20260221210510_add_tables/migration.sql
================
-- CreateTable
CREATE TABLE "seating_tables" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "status" TEXT NOT NULL DEFAULT 'FREE',
    "capacity" INTEGER NOT NULL DEFAULT 4,
    "floor" TEXT NOT NULL DEFAULT 'Main',
    "x" INTEGER NOT NULL DEFAULT 0,
    "y" INTEGER NOT NULL DEFAULT 0,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "deleted_at" TIMESTAMP(3),

    CONSTRAINT "seating_tables_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "orders" ADD CONSTRAINT "orders_table_id_fkey" FOREIGN KEY ("table_id") REFERENCES "seating_tables"("id") ON DELETE SET NULL ON UPDATE CASCADE;

================
File: qristal-api/prisma/migrations/20260222111806_add_inventory/migration.sql
================
-- CreateTable
CREATE TABLE "inventory_items" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "sku" TEXT,
    "unitOfMeasure" TEXT NOT NULL,
    "currentStock" DECIMAL(10,4) NOT NULL DEFAULT 0,
    "minimumStock" DECIMAL(10,4) NOT NULL DEFAULT 0,
    "costPerUnit" DECIMAL(10,2) NOT NULL DEFAULT 0,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "inventory_items_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "recipe_ingredients" (
    "id" TEXT NOT NULL,
    "product_id" TEXT NOT NULL,
    "inventory_item_id" TEXT NOT NULL,
    "amount" DECIMAL(10,4) NOT NULL,

    CONSTRAINT "recipe_ingredients_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "inventory_items_sku_key" ON "inventory_items"("sku");

-- AddForeignKey
ALTER TABLE "recipe_ingredients" ADD CONSTRAINT "recipe_ingredients_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "products"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "recipe_ingredients" ADD CONSTRAINT "recipe_ingredients_inventory_item_id_fkey" FOREIGN KEY ("inventory_item_id") REFERENCES "inventory_items"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

================
File: qristal-api/prisma/migrations/migration_lock.toml
================
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"

================
File: qristal-api/prisma/schema.prisma
================
generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ------------------------------------------------------
// 1. AUTH & STAFF
// ------------------------------------------------------
enum Role {
  OWNER
  MANAGER
  CASHIER
  WAITER
  KITCHEN
}

model User {
  id           String    @id @default(uuid())
  pin          String    @unique // Hashed PIN for terminal login
  role         Role      @default(WAITER)
  fullName     String    @map("full_name")
  branchId     String    @map("branch_id") // Ready for Phase 3 (Multi-branch)
  isActive     Boolean   @default(true) @map("is_active")
  
  // Relations
  orders       Order[]
  
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")
  deletedAt    DateTime? @map("deleted_at") // Soft delete

  @@map("users")
}

// ------------------------------------------------------
// 2. MENU & PRODUCTS (Server is source of truth)
// ------------------------------------------------------
model Category {
  id           String    @id @default(uuid())
  name         String
  colorHex     String?   @map("color_hex") // For the POS UI (e.g., #FF5733)
  sortOrder    Int       @default(0) @map("sort_order")
  
  products     Product[]

  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at") // Used by terminal to detect changes
  deletedAt    DateTime? @map("deleted_at")

  @@map("categories")
}

model Product {
  id           String    @id @default(uuid())
  categoryId   String    @map("category_id")
  name         String
  price        Decimal   @db.Decimal(10, 2)
  isAvailable  Boolean   @default(true) @map("is_available")

  category     Category  @relation(fields: [categoryId], references: [id])
  orderItems   OrderItem[]

  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at") // The sync engine monitors this field heavily!
  deletedAt    DateTime? @map("deleted_at")

  recipe          RecipeIngredient[]

  @@map("products")
}

// ------------------------------------------------------
// 3. ORDERS (Terminals are source of truth, pushed to server)
// ------------------------------------------------------
enum OrderStatus {
  OPEN
  KITCHEN
  SERVED
  CLOSED
  VOIDED
}

model Order {
  id            String      @id @default(uuid()) // Terminals generate this UUID
  receiptNumber String      @map("receipt_number") // e.g., ORD-0001
  userId        String      @map("user_id") // Waiter who took the order
  tableId       String?     @map("table_id") // Nullable for takeaway
  totalAmount   Decimal     @db.Decimal(10, 2) @map("total_amount")
  status        OrderStatus @default(OPEN)
  
  user          User        @relation(fields: [userId], references: [id])
  items         OrderItem[]

  payments      Payment[]

  table         SeatingTable? @relation(fields: [tableId], references: [id])

  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")

  @@map("orders")
}

model OrderItem {
  id                  String   @id @default(uuid())
  orderId             String   @map("order_id")
  productId           String   @map("product_id")
  quantity            Int
  priceAtTimeOfOrder  Decimal  @db.Decimal(10, 2) @map("price_at_time_of_order") // Financial integrity
  notes               String?  // e.g. "Extra spicy"
  
  order               Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product             Product  @relation(fields: [productId], references: [id])

  @@map("order_items")
}

enum PaymentMethod {
  CASH
  CARD
  MOBILE_MONEY
  OTHER
}

model Payment {
  id            String        @id @default(uuid())
  orderId       String        @map("order_id")
  method        PaymentMethod
  amount        Decimal       @db.Decimal(10, 2)
  reference     String?       // For Mobile Money Ref / Card Auth Code
  createdAt     DateTime      @default(now()) @map("created_at")

  order         Order         @relation(fields: [orderId], references: [id])

  @@map("payments")
}

model SeatingTable {
  id        String   @id @default(uuid())
  name      String   // e.g., "T-1", "Bar-2"
  status    String   @default("FREE") // FREE, OCCUPIED, RESERVED
  capacity  Int      @default(4)
  floor     String   @default("Main") // Main, Terrace, VIP
  
  // Coordinates for future Drag-n-Drop UI
  x         Int      @default(0) 
  y         Int      @default(0)

  orders    Order[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at")

  @@map("seating_tables")
}

// ------------------------------------------------------
// 4. INVENTORY & RECIPES
// ------------------------------------------------------

model InventoryItem {
  id              String   @id @default(uuid())
  name            String   // e.g., "Coffee Beans", "Milk", "Burger Bun"
  sku             String?  @unique
  unitOfMeasure   String   // e.g., "Kg", "Liters", "Pieces", "Grams"
  currentStock    Decimal  @default(0) @db.Decimal(10, 4)
  minimumStock    Decimal  @default(0) @db.Decimal(10, 4) // For low stock alerts
  costPerUnit     Decimal  @default(0) @db.Decimal(10, 2)
  
  recipeIngredients RecipeIngredient[]

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@map("inventory_items")
}

// A Recipe links a Product (what you sell) to InventoryItems (what you use)
model RecipeIngredient {
  id              String   @id @default(uuid())
  productId       String   @map("product_id")
  inventoryItemId String   @map("inventory_item_id")
  
  // How much of the inventory item is used to make ONE of the product
  // e.g., 1 Cappuccino uses 15 (amount) Grams (from InventoryItem unit) of Coffee Beans
  amount          Decimal  @db.Decimal(10, 4) 

  product         Product       @relation(fields: [productId], references: [id], onDelete: Cascade)
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Restrict)

  @@map("recipe_ingredients")
}

================
File: qristal-api/prisma/schema.prisma.save
================
generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
}

// ------------------------------------------------------
// 1. AUTH & STAFF
// ------------------------------------------------------
enum Role {
  OWNER
  MANAGER
  CASHIER
  WAITER
  KITCHEN
}

model User {
  id           String    @id @default(uuid())
  pin          String    @unique // Hashed PIN for terminal login
  role         Role      @default(WAITER)
  fullName     String    @map("full_name")
  branchId     String    @map("branch_id") // Ready for Phase 3 (Multi-branch)
  isActive     Boolean   @default(true) @map("is_active")
  
  // Relations
  orders       Order[]
  
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")
  deletedAt    DateTime? @map("deleted_at") // Soft delete

  @@map("users")
}

// ------------------------------------------------------
// 2. MENU & PRODUCTS (Server is source of truth)
// ------------------------------------------------------
model Category {
  id           String    @id @default(uuid())
  name         String
  colorHex     String?   @map("color_hex") // For the POS UI (e.g., #FF5733)
  sortOrder    Int       @default(0) @map("sort_order")
  
  products     Product[]

  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at") // Used by terminal to detect changes
  deletedAt    DateTime? @map("deleted_at")

  @@map("categories")
}

model Product {
  id           String    @id @default(uuid())
  categoryId   String    @map("category_id")
  name         String
  price        Decimal   @db.Decimal(10, 2)
  isAvailable  Boolean   @default(true) @map("is_available")

  category     Category  @relation(fields: [categoryId], references: [id])
  orderItems   OrderItem[]

  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at") // The sync engine monitors this field heavily!
  deletedAt    DateTime? @map("deleted_at")

  @@map("products")
}

// ------------------------------------------------------
// 3. ORDERS (Terminals are source of truth, pushed to server)
// ------------------------------------------------------
enum OrderStatus {
  OPEN
  KITCHEN
  SERVED
  CLOSED
  VOIDED
}

model Order {
  id            String      @id @default(uuid()) // Terminals generate this UUID
  receiptNumber String      @map("receipt_number") // e.g., ORD-0001
  userId        String      @map("user_id") // Waiter who took the order
  tableId       String?     @map("table_id") // Nullable for takeaway
  totalAmount   Decimal     @db.Decimal(10, 2) @map("total_amount")
  status        OrderStatus @default(OPEN)
  
  user          User        @relation(fields: [userId], references: [id])
  items         OrderItem[]

  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")

  @@map("orders")
}

model OrderItem {
  id                  String   @id @default(uuid())
  orderId             String   @map("order_id")
  productId           String   @map("product_id")
  quantity            Int
  priceAtTimeOfOrder  Decimal  @db.Decimal(10, 2) @map("price_at_time_of_order") // Financial integrity
  notes               String?  // e.g. "Extra spicy"
  
  order               Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product             Product  @relation(fields: [productId], references: [id])

  @@map("order_items")
}
x

================
File: qristal-api/prisma/seed.ts
================
import { PrismaClient } from '@prisma/client';
import * as bcrypt from 'bcrypt';

const prisma = new PrismaClient();

async function main() {
  console.log('Clearing database...');
  await prisma.orderItem.deleteMany();
  await prisma.order.deleteMany();
  await prisma.product.deleteMany();
  await prisma.category.deleteMany();
  await prisma.user.deleteMany();
  await prisma.inventoryItem.deleteMany();
  await prisma.recipeIngredient.deleteMany();
  await prisma.seatingTable.deleteMany();


  console.log('Seeding data...');

  // 1. Create a User
  const hashedPin = await bcrypt.hash('1234', 10);
  const admin = await prisma.user.create({
    data: {
      fullName: 'Admin User',
      pin: hashedPin,
      role: 'OWNER',
      branchId: 'BRANCH-01',
      isActive: true,
    },
  });

  // 2. Create Categories
  const catDrinks = await prisma.category.create({
    data: { name: 'Drinks', colorHex: '#3498db', sortOrder: 1 },
  });

  const catFood = await prisma.category.create({
    data: { name: 'Food', colorHex: '#e67e22', sortOrder: 2 },
  });

  // 3. Create Products
  await prisma.product.createMany({
    data: [
      {
        categoryId: catDrinks.id,
        name: 'Coffee',
        price: 2.50,
        isAvailable: true,
      },
      {
        categoryId: catDrinks.id,
        name: 'Soda',
        price: 1.50,
        isAvailable: true,
      },
      {
        categoryId: catFood.id,
        name: 'Burger',
        price: 8.50,
        isAvailable: true,
      },
      {
        categoryId: catFood.id,
        name: 'Fries',
        price: 3.00,
        isAvailable: true,
      },
    ],
  });

  console.log('Seeding Inventory...');
  
  const coffeeBeans = await prisma.inventoryItem.create({
    data: { name: 'Espresso Beans', unitOfMeasure: 'Grams', currentStock: 5000, costPerUnit: 0.05 }
  });

  const milk = await prisma.inventoryItem.create({
     data: { name: 'Whole Milk', unitOfMeasure: 'Liters', currentStock: 20, costPerUnit: 2000 }
  });

  const bun = await prisma.inventoryItem.create({
    data: { name: 'Brioche Bun', unitOfMeasure: 'Pieces', currentStock: 100, costPerUnit: 500 }
  });

  const beefPatty = await prisma.inventoryItem.create({
    data: { name: 'Beef Patty 150g', unitOfMeasure: 'Pieces', currentStock: 100, costPerUnit: 2500 }
  });

  console.log('Creating Recipes...');
  
  // Find the Coffee product we created earlier
  const coffee = await prisma.product.findFirst({ where: { name: 'Coffee' }});
  if (coffee) {
    await prisma.recipeIngredient.createMany({
        data: [
            { productId: coffee.id, inventoryItemId: coffeeBeans.id, amount: 18 }, // 18 grams of beans
            { productId: coffee.id, inventoryItemId: milk.id, amount: 0.2 },       // 200ml milk
        ]
    });
  }

  // Find the Burger product
  const burger = await prisma.product.findFirst({ where: { name: 'Burger' }});
  if (burger) {
    await prisma.recipeIngredient.createMany({
        data: [
            { productId: burger.id, inventoryItemId: bun.id, amount: 1 }, 
            { productId: burger.id, inventoryItemId: beefPatty.id, amount: 1 },
        ]
    });
  }
  
  console.log('Seeding Tables...');
  await prisma.seatingTable.createMany({
    data: [
      { name: 'T-01', status: 'FREE', floor: 'Main', x: 0, y: 0 },
      { name: 'T-02', status: 'FREE', floor: 'Main', x: 1, y: 0 },
      { name: 'T-03', status: 'OCCUPIED', floor: 'Main', x: 2, y: 0 }, // Mocking an active table
      { name: 'VIP-1', status: 'FREE', floor: 'VIP', x: 0, y: 1 },
    ]
  });

  console.log('Seed data created successfully!');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

================
File: qristal-api/scripts/create-main-entry.cjs
================
const { writeFileSync } = require('node:fs');
const { join } = require('node:path');

const entrypointPath = join(__dirname, '..', 'dist', 'main.js');
writeFileSync(entrypointPath, "require('./src/main.js');\n", 'utf8');
console.log(`Created ${entrypointPath}`);

================
File: qristal-api/src/auth/auth.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AuthController } from './auth.controller';

describe('AuthController', () => {
  let controller: AuthController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
    }).compile();

    controller = module.get<AuthController>(AuthController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: qristal-api/src/auth/auth.controller.ts
================
// src/auth/auth.controller.ts
import { Controller, Post, Body, UnauthorizedException } from '@nestjs/common';
import { AuthService } from './auth.service';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('login')
  async login(@Body() body: { id: string; pin: string }) {
    const user = await this.authService.validateUser(body.id, body.pin);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }
    return this.authService.login(user);
  }
}

================
File: qristal-api/src/auth/auth.module.ts
================
// src/auth/auth.module.ts
import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { JwtStrategy } from './jwt.strategy';

@Module({
  imports: [
    PassportModule,
    JwtModule.register({
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '24h' },
    }),
  ],
  providers: [AuthService, JwtStrategy],
  controllers: [AuthController],
})
export class AuthModule {}

================
File: qristal-api/src/auth/auth.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from './auth.service';

describe('AuthService', () => {
  let service: AuthService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [AuthService],
    }).compile();

    service = module.get<AuthService>(AuthService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: qristal-api/src/auth/auth.service.ts
================
// src/auth/auth.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { PrismaService } from '../prisma/prisma.service';
import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  constructor(
    private prisma: PrismaService,
    private jwtService: JwtService
  ) {}

  async validateUser(userId: string, pin: string): Promise<any> {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
    });

    if (user && (await bcrypt.compare(pin, user.pin))) {
      const { pin, ...result } = user;
      return result;
    }
    return null;
  }

  async login(user: any) {
    const payload = { sub: user.id, role: user.role, branchId: user.branchId };
    return {
      access_token: this.jwtService.sign(payload),
      user: user
    };
  }
}

================
File: qristal-api/src/auth/jwt.strategy.ts
================
// src/auth/jwt.strategy.ts
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: process.env.JWT_SECRET,
    });
  }

  async validate(payload: any) {
    // This return value is added to Request object (req.user)
    return { userId: payload.sub, role: payload.role, branchId: payload.branchId };
  }
}

================
File: qristal-api/src/events/events.gateway.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { EventsGateway } from './events.gateway';

describe('EventsGateway', () => {
  let gateway: EventsGateway;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [EventsGateway],
    }).compile();

    gateway = module.get<EventsGateway>(EventsGateway);
  });

  it('should be defined', () => {
    expect(gateway).toBeDefined();
  });
});

================
File: qristal-api/src/events/events.gateway.ts
================
import {
  WebSocketGateway,
  WebSocketServer,
  OnGatewayConnection,
  OnGatewayDisconnect,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Logger } from '@nestjs/common';

// Allow any origin for now to avoid CORS issues during dev/testing across devices
@WebSocketGateway({
  cors: {
    origin: '*',
  },
})
export class EventsGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  private logger: Logger = new Logger('EventsGateway');

  handleConnection(client: Socket) {
    this.logger.log(`Client connected: ${client.id}`);
  }

  handleDisconnect(client: Socket) {
    this.logger.log(`Client disconnected: ${client.id}`);
  }

  // --- Methods to emit events from other services ---

  // Call this when an order is received from the POS
  emitNewOrder(orderData: any) {
    this.server.emit('newOrder', orderData);
  }

  // Call this when inventory is updated
  emitInventoryUpdate(inventoryData: any) {
    this.server.emit('inventoryUpdate', inventoryData);
  }
}

================
File: qristal-api/src/events/events.module.ts
================
import { Module } from '@nestjs/common';
import { EventsGateway } from './events.gateway';

@Module({
  providers: [EventsGateway],
  exports: [EventsGateway], // Export the gateway to be used in other modules
})
export class EventsModule {}

================
File: qristal-api/src/inventory/inventory.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { InventoryController } from './inventory.controller';

describe('InventoryController', () => {
  let controller: InventoryController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [InventoryController],
    }).compile();

    controller = module.get<InventoryController>(InventoryController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: qristal-api/src/inventory/inventory.controller.ts
================
import { Controller, Get } from '@nestjs/common';
import { InventoryService } from './inventory.service';

@Controller('inventory')
export class InventoryController {
  constructor(private readonly inventoryService: InventoryService) {}

  @Get()
  async getInventory() {
    return this.inventoryService.getInventoryStatus();
  }
}

================
File: qristal-api/src/inventory/inventory.module.ts
================
import { Module } from '@nestjs/common';
import { InventoryService } from './inventory.service';
import { InventoryController } from './inventory.controller';

@Module({
  controllers: [InventoryController],
  providers: [InventoryService],
  exports: [InventoryService], // <-- Crucial: Export so SyncModule can use it
})
export class InventoryModule {}

================
File: qristal-api/src/inventory/inventory.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { InventoryService } from './inventory.service';

describe('InventoryService', () => {
  let service: InventoryService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [InventoryService],
    }).compile();

    service = module.get<InventoryService>(InventoryService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: qristal-api/src/inventory/inventory.service.ts
================
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class InventoryService {
  private readonly logger = new Logger(InventoryService.name);

  constructor(private prisma: PrismaService) {}

  /**
   * Processes inventory deductions for a given order.
   * This should be called after an order is successfully synced from the POS.
   */
  async deductStockForOrder(orderId: string) {
    try {
      // 1. Fetch the order and its items
      const order = await this.prisma.order.findUnique({
        where: { id: orderId },
        include: { items: true },
      });

      if (!order) {
        this.logger.error(`Order ${orderId} not found for inventory deduction.`);
        return;
      }

      this.logger.log(`Processing inventory for Order: ${order.receiptNumber}`);

      // 2. Loop through each item in the order
      for (const orderItem of order.items) {
        
        // 3. Find the recipe for this product
        const recipeIngredients = await this.prisma.recipeIngredient.findMany({
          where: { productId: orderItem.productId },
        });

        if (recipeIngredients.length === 0) {
            // It's a product without a recipe (maybe a retail item), skip deduction or handle retail logic.
            continue; 
        }

        // 4. Calculate total deduction and update inventory
        for (const ingredient of recipeIngredients) {
            // quantity ordered * amount needed per item
            const totalDeduction = Number(orderItem.quantity) * Number(ingredient.amount);

            await this.prisma.inventoryItem.update({
                where: { id: ingredient.inventoryItemId },
                data: {
                    currentStock: {
                        decrement: totalDeduction
                    }
                }
            });

            this.logger.debug(`Deducted ${totalDeduction} from InventoryItem ${ingredient.inventoryItemId}`);
        }
      }
    } catch (error) {
        this.logger.error(`Failed to deduct inventory for order ${orderId}: ${error.message}`);
    }
  }

  async getInventoryStatus() {
    return this.prisma.inventoryItem.findMany({
      orderBy: { currentStock: 'asc' }, // Order by lowest stock first
    });
  }
}

================
File: qristal-api/src/prisma/prisma.module.ts
================
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global() // Makes PrismaService available everywhere without importing the module
@Module({
    providers: [PrismaService],
    exports: [PrismaService],
})
export class PrismaModule {}

================
File: qristal-api/src/prisma/prisma.service.ts
================
import { INestApplication, Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
  }
}

================
File: qristal-api/src/sync/sync.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { SyncController } from './sync.controller';

describe('SyncController', () => {
  let controller: SyncController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [SyncController],
    }).compile();

    controller = module.get<SyncController>(SyncController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: qristal-api/src/sync/sync.controller.ts
================
// src/sync/sync.controller.ts
import { Controller, Get, Post, Body, Query, UseGuards } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport'; // Built-in guard
import { SyncService } from './sync.service';

@Controller('sync')
@UseGuards(AuthGuard('jwt')) // This protects all routes in this controller
export class SyncController {
    constructor(private readonly syncService: SyncService) { }

    @Get('pull')
    async pull(@Query('lastSyncTimestamp') lastSyncTimestamp: string) {
        return this.syncService.pullChanges(lastSyncTimestamp);
    }

    @Post('push')
    async push(@Body() payload: any) {
        return this.syncService.pushChanges(payload);
    }
}

================
File: qristal-api/src/sync/sync.module.ts
================
import { Module } from '@nestjs/common';
import { SyncService } from './sync.service';
import { SyncController } from './sync.controller';
import { EventsModule } from '../events/events.module'; // Import the module
import { InventoryModule } from '../inventory/inventory.module'; // Also need this for deductStockForOrder

@Module({
  imports: [
    EventsModule,    // <-- Import EventsModule here
    InventoryModule  // <-- Import InventoryModule here
  ],
  controllers: [SyncController],
  providers: [SyncService],
})
export class SyncModule {}

================
File: qristal-api/src/sync/sync.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { SyncService } from './sync.service';

describe('SyncService', () => {
  let service: SyncService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [SyncService],
    }).compile();

    service = module.get<SyncService>(SyncService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: qristal-api/src/sync/sync.service.ts
================
import { Injectable, BadRequestException, Logger } from '@nestjs/common'; // Import Logger
import { PrismaService } from '../prisma/prisma.service';
import { EventsGateway } from '../events/events.gateway';
import { InventoryService } from '../inventory/inventory.service';
import { Order } from '@prisma/client';

@Injectable()
export class SyncService {
  private readonly logger = new Logger(SyncService.name); // Instantiate Logger

  constructor(private prisma: PrismaService,
    private inventoryService: InventoryService,
    private eventsGateway: EventsGateway
  ) { }

  async pullChanges(lastSyncTimestamp: string) {
    // ... (omitted for brevity)
    let lastSyncDate: Date;

    if (!lastSyncTimestamp) {
      lastSyncDate = new Date(0);
    } else {
      lastSyncDate = new Date(lastSyncTimestamp);
      if (isNaN(lastSyncDate.getTime())) {
        throw new BadRequestException('Invalid lastSyncTimestamp format.');
      }
    }

    const [categories, products, users, seatingTables, orders] = await Promise.all([
      this.prisma.category.findMany({
        where: { updatedAt: { gt: lastSyncDate } },
      }),
      this.prisma.product.findMany({
        where: { updatedAt: { gt: lastSyncDate } },
      }),
      this.prisma.user.findMany({
        where: { updatedAt: { gt: lastSyncDate } },
      }),
      this.prisma.seatingTable.findMany({
        where: { updatedAt: { gt: lastSyncDate } },
      }),
      this.prisma.order.findMany({
        where: { updatedAt: { gt: lastSyncDate } },
      }),
    ]);

    return {
      timestamp: new Date().toISOString(),
      changes: {
        categories,
        products,
        users,
        seatingTables,
        orders,
      },
    };
  }

  async pushChanges(payload: any) {
    // ---- START OF DIAGNOSTIC LOGGING ----
    this.logger.log('Received pushChanges payload:');
    this.logger.log(JSON.stringify(payload, null, 2));
    // ---- END OF DIAGNOSTIC LOGGING ----

    const { orders, orderItems, payments } = payload;
    const errors: { id: any; error: any }[] = [];
    let processedOrders = 0;

    const newOrderIdsToDeduct: string[] = [];
    const newlyCreatedOrdersForKDS: Order[] = [];

    try {
      await this.prisma.$transaction(async (tx) => {
        if (orders && Array.isArray(orders)) {
          for (const order of orders) {
            try {
              const existing = await tx.order.findUnique({ where: { id: order.id } });
              const savedOrder = await tx.order.upsert({
                where: { id: order.id },
                update: {
                  status: order.status,
                  totalAmount: order.totalAmount,
                  updatedAt: new Date(),
                },
                create: {
                  id: order.id,
                  receiptNumber: order.receiptNumber,
                  userId: order.userId,
                  tableId: order.tableId,
                  totalAmount: order.totalAmount,
                  status: order.status,
                  createdAt: new Date(order.createdAt),
                },
              });
              processedOrders++;
              if (!existing) {
                newOrderIdsToDeduct.push(order.id);
                newlyCreatedOrdersForKDS.push(savedOrder);
              }

            } catch (err) {
              errors.push({ id: order.id, error: err.message });
            }
          }
        }

        if (orderItems && Array.isArray(orderItems)) {
          for (const item of orderItems) {
            try {
              await tx.orderItem.upsert({
                where: { id: item.id },
                update: {
                  quantity: item.quantity,
                  notes: item.notes,
                },
                create: {
                  id: item.id,
                  orderId: item.orderId,
                  productId: item.productId,
                  quantity: item.quantity,
                  priceAtTimeOfOrder: item.priceAtTimeOfOrder,
                  notes: item.notes,
                },
              });
            } catch (err) {
              errors.push({ id: item.id, error: err.message });
            }
          }
        }

        if (payments && Array.isArray(payments)) {
          for (const pay of payments) {
            try {
              await tx.payment.create({
                data: {
                  id: pay.id,
                  orderId: pay.orderId,
                  method: pay.method,
                  amount: pay.amount,
                  reference: pay.reference,
                  createdAt: new Date(pay.createdAt),
                }
              });
            } catch (err) {
              if (!err.message.includes('Unique constraint')) {
                errors.push({ id: pay.id, error: err.message });
              }
            }
          }
        }
      });

      for (const orderId of newOrderIdsToDeduct) {
        this.inventoryService.deductStockForOrder(orderId).catch(e =>
          console.error(`Inventory deduction failed async: ${e}`)
        );
      }
      if (newlyCreatedOrdersForKDS.length > 0) {
        this.eventsGateway.emitNewOrder({ message: 'New orders arrived!' });
      }

      for (const orderId of newOrderIdsToDeduct) {
        this.inventoryService.deductStockForOrder(orderId).then(async () => {
          const latestInventory = await this.inventoryService.getInventoryStatus();
          this.eventsGateway.emitInventoryUpdate(latestInventory);
        }).catch(e => console.error(e));
      }
      return {
        success: true,
        processedOrders,
        errors: errors.length > 0 ? errors : undefined,
      };

    } catch (error) {
      throw new BadRequestException(`Push sync failed: ${error.message}`);
    }
  }
}

================
File: qristal-api/src/app.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});

================
File: qristal-api/src/app.controller.ts
================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

================
File: qristal-api/src/app.module.ts
================
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PrismaModule } from './prisma/prisma.module';
import { SyncModule } from './sync/sync.module';
import { AuthModule } from './auth/auth.module';
import { InventoryModule } from './inventory/inventory.module';
import { EventsModule } from './events/events.module';

@Module({
  imports: [PrismaModule, SyncModule, AuthModule, InventoryModule, EventsModule],  // Add PrismaModule here
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule { }

================
File: qristal-api/src/app.service.ts
================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

================
File: qristal-api/src/main.ts
================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Enable CORS so your Flutter Web/Mobile can talk to it
  app.enableCors(); 
  
  // Listen on 0.0.0.0 to accept external connections in Docker/Railway
  await app.listen(process.env.PORT || 3000, '0.0.0.0');
  
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();

================
File: qristal-api/test/app.e2e-spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import request from 'supertest';
import { App } from 'supertest/types';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication<App>;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});

================
File: qristal-api/test/jest-e2e.json
================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}

================
File: qristal-api/.gitignore
================
# compiled output
/dist
/node_modules
/build

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

/generated/prisma

================
File: qristal-api/.prettierrc
================
{
  "singleQuote": true,
  "trailingComma": "all"
}

================
File: qristal-api/.repomixignore
================
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

================
File: qristal-api/docker-compose.yaml
================
version: '3.8'
services:
  postgres:
    image: postgres:15-alpine
    restart: always
    environment:
      POSTGRES_USER: qristal_user
      POSTGRES_PASSWORD: qristal_password
      POSTGRES_DB: qristal_db
    ports:
      - '5432:5432'
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:

================
File: qristal-api/eslint.config.mjs
================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      sourceType: 'commonjs',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'warn',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      "prettier/prettier": ["error", { endOfLine: "auto" }],
    },
  },
);

================
File: qristal-api/nest-cli.json
================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}

================
File: qristal-api/package.json
================
{
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  },
  "name": "qristal-api",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build && node scripts/create-main-entry.cjs",
    "postinstall": "npx prisma generate",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "dependencies": {
    "@nestjs/cli": "^11.0.0",
    "@nestjs/common": "^11.0.1",
    "@nestjs/core": "^11.0.1",
    "@nestjs/jwt": "^11.0.2",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^11.0.1",
    "@nestjs/platform-socket.io": "^11.1.14",
    "@nestjs/swagger": "^11.2.6",
    "@nestjs/websockets": "^11.1.14",
    "@prisma/client": "^5.22.0",
    "bcrypt": "^6.0.0",
    "passport-jwt": "^4.0.1",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "socket.io": "^4.8.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@prisma/config": "^7.4.1",
    "@types/bcrypt": "^6.0.0",
    "@types/express": "^5.0.0",
    "@types/jest": "^30.0.0",
    "@types/node": "^22.10.7",
    "@types/supertest": "^6.0.2",
    "dotenv": "^17.3.1",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^30.0.0",
    "prettier": "^3.4.2",
    "prisma": "^5.22.0",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

================
File: qristal-api/prisma.config.ts
================
import "dotenv/config";
import { defineConfig, env } from "@prisma/config";

export default defineConfig({
  schema: "prisma/schema.prisma",
  datasource: {
    url: env("DATABASE_URL"),
  },
});

================
File: qristal-api/README.md
================
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ npm install
```

## Compile and run the project

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Run tests

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Deployment

When you're ready to deploy your NestJS application to production, there are some key steps you can take to ensure it runs as efficiently as possible. Check out the [deployment documentation](https://docs.nestjs.com/deployment) for more information.

If you are looking for a cloud-based platform to deploy your NestJS application, check out [Mau](https://mau.nestjs.com), our official platform for deploying NestJS applications on AWS. Mau makes deployment straightforward and fast, requiring just a few simple steps:

```bash
$ npm install -g @nestjs/mau
$ mau deploy
```

With Mau, you can deploy your application in just a few clicks, allowing you to focus on building features rather than managing infrastructure.

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Deploy your application to AWS with the help of [NestJS Mau](https://mau.nestjs.com) in just a few clicks.
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).

================
File: qristal-api/repomix-output.txt
================
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
prisma/
  migrations/
    20260219201451_init/
      migration.sql
    20260221192920_add_payments/
      migration.sql
    20260221210510_add_tables/
      migration.sql
    20260222111806_add_inventory/
      migration.sql
    migration_lock.toml
  schema.prisma
  schema.prisma.save
  seed.ts
scripts/
  create-main-entry.cjs
src/
  auth/
    auth.controller.spec.ts
    auth.controller.ts
    auth.module.ts
    auth.service.spec.ts
    auth.service.ts
    jwt.strategy.ts
  events/
    events.gateway.spec.ts
    events.gateway.ts
  inventory/
    inventory.controller.spec.ts
    inventory.controller.ts
    inventory.module.ts
    inventory.service.spec.ts
    inventory.service.ts
  prisma/
    prisma.module.ts
    prisma.service.ts
  sync/
    sync.controller.spec.ts
    sync.controller.ts
    sync.module.ts
    sync.service.spec.ts
    sync.service.ts
  app.controller.spec.ts
  app.controller.ts
  app.module.ts
  app.service.ts
  main.ts
test/
  app.e2e-spec.ts
  jest-e2e.json
.gitignore
.prettierrc
.repomixignore
docker-compose.yaml
eslint.config.mjs
nest-cli.json
package.json
prisma.config.ts
README.md
repomix.config.json
tsconfig.build.json
tsconfig.json

================================================================
Files
================================================================

================
File: .repomixignore
================
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

================
File: repomix.config.json
================
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output.txt",
    "style": "plain",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "includeFullDirectoryStructure": false,
    "tokenCountTree": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false,
      "includeLogs": false,
      "includeLogsCount": 50
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDotIgnore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}

================
File: prisma/migrations/20260219201451_init/migration.sql
================
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('OWNER', 'MANAGER', 'CASHIER', 'WAITER', 'KITCHEN');

-- CreateEnum
CREATE TYPE "OrderStatus" AS ENUM ('OPEN', 'KITCHEN', 'SERVED', 'CLOSED', 'VOIDED');

-- CreateTable
CREATE TABLE "users" (
    "id" TEXT NOT NULL,
    "pin" TEXT NOT NULL,
    "role" "Role" NOT NULL DEFAULT 'WAITER',
    "full_name" TEXT NOT NULL,
    "branch_id" TEXT NOT NULL,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "deleted_at" TIMESTAMP(3),

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "categories" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "color_hex" TEXT,
    "sort_order" INTEGER NOT NULL DEFAULT 0,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "deleted_at" TIMESTAMP(3),

    CONSTRAINT "categories_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "products" (
    "id" TEXT NOT NULL,
    "category_id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "price" DECIMAL(10,2) NOT NULL,
    "is_available" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "deleted_at" TIMESTAMP(3),

    CONSTRAINT "products_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "orders" (
    "id" TEXT NOT NULL,
    "receipt_number" TEXT NOT NULL,
    "user_id" TEXT NOT NULL,
    "table_id" TEXT,
    "total_amount" DECIMAL(10,2) NOT NULL,
    "status" "OrderStatus" NOT NULL DEFAULT 'OPEN',
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "orders_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "order_items" (
    "id" TEXT NOT NULL,
    "order_id" TEXT NOT NULL,
    "product_id" TEXT NOT NULL,
    "quantity" INTEGER NOT NULL,
    "price_at_time_of_order" DECIMAL(10,2) NOT NULL,
    "notes" TEXT,

    CONSTRAINT "order_items_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_pin_key" ON "users"("pin");

-- AddForeignKey
ALTER TABLE "products" ADD CONSTRAINT "products_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "categories"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "orders" ADD CONSTRAINT "orders_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "order_items" ADD CONSTRAINT "order_items_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "orders"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "order_items" ADD CONSTRAINT "order_items_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "products"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

================
File: prisma/migrations/20260221192920_add_payments/migration.sql
================
-- CreateEnum
CREATE TYPE "PaymentMethod" AS ENUM ('CASH', 'CARD', 'MOBILE_MONEY', 'OTHER');

-- CreateTable
CREATE TABLE "payments" (
    "id" TEXT NOT NULL,
    "order_id" TEXT NOT NULL,
    "method" "PaymentMethod" NOT NULL,
    "amount" DECIMAL(10,2) NOT NULL,
    "reference" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "payments_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "payments" ADD CONSTRAINT "payments_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "orders"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

================
File: prisma/migrations/20260221210510_add_tables/migration.sql
================
-- CreateTable
CREATE TABLE "seating_tables" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "status" TEXT NOT NULL DEFAULT 'FREE',
    "capacity" INTEGER NOT NULL DEFAULT 4,
    "floor" TEXT NOT NULL DEFAULT 'Main',
    "x" INTEGER NOT NULL DEFAULT 0,
    "y" INTEGER NOT NULL DEFAULT 0,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "deleted_at" TIMESTAMP(3),

    CONSTRAINT "seating_tables_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "orders" ADD CONSTRAINT "orders_table_id_fkey" FOREIGN KEY ("table_id") REFERENCES "seating_tables"("id") ON DELETE SET NULL ON UPDATE CASCADE;

================
File: prisma/migrations/20260222111806_add_inventory/migration.sql
================
-- CreateTable
CREATE TABLE "inventory_items" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "sku" TEXT,
    "unitOfMeasure" TEXT NOT NULL,
    "currentStock" DECIMAL(10,4) NOT NULL DEFAULT 0,
    "minimumStock" DECIMAL(10,4) NOT NULL DEFAULT 0,
    "costPerUnit" DECIMAL(10,2) NOT NULL DEFAULT 0,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "inventory_items_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "recipe_ingredients" (
    "id" TEXT NOT NULL,
    "product_id" TEXT NOT NULL,
    "inventory_item_id" TEXT NOT NULL,
    "amount" DECIMAL(10,4) NOT NULL,

    CONSTRAINT "recipe_ingredients_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "inventory_items_sku_key" ON "inventory_items"("sku");

-- AddForeignKey
ALTER TABLE "recipe_ingredients" ADD CONSTRAINT "recipe_ingredients_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "products"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "recipe_ingredients" ADD CONSTRAINT "recipe_ingredients_inventory_item_id_fkey" FOREIGN KEY ("inventory_item_id") REFERENCES "inventory_items"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

================
File: prisma/migrations/migration_lock.toml
================
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"

================
File: prisma/schema.prisma.save
================
generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
}

// ------------------------------------------------------
// 1. AUTH & STAFF
// ------------------------------------------------------
enum Role {
  OWNER
  MANAGER
  CASHIER
  WAITER
  KITCHEN
}

model User {
  id           String    @id @default(uuid())
  pin          String    @unique // Hashed PIN for terminal login
  role         Role      @default(WAITER)
  fullName     String    @map("full_name")
  branchId     String    @map("branch_id") // Ready for Phase 3 (Multi-branch)
  isActive     Boolean   @default(true) @map("is_active")
  
  // Relations
  orders       Order[]
  
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")
  deletedAt    DateTime? @map("deleted_at") // Soft delete

  @@map("users")
}

// ------------------------------------------------------
// 2. MENU & PRODUCTS (Server is source of truth)
// ------------------------------------------------------
model Category {
  id           String    @id @default(uuid())
  name         String
  colorHex     String?   @map("color_hex") // For the POS UI (e.g., #FF5733)
  sortOrder    Int       @default(0) @map("sort_order")
  
  products     Product[]

  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at") // Used by terminal to detect changes
  deletedAt    DateTime? @map("deleted_at")

  @@map("categories")
}

model Product {
  id           String    @id @default(uuid())
  categoryId   String    @map("category_id")
  name         String
  price        Decimal   @db.Decimal(10, 2)
  isAvailable  Boolean   @default(true) @map("is_available")

  category     Category  @relation(fields: [categoryId], references: [id])
  orderItems   OrderItem[]

  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at") // The sync engine monitors this field heavily!
  deletedAt    DateTime? @map("deleted_at")

  @@map("products")
}

// ------------------------------------------------------
// 3. ORDERS (Terminals are source of truth, pushed to server)
// ------------------------------------------------------
enum OrderStatus {
  OPEN
  KITCHEN
  SERVED
  CLOSED
  VOIDED
}

model Order {
  id            String      @id @default(uuid()) // Terminals generate this UUID
  receiptNumber String      @map("receipt_number") // e.g., ORD-0001
  userId        String      @map("user_id") // Waiter who took the order
  tableId       String?     @map("table_id") // Nullable for takeaway
  totalAmount   Decimal     @db.Decimal(10, 2) @map("total_amount")
  status        OrderStatus @default(OPEN)
  
  user          User        @relation(fields: [userId], references: [id])
  items         OrderItem[]

  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")

  @@map("orders")
}

model OrderItem {
  id                  String   @id @default(uuid())
  orderId             String   @map("order_id")
  productId           String   @map("product_id")
  quantity            Int
  priceAtTimeOfOrder  Decimal  @db.Decimal(10, 2) @map("price_at_time_of_order") // Financial integrity
  notes               String?  // e.g. "Extra spicy"
  
  order               Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product             Product  @relation(fields: [productId], references: [id])

  @@map("order_items")
}
x

================
File: scripts/create-main-entry.cjs
================
const { writeFileSync } = require('node:fs');
const { join } = require('node:path');

const entrypointPath = join(__dirname, '..', 'dist', 'main.js');
writeFileSync(entrypointPath, "require('./src/main.js');\n", 'utf8');
console.log(`Created ${entrypointPath}`);

================
File: src/auth/auth.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AuthController } from './auth.controller';

describe('AuthController', () => {
  let controller: AuthController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
    }).compile();

    controller = module.get<AuthController>(AuthController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/auth/auth.controller.ts
================
// src/auth/auth.controller.ts
import { Controller, Post, Body, UnauthorizedException } from '@nestjs/common';
import { AuthService } from './auth.service';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('login')
  async login(@Body() body: { id: string; pin: string }) {
    const user = await this.authService.validateUser(body.id, body.pin);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }
    return this.authService.login(user);
  }
}

================
File: src/auth/auth.module.ts
================
// src/auth/auth.module.ts
import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { JwtStrategy } from './jwt.strategy';

@Module({
  imports: [
    PassportModule,
    JwtModule.register({
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '24h' },
    }),
  ],
  providers: [AuthService, JwtStrategy],
  controllers: [AuthController],
})
export class AuthModule {}

================
File: src/auth/auth.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from './auth.service';

describe('AuthService', () => {
  let service: AuthService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [AuthService],
    }).compile();

    service = module.get<AuthService>(AuthService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/auth/auth.service.ts
================
// src/auth/auth.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { PrismaService } from '../prisma/prisma.service';
import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  constructor(
    private prisma: PrismaService,
    private jwtService: JwtService
  ) {}

  async validateUser(userId: string, pin: string): Promise<any> {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
    });

    if (user && (await bcrypt.compare(pin, user.pin))) {
      const { pin, ...result } = user;
      return result;
    }
    return null;
  }

  async login(user: any) {
    const payload = { sub: user.id, role: user.role, branchId: user.branchId };
    return {
      access_token: this.jwtService.sign(payload),
      user: user
    };
  }
}

================
File: src/auth/jwt.strategy.ts
================
// src/auth/jwt.strategy.ts
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: process.env.JWT_SECRET,
    });
  }

  async validate(payload: any) {
    // This return value is added to Request object (req.user)
    return { userId: payload.sub, role: payload.role, branchId: payload.branchId };
  }
}

================
File: src/events/events.gateway.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { EventsGateway } from './events.gateway';

describe('EventsGateway', () => {
  let gateway: EventsGateway;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [EventsGateway],
    }).compile();

    gateway = module.get<EventsGateway>(EventsGateway);
  });

  it('should be defined', () => {
    expect(gateway).toBeDefined();
  });
});

================
File: src/events/events.gateway.ts
================
import {
  WebSocketGateway,
  WebSocketServer,
  OnGatewayConnection,
  OnGatewayDisconnect,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Logger } from '@nestjs/common';

// Allow any origin for now to avoid CORS issues during dev/testing across devices
@WebSocketGateway({
  cors: {
    origin: '*',
  },
})
export class EventsGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  private logger: Logger = new Logger('EventsGateway');

  handleConnection(client: Socket) {
    this.logger.log(`Client connected: ${client.id}`);
  }

  handleDisconnect(client: Socket) {
    this.logger.log(`Client disconnected: ${client.id}`);
  }

  // --- Methods to emit events from other services ---

  // Call this when an order is received from the POS
  emitNewOrder(orderData: any) {
    this.server.emit('newOrder', orderData);
  }

  // Call this when inventory is updated
  emitInventoryUpdate(inventoryData: any) {
    this.server.emit('inventoryUpdate', inventoryData);
  }
}

================
File: src/inventory/inventory.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { InventoryController } from './inventory.controller';

describe('InventoryController', () => {
  let controller: InventoryController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [InventoryController],
    }).compile();

    controller = module.get<InventoryController>(InventoryController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/inventory/inventory.controller.ts
================
import { Controller, Get } from '@nestjs/common';
import { InventoryService } from './inventory.service';

@Controller('inventory')
export class InventoryController {
  constructor(private readonly inventoryService: InventoryService) {}

  @Get()
  async getInventory() {
    return this.inventoryService.getInventoryStatus();
  }
}

================
File: src/inventory/inventory.module.ts
================
import { Module } from '@nestjs/common';
import { InventoryService } from './inventory.service';
import { InventoryController } from './inventory.controller';

@Module({
  providers: [InventoryService],
  controllers: [InventoryController]
})
export class InventoryModule {}

================
File: src/inventory/inventory.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { InventoryService } from './inventory.service';

describe('InventoryService', () => {
  let service: InventoryService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [InventoryService],
    }).compile();

    service = module.get<InventoryService>(InventoryService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/inventory/inventory.service.ts
================
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class InventoryService {
  private readonly logger = new Logger(InventoryService.name);

  constructor(private prisma: PrismaService) {}

  /**
   * Processes inventory deductions for a given order.
   * This should be called after an order is successfully synced from the POS.
   */
  async deductStockForOrder(orderId: string) {
    try {
      // 1. Fetch the order and its items
      const order = await this.prisma.order.findUnique({
        where: { id: orderId },
        include: { items: true },
      });

      if (!order) {
        this.logger.error(`Order ${orderId} not found for inventory deduction.`);
        return;
      }

      this.logger.log(`Processing inventory for Order: ${order.receiptNumber}`);

      // 2. Loop through each item in the order
      for (const orderItem of order.items) {
        
        // 3. Find the recipe for this product
        const recipeIngredients = await this.prisma.recipeIngredient.findMany({
          where: { productId: orderItem.productId },
        });

        if (recipeIngredients.length === 0) {
            // It's a product without a recipe (maybe a retail item), skip deduction or handle retail logic.
            continue; 
        }

        // 4. Calculate total deduction and update inventory
        for (const ingredient of recipeIngredients) {
            // quantity ordered * amount needed per item
            const totalDeduction = Number(orderItem.quantity) * Number(ingredient.amount);

            await this.prisma.inventoryItem.update({
                where: { id: ingredient.inventoryItemId },
                data: {
                    currentStock: {
                        decrement: totalDeduction
                    }
                }
            });

            this.logger.debug(`Deducted ${totalDeduction} from InventoryItem ${ingredient.inventoryItemId}`);
        }
      }
    } catch (error) {
        this.logger.error(`Failed to deduct inventory for order ${orderId}: ${error.message}`);
    }
  }

  async getInventoryStatus() {
    return this.prisma.inventoryItem.findMany({
      orderBy: { currentStock: 'asc' }, // Order by lowest stock first
    });
  }
}

================
File: src/prisma/prisma.module.ts
================
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global() // Makes PrismaService available everywhere without importing the module
@Module({
    providers: [PrismaService],
    exports: [PrismaService],
})
export class PrismaModule {}

================
File: src/prisma/prisma.service.ts
================
import { INestApplication, Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
  }
}

================
File: src/sync/sync.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { SyncController } from './sync.controller';

describe('SyncController', () => {
  let controller: SyncController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [SyncController],
    }).compile();

    controller = module.get<SyncController>(SyncController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/sync/sync.controller.ts
================
// src/sync/sync.controller.ts
import { Controller, Get, Post, Body, Query, UseGuards } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport'; // Built-in guard
import { SyncService } from './sync.service';

@Controller('sync')
@UseGuards(AuthGuard('jwt')) // This protects all routes in this controller
export class SyncController {
    constructor(private readonly syncService: SyncService) { }

    @Get('pull')
    async pull(@Query('lastSyncTimestamp') lastSyncTimestamp: string) {
        return this.syncService.pullChanges(lastSyncTimestamp);
    }

    @Post('push')
    async push(@Body() payload: any) {
        return this.syncService.pushChanges(payload);
    }
}

================
File: src/sync/sync.module.ts
================
import { Module } from '@nestjs/common';
import { SyncService } from './sync.service';
import { SyncController } from './sync.controller';

@Module({
  providers: [SyncService],
  controllers: [SyncController]
})
export class SyncModule {}

================
File: src/sync/sync.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { SyncService } from './sync.service';

describe('SyncService', () => {
  let service: SyncService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [SyncService],
    }).compile();

    service = module.get<SyncService>(SyncService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/app.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});

================
File: src/app.controller.ts
================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

================
File: src/app.service.ts
================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

================
File: test/app.e2e-spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import request from 'supertest';
import { App } from 'supertest/types';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication<App>;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});

================
File: test/jest-e2e.json
================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}

================
File: .gitignore
================
# compiled output
/dist
/node_modules
/build

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

/generated/prisma

================
File: .prettierrc
================
{
  "singleQuote": true,
  "trailingComma": "all"
}

================
File: docker-compose.yaml
================
version: '3.8'
services:
  postgres:
    image: postgres:15-alpine
    restart: always
    environment:
      POSTGRES_USER: qristal_user
      POSTGRES_PASSWORD: qristal_password
      POSTGRES_DB: qristal_db
    ports:
      - '5432:5432'
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:

================
File: eslint.config.mjs
================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      sourceType: 'commonjs',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'warn',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      "prettier/prettier": ["error", { endOfLine: "auto" }],
    },
  },
);

================
File: nest-cli.json
================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}

================
File: prisma.config.ts
================
import "dotenv/config";
import { defineConfig, env } from "@prisma/config";

export default defineConfig({
  schema: "prisma/schema.prisma",
  datasource: {
    url: env("DATABASE_URL"),
  },
});

================
File: README.md
================
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ npm install
```

## Compile and run the project

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Run tests

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Deployment

When you're ready to deploy your NestJS application to production, there are some key steps you can take to ensure it runs as efficiently as possible. Check out the [deployment documentation](https://docs.nestjs.com/deployment) for more information.

If you are looking for a cloud-based platform to deploy your NestJS application, check out [Mau](https://mau.nestjs.com), our official platform for deploying NestJS applications on AWS. Mau makes deployment straightforward and fast, requiring just a few simple steps:

```bash
$ npm install -g @nestjs/mau
$ mau deploy
```

With Mau, you can deploy your application in just a few clicks, allowing you to focus on building features rather than managing infrastructure.

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Deploy your application to AWS with the help of [NestJS Mau](https://mau.nestjs.com) in just a few clicks.
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).

================
File: tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "module": "nodenext",
    "moduleResolution": "nodenext",
    "resolvePackageJsonExports": true,
    "esModuleInterop": true,
    "isolatedModules": true,
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false
  }
}

================
File: src/main.ts
================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Enable CORS so your Flutter Web/Mobile can talk to it
  app.enableCors(); 
  
  // Listen on 0.0.0.0 to accept external connections in Docker/Railway
  await app.listen(process.env.PORT || 3000, '0.0.0.0');
  
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();

================
File: prisma/seed.ts
================
import { PrismaClient } from '@prisma/client';
import * as bcrypt from 'bcrypt';

const prisma = new PrismaClient();

async function main() {
  console.log('Clearing database...');
  await prisma.orderItem.deleteMany();
  await prisma.order.deleteMany();
  await prisma.product.deleteMany();
  await prisma.category.deleteMany();
  await prisma.user.deleteMany();
  await prisma.inventoryItem.deleteMany();
  await prisma.recipeIngredient.deleteMany();
  await prisma.seatingTable.deleteMany();


  console.log('Seeding data...');

  // 1. Create a User
  const hashedPin = await bcrypt.hash('1234', 10);
  const admin = await prisma.user.create({
    data: {
      fullName: 'Admin User',
      pin: hashedPin,
      role: 'OWNER',
      branchId: 'BRANCH-01',
      isActive: true,
    },
  });

  // 2. Create Categories
  const catDrinks = await prisma.category.create({
    data: { name: 'Drinks', colorHex: '#3498db', sortOrder: 1 },
  });

  const catFood = await prisma.category.create({
    data: { name: 'Food', colorHex: '#e67e22', sortOrder: 2 },
  });

  // 3. Create Products
  await prisma.product.createMany({
    data: [
      {
        categoryId: catDrinks.id,
        name: 'Coffee',
        price: 2.50,
        isAvailable: true,
      },
      {
        categoryId: catDrinks.id,
        name: 'Soda',
        price: 1.50,
        isAvailable: true,
      },
      {
        categoryId: catFood.id,
        name: 'Burger',
        price: 8.50,
        isAvailable: true,
      },
      {
        categoryId: catFood.id,
        name: 'Fries',
        price: 3.00,
        isAvailable: true,
      },
    ],
  });

  console.log('Seeding Inventory...');
  
  const coffeeBeans = await prisma.inventoryItem.create({
    data: { name: 'Espresso Beans', unitOfMeasure: 'Grams', currentStock: 5000, costPerUnit: 0.05 }
  });

  const milk = await prisma.inventoryItem.create({
     data: { name: 'Whole Milk', unitOfMeasure: 'Liters', currentStock: 20, costPerUnit: 2000 }
  });

  const bun = await prisma.inventoryItem.create({
    data: { name: 'Brioche Bun', unitOfMeasure: 'Pieces', currentStock: 100, costPerUnit: 500 }
  });

  const beefPatty = await prisma.inventoryItem.create({
    data: { name: 'Beef Patty 150g', unitOfMeasure: 'Pieces', currentStock: 100, costPerUnit: 2500 }
  });

  console.log('Creating Recipes...');
  
  // Find the Coffee product we created earlier
  const coffee = await prisma.product.findFirst({ where: { name: 'Coffee' }});
  if (coffee) {
    await prisma.recipeIngredient.createMany({
        data: [
            { productId: coffee.id, inventoryItemId: coffeeBeans.id, amount: 18 }, // 18 grams of beans
            { productId: coffee.id, inventoryItemId: milk.id, amount: 0.2 },       // 200ml milk
        ]
    });
  }

  // Find the Burger product
  const burger = await prisma.product.findFirst({ where: { name: 'Burger' }});
  if (burger) {
    await prisma.recipeIngredient.createMany({
        data: [
            { productId: burger.id, inventoryItemId: bun.id, amount: 1 }, 
            { productId: burger.id, inventoryItemId: beefPatty.id, amount: 1 },
        ]
    });
  }
  
  console.log('Seeding Tables...');
  await prisma.seatingTable.createMany({
    data: [
      { name: 'T-01', status: 'FREE', floor: 'Main', x: 0, y: 0 },
      { name: 'T-02', status: 'FREE', floor: 'Main', x: 1, y: 0 },
      { name: 'T-03', status: 'OCCUPIED', floor: 'Main', x: 2, y: 0 }, // Mocking an active table
      { name: 'VIP-1', status: 'FREE', floor: 'VIP', x: 0, y: 1 },
    ]
  });

  console.log('Seed data created successfully!');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

================
File: src/app.module.ts
================
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PrismaModule } from './prisma/prisma.module';
import { SyncModule } from './sync/sync.module';
import { AuthModule } from './auth/auth.module';
import { InventoryModule } from './inventory/inventory.module';
import { EventsGateway } from './events/events.gateway';

@Module({
  imports: [PrismaModule, SyncModule, AuthModule, InventoryModule],  // Add PrismaModule here
  controllers: [AppController],
  providers: [AppService, EventsGateway],
})
export class AppModule {}

================
File: prisma/schema.prisma
================
generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ------------------------------------------------------
// 1. AUTH & STAFF
// ------------------------------------------------------
enum Role {
  OWNER
  MANAGER
  CASHIER
  WAITER
  KITCHEN
}

model User {
  id           String    @id @default(uuid())
  pin          String    @unique // Hashed PIN for terminal login
  role         Role      @default(WAITER)
  fullName     String    @map("full_name")
  branchId     String    @map("branch_id") // Ready for Phase 3 (Multi-branch)
  isActive     Boolean   @default(true) @map("is_active")
  
  // Relations
  orders       Order[]
  
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")
  deletedAt    DateTime? @map("deleted_at") // Soft delete

  @@map("users")
}

// ------------------------------------------------------
// 2. MENU & PRODUCTS (Server is source of truth)
// ------------------------------------------------------
model Category {
  id           String    @id @default(uuid())
  name         String
  colorHex     String?   @map("color_hex") // For the POS UI (e.g., #FF5733)
  sortOrder    Int       @default(0) @map("sort_order")
  
  products     Product[]

  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at") // Used by terminal to detect changes
  deletedAt    DateTime? @map("deleted_at")

  @@map("categories")
}

model Product {
  id           String    @id @default(uuid())
  categoryId   String    @map("category_id")
  name         String
  price        Decimal   @db.Decimal(10, 2)
  isAvailable  Boolean   @default(true) @map("is_available")

  category     Category  @relation(fields: [categoryId], references: [id])
  orderItems   OrderItem[]

  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at") // The sync engine monitors this field heavily!
  deletedAt    DateTime? @map("deleted_at")

  recipe          RecipeIngredient[]

  @@map("products")
}

// ------------------------------------------------------
// 3. ORDERS (Terminals are source of truth, pushed to server)
// ------------------------------------------------------
enum OrderStatus {
  OPEN
  KITCHEN
  SERVED
  CLOSED
  VOIDED
}

model Order {
  id            String      @id @default(uuid()) // Terminals generate this UUID
  receiptNumber String      @map("receipt_number") // e.g., ORD-0001
  userId        String      @map("user_id") // Waiter who took the order
  tableId       String?     @map("table_id") // Nullable for takeaway
  totalAmount   Decimal     @db.Decimal(10, 2) @map("total_amount")
  status        OrderStatus @default(OPEN)
  
  user          User        @relation(fields: [userId], references: [id])
  items         OrderItem[]

  payments      Payment[]

  table         SeatingTable? @relation(fields: [tableId], references: [id])

  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")

  @@map("orders")
}

model OrderItem {
  id                  String   @id @default(uuid())
  orderId             String   @map("order_id")
  productId           String   @map("product_id")
  quantity            Int
  priceAtTimeOfOrder  Decimal  @db.Decimal(10, 2) @map("price_at_time_of_order") // Financial integrity
  notes               String?  // e.g. "Extra spicy"
  
  order               Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product             Product  @relation(fields: [productId], references: [id])

  @@map("order_items")
}

enum PaymentMethod {
  CASH
  CARD
  MOBILE_MONEY
  OTHER
}

model Payment {
  id            String        @id @default(uuid())
  orderId       String        @map("order_id")
  method        PaymentMethod
  amount        Decimal       @db.Decimal(10, 2)
  reference     String?       // For Mobile Money Ref / Card Auth Code
  createdAt     DateTime      @default(now()) @map("created_at")

  order         Order         @relation(fields: [orderId], references: [id])

  @@map("payments")
}

model SeatingTable {
  id        String   @id @default(uuid())
  name      String   // e.g., "T-1", "Bar-2"
  status    String   @default("FREE") // FREE, OCCUPIED, RESERVED
  capacity  Int      @default(4)
  floor     String   @default("Main") // Main, Terrace, VIP
  
  // Coordinates for future Drag-n-Drop UI
  x         Int      @default(0) 
  y         Int      @default(0)

  orders    Order[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at")

  @@map("seating_tables")
}

// ------------------------------------------------------
// 4. INVENTORY & RECIPES
// ------------------------------------------------------

model InventoryItem {
  id              String   @id @default(uuid())
  name            String   // e.g., "Coffee Beans", "Milk", "Burger Bun"
  sku             String?  @unique
  unitOfMeasure   String   // e.g., "Kg", "Liters", "Pieces", "Grams"
  currentStock    Decimal  @default(0) @db.Decimal(10, 4)
  minimumStock    Decimal  @default(0) @db.Decimal(10, 4) // For low stock alerts
  costPerUnit     Decimal  @default(0) @db.Decimal(10, 2)
  
  recipeIngredients RecipeIngredient[]

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@map("inventory_items")
}

// A Recipe links a Product (what you sell) to InventoryItems (what you use)
model RecipeIngredient {
  id              String   @id @default(uuid())
  productId       String   @map("product_id")
  inventoryItemId String   @map("inventory_item_id")
  
  // How much of the inventory item is used to make ONE of the product
  // e.g., 1 Cappuccino uses 15 (amount) Grams (from InventoryItem unit) of Coffee Beans
  amount          Decimal  @db.Decimal(10, 4) 

  product         Product       @relation(fields: [productId], references: [id], onDelete: Cascade)
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Restrict)

  @@map("recipe_ingredients")
}

================
File: src/sync/sync.service.ts
================
import { Injectable, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service'; // Assuming you generated a Prisma module
import { EventsGateway } from '../events/events.gateway';
import { InventoryService } from '../inventory/inventory.service';

@Injectable()
export class SyncService {
  constructor(private prisma: PrismaService,
    private inventoryService: InventoryService,
    private eventsGateway: EventsGateway
  ) { }

  /**
   * PULL: Client requests data that has changed since `lastSyncTimestamp`.
   * The client sends a timestamp (ISO string), and the server returns
   * all records where `updatedAt > lastSyncTimestamp`.
   */
  async pullChanges(lastSyncTimestamp: string) {
    let lastSyncDate: Date;

    if (!lastSyncTimestamp) {
      // If no timestamp provided, do a full initial sync (return all data)
      lastSyncDate = new Date(0); // 1970-01-01
    } else {
      lastSyncDate = new Date(lastSyncTimestamp);
      if (isNaN(lastSyncDate.getTime())) {
        throw new BadRequestException('Invalid lastSyncTimestamp format.');
      }
    }

    // Fetch all updated records
    const [categories, products, users, seatingTables, orders] = await Promise.all([
      this.prisma.category.findMany({
        where: { updatedAt: { gt: lastSyncDate } },
      }),
      this.prisma.product.findMany({
        where: { updatedAt: { gt: lastSyncDate } },
      }),
      this.prisma.user.findMany({
        where: { updatedAt: { gt: lastSyncDate } },
      }),
      this.prisma.seatingTable.findMany({
        where: { updatedAt: { gt: lastSyncDate } },
      }),
      this.prisma.order.findMany({
        where: { updatedAt: { gt: lastSyncDate } },
      }),
    ]);

    return {
      timestamp: new Date().toISOString(), // The client will save this for the next sync
      changes: {
        categories,
        products,
        users,
        seatingTables,
        orders,
      },
    };
  }

  /**
   * PUSH: Client sends new/updated data (orders, transactions) to the server.
   * Since orders are generated on the POS, the server needs to upsert them.
   */
  async pushChanges(payload: any) {
    const { orders, orderItems, payments } = payload;
    const errors: { id: any; error: any }[] = [];
    let processedOrders = 0;

    const newOrderIdsToDeduct: string[] = [];

    const newlyCreatedOrdersForKDS = [];
    // We use a transaction to ensure data integrity
    try {
      await this.prisma.$transaction(async (tx) => {

        // 1. Process Orders
        if (orders && Array.isArray(orders)) {
          for (const order of orders) {
            try {
              const existing = await tx.order.findUnique({ where: { id: order.id } });
              const savedOrder = await tx.order.upsert({
                where: { id: order.id },
                update: {
                  status: order.status,
                  totalAmount: order.totalAmount,
                  updatedAt: new Date(), // Force server timestamp
                },
                create: {
                  id: order.id,
                  receiptNumber: order.receiptNumber,
                  userId: order.userId,
                  tableId: order.tableId,
                  totalAmount: order.totalAmount,
                  status: order.status,
                  createdAt: new Date(order.createdAt), // Keep original creation time
                },
              });
              processedOrders++;
              if (!existing) {
                newOrderIdsToDeduct.push(order.id);
                newlyCreatedOrdersForKDS.push(savedOrder); // Save for WebSocket
              }

            } catch (err) {
              errors.push({ id: order.id, error: err.message });
            }
          }
        }

        // 2. Process Order Items
        if (orderItems && Array.isArray(orderItems)) {
          for (const item of orderItems) {
            try {
              await tx.orderItem.upsert({
                where: { id: item.id },
                update: {
                  quantity: item.quantity,
                  notes: item.notes,
                },
                create: {
                  id: item.id,
                  orderId: item.orderId,
                  productId: item.productId,
                  quantity: item.quantity,
                  priceAtTimeOfOrder: item.priceAtTimeOfOrder,
                  notes: item.notes,
                },
              });
            } catch (err) {
              errors.push({ id: item.id, error: err.message });
            }
          }
        }

        // 3. Process Payments
        if (payments && Array.isArray(payments)) {
          for (const pay of payments) {
            try {
              await tx.payment.create({ // We usually only create payments, not update them
                data: {
                  id: pay.id,
                  orderId: pay.orderId,
                  method: pay.method, // Ensure Enum mapping matches
                  amount: pay.amount,
                  reference: pay.reference,
                  createdAt: new Date(pay.createdAt),
                }
              });
            } catch (err) {
              // If it exists, ignore (idempotency), otherwise log error
              if (!err.message.includes('Unique constraint')) {
                errors.push({ id: pay.id, error: err.message });
              }
            }
          }
        }
      });

      for (const orderId of newOrderIdsToDeduct) {
        // Fire and forget - don't await this so the POS gets a fast response
        this.inventoryService.deductStockForOrder(orderId).catch(e =>
          console.error(`Inventory deduction failed async: ${e}`)
        );
      }
      if (newlyCreatedOrdersForKDS.length > 0) {
        // In a real app we'd fetch the items too, but sending the signal is enough 
        // for the KDS to know it needs to pull. Let's send the data.
        this.eventsGateway.emitNewOrder({ message: 'New orders arrived!' });
      }

      // 2. Trigger Inventory Deduction (Non-blocking)
      for (const orderId of newOrderIdsToDeduct) {
        this.inventoryService.deductStockForOrder(orderId).then(async () => {
          // After deduction, fetch latest inventory and broadcast to Dashboard
          const latestInventory = await this.inventoryService.getInventoryStatus();
          this.eventsGateway.emitInventoryUpdate(latestInventory);
        }).catch(e => console.error(e));
      }
      return {
        success: true,
        processedOrders,
        errors: errors.length > 0 ? errors : undefined,
      };

    } catch (error) {
      // Transaction failed
      throw new BadRequestException(`Push sync failed: ${error.message}`);
    }
  }
}

================
File: package.json
================
{
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  },
  "name": "qristal-api",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build && node scripts/create-main-entry.cjs",
    "postinstall": "npx prisma generate",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "dependencies": {
    "@nestjs/cli": "^11.0.0",
    "@nestjs/common": "^11.0.1",
    "@nestjs/core": "^11.0.1",
    "@nestjs/jwt": "^11.0.2",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^11.0.1",
    "@nestjs/platform-socket.io": "^11.1.14",
    "@nestjs/swagger": "^11.2.6",
    "@nestjs/websockets": "^11.1.14",
    "@prisma/client": "^5.22.0",
    "bcrypt": "^6.0.0",
    "passport-jwt": "^4.0.1",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "socket.io": "^4.8.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@prisma/config": "^7.4.1",
    "@types/bcrypt": "^6.0.0",
    "@types/express": "^5.0.0",
    "@types/jest": "^30.0.0",
    "@types/node": "^22.10.7",
    "@types/supertest": "^6.0.2",
    "dotenv": "^17.3.1",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^30.0.0",
    "prettier": "^3.4.2",
    "prisma": "^5.22.0",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}





================================================================
End of Codebase
================================================================

================
File: qristal-api/repomix.config.json
================
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output.txt",
    "style": "plain",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "includeFullDirectoryStructure": false,
    "tokenCountTree": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false,
      "includeLogs": false,
      "includeLogsCount": 50
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDotIgnore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}

================
File: qristal-api/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

================
File: qristal-api/tsconfig.json
================
{
  "compilerOptions": {
    "module": "nodenext",
    "moduleResolution": "nodenext",
    "resolvePackageJsonExports": true,
    "esModuleInterop": true,
    "isolatedModules": true,
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false
  }
}

================
File: qristal-dashboard/.git/logs/refs/heads/main
================
0000000000000000000000000000000000000000 ac3b427c8c0bc2624128c3ff6374c66766471d85 truthysys <truthysys@gmail.com> 1771763624 +0000	commit (initial): Initial commit
ac3b427c8c0bc2624128c3ff6374c66766471d85 842881313bcadaa86fcf20980dfc41531782f2e1 truthysys <truthysys@gmail.com> 1771772926 +0000	commit: Reliable socket

================
File: qristal-dashboard/.git/logs/refs/remotes/origin/main
================
0000000000000000000000000000000000000000 ac3b427c8c0bc2624128c3ff6374c66766471d85 truthysys <truthysys@gmail.com> 1771763769 +0000	update by push
ac3b427c8c0bc2624128c3ff6374c66766471d85 842881313bcadaa86fcf20980dfc41531782f2e1 truthysys <truthysys@gmail.com> 1771772936 +0000	update by push

================
File: qristal-dashboard/.git/logs/HEAD
================
0000000000000000000000000000000000000000 ac3b427c8c0bc2624128c3ff6374c66766471d85 truthysys <truthysys@gmail.com> 1771763624 +0000	commit (initial): Initial commit
ac3b427c8c0bc2624128c3ff6374c66766471d85 842881313bcadaa86fcf20980dfc41531782f2e1 truthysys <truthysys@gmail.com> 1771772926 +0000	commit: Reliable socket

================
File: qristal-dashboard/.git/refs/heads/main
================
842881313bcadaa86fcf20980dfc41531782f2e1

================
File: qristal-dashboard/.git/refs/remotes/origin/main
================
842881313bcadaa86fcf20980dfc41531782f2e1

================
File: qristal-dashboard/.git/COMMIT_EDITMSG
================
Reliable socket

================
File: qristal-dashboard/.git/config
================
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
[remote "origin"]
	url = https://github.com/linTruthy/qristal-dashboard.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main

================
File: qristal-dashboard/.git/FETCH_HEAD
================


================
File: qristal-dashboard/.git/HEAD
================
ref: refs/heads/main

================
File: qristal-dashboard/.git/ORIG_HEAD
================
842881313bcadaa86fcf20980dfc41531782f2e1

================
File: qristal_mobile/android/app/src/debug/AndroidManifest.xml
================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

================
File: qristal_mobile/android/app/src/main/kotlin/com/truthysystems/qristal_mobile/MainActivity.kt
================
package com.truthysystems.qristal_mobile

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()

================
File: qristal_mobile/android/app/src/main/res/drawable/launch_background.xml
================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

================
File: qristal_mobile/android/app/src/main/res/drawable-v21/launch_background.xml
================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

================
File: qristal_mobile/android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
  <background android:drawable="@mipmap/ic_launcher_background"/>
  <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
  <monochrome android:drawable="@mipmap/ic_launcher_monochrome"/>
</adaptive-icon>

================
File: qristal_mobile/android/app/src/main/res/values/styles.xml
================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

================
File: qristal_mobile/android/app/src/main/res/values-night/styles.xml
================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

================
File: qristal_mobile/android/app/src/profile/AndroidManifest.xml
================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

================
File: qristal_mobile/android/app/build.gradle.kts
================
plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.truthysystems.qristal_mobile"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_11.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.truthysystems.qristal_mobile"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}

================
File: qristal_mobile/android/build.gradle.kts
================
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory =
    rootProject.layout.buildDirectory
        .dir("../../build")
        .get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}

================
File: qristal_mobile/android/settings.gradle.kts
================
pluginManagement {
    val flutterSdkPath =
        run {
            val properties = java.util.Properties()
            file("local.properties").inputStream().use { properties.load(it) }
            val flutterSdkPath = properties.getProperty("flutter.sdk")
            require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
            flutterSdkPath
        }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.9.1" apply false
    id("org.jetbrains.kotlin.android") version "2.1.0" apply false
}

include(":app")

================
File: qristal_mobile/lib/core/providers/database_provider.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../database/database.dart';

// The single instance of our local SQLite database
final databaseProvider = Provider<AppDatabase>((ref) {
  return AppDatabase();
});

================
File: qristal_mobile/lib/core/theme/app_theme.dart
================
import 'package:flutter/material.dart';

class AppTheme {
  static const Color background = Color(0xFF121212);
  static const Color surface = Color(0xFF1E1E1E);
  static const Color qristalBlue = Color(0xFF0EA5E9); // Light Blue
  static const Color emerald = Color(0xFF10B981); // Emerald Green
  static const Color error = Color(0xFFEF4444);

  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      scaffoldBackgroundColor: background,
      colorScheme: const ColorScheme.dark(
        primary: qristalBlue,
        secondary: emerald,
        surface: surface,
        error: error,
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: surface,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Colors.white10),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: qristalBlue),
        ),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: qristalBlue,
          foregroundColor: Colors.white,
          padding: const EdgeInsets.symmetric(vertical: 20),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          textStyle: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        ),
      ),
    );
  }
}

================
File: qristal_mobile/lib/features/hardware/services/receipt_generator.dart
================
import 'package:esc_pos_utils_plus/esc_pos_utils_plus.dart';
import 'package:intl/intl.dart';
import '../../pos/models/cart_item.dart';

class ReceiptGenerator {
  // Generate the byte list for the printer
  Future<List<int>> generateTicket({
    required String orderId,
    required List<CartItem> items,
    required double total,
    required double tendered,
    required String paymentMethod,
    required String cashierName,
  }) async {
    // 1. Load the Capability Profile (usually 'default' works for most Chinese printers)
    final profile = await CapabilityProfile.load();
    final generator = Generator(PaperSize.mm58, profile); // 58mm paper is standard for cheap handhelds
    
    List<int> bytes = [];

    // 2. Header
    bytes += generator.text('QRISTAL POS',
        styles: const PosStyles(
          align: PosAlign.center,
          height: PosTextSize.size2,
          width: PosTextSize.size2,
          bold: true,
        ));
    bytes += generator.text('Kampala, Uganda', styles: const PosStyles(align: PosAlign.center));
    bytes += generator.text('Tel: +256 700 000000', styles: const PosStyles(align: PosAlign.center));
    bytes += generator.hr();
    
    // 3. Meta Data
    bytes += generator.row([
      PosColumn(text: 'Rcpt: ${orderId.substring(0, 6)}', width: 6),
      PosColumn(text: 'Staff: $cashierName', width: 6, styles: const PosStyles(align: PosAlign.right)),
    ]);
    bytes += generator.text('Date: ${DateFormat('dd/MM/yyyy HH:mm').format(DateTime.now())}');
    bytes += generator.hr();

    // 4. Items Header
    bytes += generator.row([
      PosColumn(text: 'Item', width: 6, styles: const PosStyles(bold: true)),
      PosColumn(text: 'Total', width: 6, styles: const PosStyles(bold: true, align: PosAlign.right)),
    ]);
    
    // 5. Items List
    final fmt = NumberFormat("#,##0", "en_US");
    for (var item in items) {
      bytes += generator.row([
        PosColumn(
            text: '${item.quantity}x ${item.product.name}', 
            width: 8,
            styles: const PosStyles(align: PosAlign.left)
        ),
        PosColumn(
            text: fmt.format(item.total), 
            width: 4, 
            styles: const PosStyles(align: PosAlign.right)
        ),
      ]);
    }

    bytes += generator.hr();

    // 6. Totals
    bytes += generator.row([
      PosColumn(text: 'TOTAL', width: 6, styles: const PosStyles(height: PosTextSize.size2, bold: true)),
      PosColumn(
          text: fmt.format(total), 
          width: 6, 
          styles: const PosStyles(align: PosAlign.right, height: PosTextSize.size2, bold: true)
      ),
    ]);

    bytes += generator.text('Paid via $paymentMethod: ${fmt.format(tendered)}');
    bytes += generator.text('Change: ${fmt.format(tendered - total)}');

    // 7. Footer
    bytes += generator.feed(1);
    bytes += generator.text('Thank you for visiting!', styles: const PosStyles(align: PosAlign.center, bold: true));
    bytes += generator.text('Powered by Qristal POS', styles: const PosStyles(align: PosAlign.center, codeTable: 'CP1252'));
    bytes += generator.feed(2);
    bytes += generator.cut();

    return bytes;
  }
}

================
File: qristal_mobile/lib/features/pos/models/cart_item.dart
================
import '../../../database/database.dart';

class CartItem {
  final Product product;
  final int quantity;
  final String notes;

  CartItem({
    required this.product, 
    this.quantity = 1, 
    this.notes = ''
  });

  double get total => product.price * quantity;

  CartItem copyWith({int? quantity, String? notes}) {
    return CartItem(
      product: product,
      quantity: quantity ?? this.quantity,
      notes: notes ?? this.notes,
    );
  }
}

================
File: qristal_mobile/lib/features/pos/providers/menu_provider.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/providers/database_provider.dart';
import '../../../database/database.dart';


// Tracks which category is currently selected in the UI
final selectedCategoryProvider = StateProvider<String?>((ref) => null);

// Watches all categories from DB
final categoriesStreamProvider = StreamProvider<List<Category>>((ref) {
  final db = ref.watch(databaseProvider);
  return db.select(db.categories).watch();
});

// Watches products, filtered by the selected category
final productsStreamProvider = StreamProvider<List<Product>>((ref) {
  final db = ref.watch(databaseProvider);
  final selectedCatId = ref.watch(selectedCategoryProvider);

  if (selectedCatId == null) {
    // If no category selected, return all (or none, depending on preference)
    return db.select(db.products).watch();
  }
  
  return (db.select(db.products)
    ..where((tbl) => tbl.categoryId.equals(selectedCatId)))
    .watch();
});

================
File: qristal_mobile/lib/features/pos/widgets/payment_modal.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/theme/app_theme.dart';

class PaymentModal extends ConsumerStatefulWidget {
  final double totalAmount;
  final Function(String method, double amount, String? ref) onConfirmed;

  const PaymentModal({
    super.key,
    required this.totalAmount,
    required this.onConfirmed,
  });

  @override
  ConsumerState<PaymentModal> createState() => _PaymentModalState();
}

class _PaymentModalState extends ConsumerState<PaymentModal> {
  String _selectedMethod = 'CASH';
  final TextEditingController _amountController = TextEditingController();
  final TextEditingController _refController =
      TextEditingController(); // For Mobile Money

  @override
  void initState() {
    super.initState();
    _amountController.text =
        widget.totalAmount.toStringAsFixed(0); // Default to full amount
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        width: 500,
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Header
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text("Settle Order",
                    style:
                        TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),
                IconButton(
                    icon: const Icon(Icons.close),
                    onPressed: () => Navigator.pop(context)),
              ],
            ),
            const Divider(),
            const SizedBox(height: 16),

            // Total Display
            Center(
              child: Text(
                "Total Due: ugx ${widget.totalAmount.toStringAsFixed(0)}",
                style: const TextStyle(
                    fontSize: 32,
                    fontWeight: FontWeight.bold,
                    color: AppTheme.emerald),
              ),
            ),
            const SizedBox(height: 24),

            // Payment Methods Tabs
            Row(
              children: [
                _methodCard("CASH", Icons.money, Colors.green),
                const SizedBox(width: 10),
                _methodCard("MOBILE_MONEY", Icons.phone_android, Colors.amber),
                const SizedBox(width: 10),
                _methodCard("CARD", Icons.credit_card, Colors.blue),
              ],
            ),
            const SizedBox(height: 24),

            // Input Fields
            TextField(
              controller: _amountController,
              keyboardType: TextInputType.number,
              decoration: const InputDecoration(labelText: "Amount Tendered"),
              style: const TextStyle(fontSize: 24),
            ),

            if (_selectedMethod == 'MOBILE_MONEY') ...[
              const SizedBox(height: 10),
              TextField(
                controller: _refController,
                decoration: const InputDecoration(
                    labelText: "Transaction Reference (Optional)"),
              ),
            ],

            const SizedBox(height: 24),

            // Quick Cash Buttons
            if (_selectedMethod == 'CASH')
              Wrap(
                spacing: 10,
                children: [500, 1000, 2000, 5000, 10000, 20000, 50000]
                    .map((amount) => ActionChip(
                          label: Text(amount.toString()),
                          onPressed: () =>
                              _amountController.text = amount.toString(),
                        ))
                    .toList(),
              ),

            const SizedBox(height: 24),

            // Complete Button
            SizedBox(
              height: 60,
              child: ElevatedButton(
                style:
                    ElevatedButton.styleFrom(backgroundColor: AppTheme.emerald),
                onPressed: () {
                  final tendered = double.tryParse(_amountController.text) ?? 0;
                  if (tendered < widget.totalAmount) {
                    ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(content: Text("Insufficient Amount")));
                    return;
                  }

                  // Calculate Change
                  final change = tendered - widget.totalAmount;
                  if (change > 0) {
                    ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text("Change Due: $change")));
                  }

                  widget.onConfirmed(_selectedMethod, tendered,
                      _refController.text.isEmpty ? null : _refController.text);
                  Navigator.pop(context);
                },
                child: const Text("COMPLETE PAYMENT",
                    style: TextStyle(fontSize: 20)),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _methodCard(String id, IconData icon, Color color) {
    final isSelected = _selectedMethod == id;
    return Expanded(
      child: GestureDetector(
        onTap: () => setState(() => _selectedMethod = id),
        child: Container(
          height: 80,
          decoration: BoxDecoration(
            color: isSelected ? color.withOpacity(0.2) : AppTheme.surface,
            border: Border.all(
                color: isSelected ? color : Colors.transparent, width: 2),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(icon, color: isSelected ? color : Colors.grey, size: 30),
              const SizedBox(height: 4),
              Text(id.replaceAll('_', ' '),
                  style: TextStyle(
                      color: isSelected ? color : Colors.grey, fontSize: 12)),
            ],
          ),
        ),
      ),
    );
  }
}

================
File: qristal_mobile/lib/features/sync/providers/sync_provider.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/providers/database_provider.dart';
import '../../../services/sync_service.dart';


// Service Provider
final syncServiceProvider = Provider<SyncService>((ref) {
  final db = ref.watch(databaseProvider);
  return SyncService(db);
});

// State Controller
class SyncController extends StateNotifier<AsyncValue<void>> {
  final SyncService _service;

  SyncController(this._service) : super(const AsyncData(null));

  Future<void> performSync() async {
    state = const AsyncLoading();
    try {
      await _service.syncData();
      state = const AsyncData(null);
    } catch (e, st) {
      state = AsyncError(e, st);
    }
  }
}

// Global Provider
final syncControllerProvider = StateNotifierProvider<SyncController, AsyncValue<void>>((ref) {
  return SyncController(ref.watch(syncServiceProvider));
});

================
File: qristal_mobile/lib/features/sync/providers/sync_queue_provider.dart
================
import 'dart:async';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/providers/database_provider.dart';
import 'sync_provider.dart';

enum ConnectionStatus { online, offline, syncing, error }

class SyncQueueState {
  final ConnectionStatus status;
  final int pendingOrders;

  SyncQueueState({
    this.status = ConnectionStatus.online,
    this.pendingOrders = 0,
  });

  SyncQueueState copyWith({ConnectionStatus? status, int? pendingOrders}) {
    return SyncQueueState(
      status: status ?? this.status,
      pendingOrders: pendingOrders ?? this.pendingOrders,
    );
  }
}

class SyncQueueManager extends StateNotifier<SyncQueueState> {
  final Ref ref;
  Timer? _timer;
  StreamSubscription? _connectivitySubscription;
  StreamSubscription? _dbSubscription;

  SyncQueueManager(this.ref) : super(SyncQueueState()) {
    _init();
  }

  void _init() {
    // 1. Listen to Network Connectivity changes
    _connectivitySubscription = Connectivity().onConnectivityChanged.listen((
      List<ConnectivityResult> results,
    ) {
      if (results.contains(ConnectivityResult.none)) {
        state = state.copyWith(status: ConnectionStatus.offline);
      } else {
        state = state.copyWith(status: ConnectionStatus.online);
        _triggerSync(); // Device came online -> attempt sync!
      }
    });

    // 2. Listen to Database for Unsynced Orders
    final db = ref.read(databaseProvider);
    _dbSubscription =
        (db.select(
          db.orders,
        )..where((t) => t.isSynced.equals(false))).watch().listen((orders) {
          state = state.copyWith(pendingOrders: orders.length);
          if (orders.isNotEmpty && state.status == ConnectionStatus.online) {
            _triggerSync(); // New order added -> attempt sync!
          }
        });

    // 3. Fallback Heartbeat Timer (Retry every 30 seconds if something is pending)
    _timer = Timer.periodic(const Duration(seconds: 30), (_) {
      if (state.pendingOrders > 0 && state.status != ConnectionStatus.offline) {
        _triggerSync();
      }
    });
  }

  Future<void> _triggerSync() async {
    // Prevent overlapping syncs
    if (state.status == ConnectionStatus.syncing || state.pendingOrders == 0) {
      return;
    }

    state = state.copyWith(status: ConnectionStatus.syncing);
    try {
      await ref.read(syncServiceProvider).syncData();
      state = state.copyWith(status: ConnectionStatus.online);
    } catch (e) {
      state = state.copyWith(status: ConnectionStatus.error);
    }
  }

  @override
  void dispose() {
    _timer?.cancel();
    _connectivitySubscription?.cancel();
    _dbSubscription?.cancel();
    super.dispose();
  }
}

// Global Provider
final syncQueueProvider =
    StateNotifierProvider<SyncQueueManager, SyncQueueState>((ref) {
      return SyncQueueManager(ref);
    });

================
File: qristal_mobile/lib/features/tables/screens/floor_plan_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/theme/app_theme.dart';
import '../../../core/providers/database_provider.dart';
import '../../../database/database.dart';
import '../../pos/screens/dashboard_screen.dart';

// Provider to hold the currently selected table ID
final activeTableIdProvider = StateProvider<String?>((ref) => null);

class FloorPlanScreen extends ConsumerWidget {
  const FloorPlanScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final db = ref.watch(databaseProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text("Select Table"),
        actions: [
          // Quick button for Takeaway (No table)
          TextButton.icon(
            icon: const Icon(Icons.shopping_bag),
            label: const Text("TAKEAWAY / RETAIL"),
            onPressed: () {
              ref.read(activeTableIdProvider.notifier).state = null;
              Navigator.push(
                context,
                MaterialPageRoute(builder: (_) => const DashboardScreen()),
              );
            },
          ),
        ],
      ),
      body: StreamBuilder<List<SeatingTable>>(
        stream: db.select(db.seatingTables).watch(),
        builder: (context, snapshot) {
          if (!snapshot.hasData) {
            return const Center(child: CircularProgressIndicator());
          }

          final tables = snapshot.data!;

          return GridView.builder(
            padding: const EdgeInsets.all(20),
            gridDelegate: const SliverGridDelegateWithMaxCrossAxisExtent(
              maxCrossAxisExtent: 200,
              crossAxisSpacing: 20,
              mainAxisSpacing: 20,
              childAspectRatio: 1.5,
            ),
            itemCount: tables.length,
            itemBuilder: (context, index) {
              final table = tables[index];
              final isOccupied = table.status == 'OCCUPIED';

              return GestureDetector(
                onTap: () {
                  // Set active table and go to POS
                  ref.read(activeTableIdProvider.notifier).state = table.id;
                  Navigator.push(
                    context,
                    MaterialPageRoute(builder: (_) => const DashboardScreen()),
                  );
                },
                child: Container(
                  decoration: BoxDecoration(
                    color: isOccupied
                        ? AppTheme.error.withOpacity(0.8)
                        : AppTheme.emerald.withOpacity(0.8),
                    borderRadius: BorderRadius.circular(16),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.2),
                        blurRadius: 4,
                        offset: const Offset(2, 2),
                      ),
                    ],
                  ),
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        isOccupied ? Icons.person : Icons.table_restaurant,
                        size: 40,
                        color: Colors.white,
                      ),
                      const SizedBox(height: 10),
                      Text(
                        table.name,
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 24,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Text(
                        table.status,
                        style: const TextStyle(
                          color: Colors.white70,
                          fontSize: 14,
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          );
        },
      ),
    );
  }
}

================
File: qristal_mobile/windows/flutter/CMakeLists.txt
================
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)

================
File: qristal_mobile/windows/flutter/generated_plugin_registrant.h
================
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter/plugin_registry.h>

// Registers Flutter plugins.
void RegisterPlugins(flutter::PluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_

================
File: qristal_mobile/windows/runner/CMakeLists.txt
================
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)

================
File: qristal_mobile/windows/runner/flutter_window.cpp
================
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}

================
File: qristal_mobile/windows/runner/flutter_window.h
================
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_

================
File: qristal_mobile/windows/runner/main.cpp
================
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"qristal_mobile", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}

================
File: qristal_mobile/windows/runner/resource.h
================
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

================
File: qristal_mobile/windows/runner/runner.exe.manifest
================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
      <!-- Windows 8.1 -->
      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
      <!-- Windows 8 -->
      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
      <!-- Windows 7 -->
      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
    </application>
  </compatibility>
</assembly>

================
File: qristal_mobile/windows/runner/Runner.rc
================
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#if defined(FLUTTER_VERSION_MAJOR) && defined(FLUTTER_VERSION_MINOR) && defined(FLUTTER_VERSION_PATCH) && defined(FLUTTER_VERSION_BUILD)
#define VERSION_AS_NUMBER FLUTTER_VERSION_MAJOR,FLUTTER_VERSION_MINOR,FLUTTER_VERSION_PATCH,FLUTTER_VERSION_BUILD
#else
#define VERSION_AS_NUMBER 1,0,0,0
#endif

#if defined(FLUTTER_VERSION)
#define VERSION_AS_STRING FLUTTER_VERSION
#else
#define VERSION_AS_STRING "1.0.0"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "com.example" "\0"
            VALUE "FileDescription", "qristal_mobile" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "qristal_mobile" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2026 com.example. All rights reserved." "\0"
            VALUE "OriginalFilename", "qristal_mobile.exe" "\0"
            VALUE "ProductName", "qristal_mobile" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

================
File: qristal_mobile/windows/runner/utils.cpp
================
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}

================
File: qristal_mobile/windows/runner/utils.h
================
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_

================
File: qristal_mobile/windows/runner/win32_window.cpp
================
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}

================
File: qristal_mobile/windows/runner/win32_window.h
================
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_

================
File: qristal_mobile/windows/.gitignore
================
flutter/ephemeral/

# Visual Studio user-specific files.
*.suo
*.user
*.userosscache
*.sln.docstates

# Visual Studio build-related files.
x64/
x86/

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!*.[Cc]ache/

================
File: qristal_mobile/windows/CMakeLists.txt
================
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(qristal_mobile LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "qristal_mobile")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/windows/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)

================
File: qristal_mobile/.gitignore
================
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.buildlog/
.history
.svn/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.pub-cache/
.pub/
/build/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release

================
File: qristal_mobile/.repomixignore
================
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

================
File: qristal_mobile/analysis_options.yaml
================
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options

================
File: qristal_mobile/repomix.config.json
================
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output.txt",
    "style": "plain",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "includeFullDirectoryStructure": false,
    "tokenCountTree": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false,
      "includeLogs": false,
      "includeLogsCount": 50
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDotIgnore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}

================
File: qristal-dashboard/src/app/globals.css
================
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

================
File: qristal-dashboard/src/app/layout.tsx
================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}

================
File: qristal-dashboard/.gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: qristal-dashboard/eslint.config.mjs
================
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;

================
File: qristal-dashboard/next.config.ts
================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

================
File: qristal-dashboard/postcss.config.mjs
================
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;

================
File: qristal-dashboard/README.md
================
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

================
File: qristal-dashboard/tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}

================
File: README.md
================
Get started by customizing your environment (defined in the .idx/dev.nix file) with the tools and IDE extensions you'll need for your project!

Learn more at https://developers.google.com/idx/guides/customize-idx-env

================
File: repomix.config.json
================
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output.txt",
    "style": "plain",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "includeFullDirectoryStructure": false,
    "tokenCountTree": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false,
      "includeLogs": false,
      "includeLogsCount": 50
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDotIgnore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}

================
File: qristal_mobile/.idx/dev.nix
================
{pkgs}: {
  channel = "stable-24.05";
  packages = [
    pkgs.jdk17
    pkgs.unzip
    pkgs.openssh
  ];
  idx.extensions = [
    
  ];
  idx.previews = {
    previews = {
      # web = {
      #   command = [
      #     "flutter"
      #     "run"
      #     "--machine"
      #     "-d"
      #     "web-server"
      #     "--web-hostname"
      #     "0.0.0.0"
      #     "--web-port"
      #     "$PORT"
      #   ];
      #   manager = "flutter";
      # };
      # android = {
      #   command = [
      #     "flutter"
      #     "run"
      #     "--machine"
      #     "-d"
      #     "android"
      #     "-d"
      #     "localhost:5555"
      #   ];
      #   manager = "flutter";
      # };
    };
  };
}

================
File: qristal_mobile/android/gradle/wrapper/gradle-wrapper.properties
================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.12-all.zip

================
File: qristal_mobile/android/.gitignore
================
gradle-wrapper.jar
/.gradle
/captures/
/gradlew
/gradlew.bat
/local.properties
GeneratedPluginRegistrant.java
.cxx/

# Remember to never publicly share your keystore.
# See https://flutter.dev/to/reference-keystore
key.properties
**/*.keystore
**/*.jks

================
File: qristal_mobile/android/gradle.properties
================
org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true
android.enableJetifier=true

================
File: qristal_mobile/lib/features/auth/providers/auth_provider.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/auth_service.dart';

// 1. Provider for the Service
final authServiceProvider = Provider((ref) => AuthService());

// 2. State Controller for the Login Screen
class LoginState {
  final bool isLoading;
  final String? error;
  final bool isAuthenticated;
  final String? userId;

  LoginState({
    this.isLoading = false,
    this.error,
    this.isAuthenticated = false,
    this.userId,
  });
}

class AuthController extends StateNotifier<LoginState> {
  final AuthService _authService;

  AuthController(this._authService) : super(LoginState());

  Future<void> login(String userId, String pin) async {
    state = LoginState(isLoading: true);
    try {
      await _authService.login(userId, pin);
      state = LoginState(isAuthenticated: true, userId: userId);
    } catch (e) {
      state = LoginState(error: e.toString().replaceAll('Exception: ', ''));
    }
  }
  
  Future<void> logout() async {
    await _authService.logout();
    state = LoginState(isAuthenticated: false);
  }
}

// 3. Provider for the Controller
final authControllerProvider = StateNotifierProvider<AuthController, LoginState>((ref) {
  return AuthController(ref.watch(authServiceProvider));
});

================
File: qristal_mobile/lib/features/auth/services/auth_service.dart
================
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import '../../../core/constants/api_constants.dart';

class AuthService {
  final _storage = const FlutterSecureStorage();

  Future<Map<String, dynamic>> login(String userId, String pin) async {
    try {
      final response = await http.post(
        Uri.parse('${ApiConstants.baseUrl}${ApiConstants.loginEndpoint}'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({'id': userId, 'pin': pin}),
      );
      print(pin);
      print(userId);
     
      if (response.statusCode == 201 || response.statusCode == 200) {
        final data = jsonDecode(response.body);
        print('Response body: ${response.body}');

        // Save Token Securely
        await _storage.write(key: 'jwt_token', value: data['access_token']);

        // Save User Data (optional, for offline reference)
        await _storage.write(key: 'user_data', value: jsonEncode(data['user']));

        return data;
      } else {
        throw Exception('Invalid PIN or User ID');
      }
    } catch (e) {
      throw Exception('Connection failed: $e');
    }
  }

  Future<void> logout() async {
    await _storage.deleteAll();
  }

  Future<String?> getToken() async {
    return await _storage.read(key: 'jwt_token');
  }
}

================
File: qristal_mobile/lib/features/hardware/screens/printer_settings_screen.dart
================
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:print_bluetooth_thermal/print_bluetooth_thermal.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../services/printer_service.dart';

class PrinterSettingsScreen extends ConsumerStatefulWidget {
  const PrinterSettingsScreen({super.key});

  @override
  ConsumerState<PrinterSettingsScreen> createState() => _PrinterSettingsScreenState();
}

class _PrinterSettingsScreenState extends ConsumerState<PrinterSettingsScreen> {
  List<BluetoothInfo> _devices = [];
  String? _selectedAddress;
  bool _isLoading = false;
  String _statusMessage = "";

  @override
  void initState() {
    super.initState();
    _initPrinter();
  }

  Future<void> _initPrinter() async {
    if (!Platform.isAndroid) {
      setState(() {
        _statusMessage = "Bluetooth Printing is only supported on Android terminals.";
      });
      return;
    }

    setState(() => _isLoading = true);
    final printer = ref.read(printerServiceProvider);
    
    // Check permission first
    await printer.checkPermission();
    
    final devices = await printer.getPairedDevices();
    final prefs = await SharedPreferences.getInstance();
    final savedAddress = prefs.getString('printer_mac');

    setState(() {
      _devices = devices;
      _selectedAddress = savedAddress;
      _isLoading = false;
    });
  }

  Future<void> _connect(String macAddress) async {
    setState(() => _isLoading = true);
    final printer = ref.read(printerServiceProvider);
    
    final success = await printer.connect(macAddress);
    
    setState(() {
      _isLoading = false;
    });

    if (success) {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('printer_mac', macAddress);
      setState(() => _selectedAddress = macAddress);
      
      if(mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Printer Connected!")));
    } else {
      if(mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Connection Failed")));
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Printer Settings")),
      body: Column(
        children: [
          if (_statusMessage.isNotEmpty)
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Card(color: Colors.amber, child: Padding(padding: const EdgeInsets.all(8), child: Text(_statusMessage))),
            ),
          
          if (_isLoading) const LinearProgressIndicator(),

          Expanded(
            child: _devices.isEmpty 
              ? const Center(child: Text("No paired devices found"))
              : ListView.builder(
                  itemCount: _devices.length,
                  itemBuilder: (context, index) {
                    final device = _devices[index];
                    final isConnected = _selectedAddress == device.macAdress;

                    return ListTile(
                      leading: const Icon(Icons.print),
                      title: Text(device.name),
                      subtitle: Text(device.macAdress),
                      trailing: isConnected 
                        ? const Icon(Icons.check_circle, color: Colors.green)
                        : ElevatedButton(
                            onPressed: () => _connect(device.macAdress),
                            child: const Text("Connect"),
                          ),
                    );
                  },
                ),
          ),
        ],
      ),
    );
  }
}

================
File: qristal_mobile/lib/features/hardware/services/printer_service.dart
================
import 'dart:io';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:print_bluetooth_thermal/print_bluetooth_thermal.dart';
import '../../pos/models/cart_item.dart';
import 'receipt_generator.dart';

class PrinterService {
  final _generator = ReceiptGenerator();

  // 1. Check Permissions (Android only)
  Future<bool> checkPermission() async {
    if (!Platform.isAndroid) return false;
    
    // print_bluetooth_thermal handles permission requests internally usually,
    // but explicit checking is safer.
    final bool result = await PrintBluetoothThermal.isPermissionBluetoothGranted;
    if (!result) {
       // Only if false, we might want to prompt user. 
       // For now, the library often requests it automatically.
    }
    return result;
  }

  // 2. Scan Devices
  Future<List<BluetoothInfo>> getPairedDevices() async {
    if (!Platform.isAndroid) {
      // Return empty list on Windows for now (avoid crash)
      return [];
    }
    
    // Wait slightly to ensure permissions are active
    final bool permission = await PrintBluetoothThermal.isPermissionBluetoothGranted;
    if (!permission) return [];

    try {
      final List<BluetoothInfo> list = await PrintBluetoothThermal.pairedBluetooths;
      return list;
    } catch (e) {
      print("Error finding devices: $e");
      return [];
    }
  }

  // 3. Connect
  Future<bool> connect(String macAddress) async {
    if (!Platform.isAndroid) return false;
    
    try {
      final bool connected = await PrintBluetoothThermal.connect(macPrinterAddress: macAddress);
      return connected;
    } catch (e) {
      print("Error connecting: $e");
      return false;
    }
  }

  // 4. Print
  Future<void> printReceipt({
    required String orderId,
    required List<CartItem> items,
    required double total,
    required double tendered,
    required String paymentMethod,
    required String cashierName,
  }) async {
    if (!Platform.isAndroid) {
      print("Printing not yet implemented for Windows (Requires USB driver integration)");
      return;
    }

    // Check connection status
    final bool isConnected = await PrintBluetoothThermal.connectionStatus;
    if (!isConnected) {
      print("Printer not connected");
      return;
    }

    // Generate Bytes
    final List<int> bytes = await _generator.generateTicket(
      orderId: orderId,
      items: items,
      total: total,
      tendered: tendered,
      paymentMethod: paymentMethod,
      cashierName: cashierName,
    );

    // Send to Printer
    await PrintBluetoothThermal.writeBytes(bytes);
  }
}

final printerServiceProvider = Provider((ref) => PrinterService());

================
File: qristal_mobile/lib/services/websocket_service.dart
================
import 'package:flutter/foundation.dart';
import 'package:socket_io_client/socket_io_client.dart' as IO;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../core/constants/api_constants.dart';
import '../features/sync/providers/sync_provider.dart';

class WebSocketService {
  late IO.Socket socket;
  final Ref ref;

  WebSocketService(this.ref) {
    _init();
  }

  void _init() {
    // Replace this with your actual Render URL
    final String serverUrl = ApiConstants.baseUrl;

    socket = IO.io(serverUrl, <String, dynamic>{
      'transports': ['websocket'],
      'autoConnect': true,
    });

    socket.onConnect((_) {
      if (kDebugMode) {
        print(' Connected to WebSocket Server');
      }
    });

    // Listen for new orders (This is where the magic happens for the KDS)
    socket.on('newOrder', (data) {
      if (kDebugMode) {
        print(' New order received via WebSocket! Forcing sync...');
      }
      // When the server says a new order arrived, tell our local DB to pull it!
      ref.read(syncControllerProvider.notifier).performSync();
    });

    socket.onDisconnect((_) => print(' Disconnected from WebSocket'));
  }

  void dispose() {
    socket.dispose();
  }
}

// Provider
final webSocketProvider = Provider<WebSocketService>((ref) {
  return WebSocketService(ref);
});

================
File: qristal_mobile/test/widget_test.dart
================
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';



void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
  

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}

================
File: qristal_mobile/.metadata
================
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "05db9689081f091050f01aed79f04dce0c750154"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: 05db9689081f091050f01aed79f04dce0c750154
      base_revision: 05db9689081f091050f01aed79f04dce0c750154
    - platform: android
      create_revision: 05db9689081f091050f01aed79f04dce0c750154
      base_revision: 05db9689081f091050f01aed79f04dce0c750154
    - platform: ios
      create_revision: 05db9689081f091050f01aed79f04dce0c750154
      base_revision: 05db9689081f091050f01aed79f04dce0c750154
    - platform: linux
      create_revision: 05db9689081f091050f01aed79f04dce0c750154
      base_revision: 05db9689081f091050f01aed79f04dce0c750154
    - platform: macos
      create_revision: 05db9689081f091050f01aed79f04dce0c750154
      base_revision: 05db9689081f091050f01aed79f04dce0c750154
    - platform: web
      create_revision: 05db9689081f091050f01aed79f04dce0c750154
      base_revision: 05db9689081f091050f01aed79f04dce0c750154
    - platform: windows
      create_revision: 05db9689081f091050f01aed79f04dce0c750154
      base_revision: 05db9689081f091050f01aed79f04dce0c750154

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'

================
File: qristal_mobile/README.md
================
# qristal_mobile

A new Flutter project.

## Getting Started

This project is a starting point for a Flutter application.

A few resources to get you started if this is your first Flutter project:

- [Lab: Write your first Flutter app](https://docs.flutter.dev/get-started/codelab)
- [Cookbook: Useful Flutter samples](https://docs.flutter.dev/cookbook)

For help getting started with Flutter development, view the
[online documentation](https://docs.flutter.dev/), which offers tutorials,
samples, guidance on mobile development, and a full API reference.
# Qristal-POS-Mobile

================
File: qristal-dashboard/package.json
================
{
  "name": "qristal-dashboard",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "next": "16.1.6",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "recharts": "^3.7.0",
    "socket.io-client": "^4.8.3"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "16.1.6",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}

================
File: .idx/dev.nix
================
{ pkgs, ... }: {
  # Which nixpkgs channel to use.
  channel = "stable-24.05"; 
  
  # Use https://search.nixos.org/packages to find packages
  packages = [
    pkgs.docker
    pkgs.docker-compose # Added for convenience
    pkgs.openssl
    pkgs.nodejs_20
    pkgs.flutter
    pkgs.openssh
  ];

  # Enable the Docker daemon service
  services.docker.enable = true;

  # Sets environment variables in the workspace
  env = {};
  
  idx = {
    extensions = [
      "google.gemini-cli-vscode-ide-companion"
    ];
    previews = {
      enable = true;
      previews = {
        # web = {
        #   command = ["npm" "run" "dev"];
        #   manager = "web";
        #   env = {
        #     PORT = "$PORT";
        #   };
        # };
      };
    };
    workspace = {
      onCreate = {
        default.openFiles = [ ".idx/dev.nix" "README.md" ];
      };
      onStart = {
      };
    };
  };
}

================
File: qristal_mobile/lib/core/constants/api_constants.dart
================
class ApiConstants {
  // Use 10.0.2.2 for Android Emulator, localhost for iOS/Web
static String get baseUrl {
    // Return your Railway URL (HTTPS is standard)
    //return 'https://api.truthysystems.com';
    return 'https://qristal-pos-api.onrender.com';
  }

  static const String loginEndpoint = '/auth/login';
  static const String syncPushEndpoint = '/sync/push';
}

================
File: qristal_mobile/lib/features/kitchen/screens/kitchen_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/theme/app_theme.dart';
import '../../../core/providers/database_provider.dart';
import '../../../database/database.dart';
import '../../sync/providers/sync_provider.dart';

class KitchenScreen extends ConsumerWidget {
  const KitchenScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final db = ref.watch(databaseProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text("Kitchen Display System"),
        backgroundColor: AppTheme.surface,
        actions: [
          // Optional: A button to manually trigger a sync if needed
          IconButton(
            icon: const Icon(Icons.refresh),
            tooltip: "Force Sync",
            onPressed: () {
              // ref.read(syncControllerProvider.notifier).performSync();
              ScaffoldMessenger.of(
                context,
              ).showSnackBar(const SnackBar(content: Text("Syncing...")));
            },
          ),
          const SizedBox(width: 16),
        ],
      ),
      body: StreamBuilder<List<Order>>(
        stream: db.watchKitchenOrders(),
        builder: (context, snapshot) {
          if (!snapshot.hasData) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(
              child: Text(
                'Error loading orders: ${snapshot.error}',
                style: const TextStyle(color: Colors.red),
              ),
            );
          }

          final orders = snapshot.data ?? [];

          if (orders.isEmpty) {
            return const Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.check_circle_outline,
                    size: 80,
                    color: Colors.green,
                  ),
                  SizedBox(height: 16),
                  Text(
                    "No pending orders. Good job!",
                    style: TextStyle(color: Colors.grey, fontSize: 24),
                  ),
                ],
              ),
            );
          }

          return ListView.builder(
            scrollDirection: Axis.horizontal, // KDS usually scrolls sideways
            itemCount: orders.length,
            padding: const EdgeInsets.all(16),
            itemBuilder: (context, index) {
              return KitchenTicket(order: orders[index]);
            },
          );
        },
      ),
    );
  }
}

class KitchenTicket extends ConsumerStatefulWidget {
  final Order order;
  const KitchenTicket({super.key, required this.order});

  @override
  ConsumerState<KitchenTicket> createState() => _KitchenTicketState();
}

class _KitchenTicketState extends ConsumerState<KitchenTicket> {
  late Future<List<TypedOrderItem>> _itemsFuture;

  @override
  void initState() {
    super.initState();
    _loadItems();
  }

  void _loadItems() {
    final db = ref.read(databaseProvider);
    _itemsFuture = db.getOrderItems(widget.order.id);
  }

  @override
  Widget build(BuildContext context) {
    final db = ref.read(databaseProvider);
    final isPreparing = widget.order.status == 'PREPARING';

    return Container(
      width: 300,
      margin: const EdgeInsets.only(right: 16),
      decoration: BoxDecoration(
        color: AppTheme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: isPreparing ? Colors.orange : AppTheme.qristalBlue,
          width: 3,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.3),
            blurRadius: 8,
            offset: const Offset(4, 4),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // Header
          Container(
            padding: const EdgeInsets.all(12),
            color: isPreparing
                ? Colors.orange.withOpacity(0.2)
                : AppTheme.qristalBlue.withOpacity(0.2),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  "#${widget.order.receiptNumber}",
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 18,
                  ),
                ),
                Text(
                  widget.order.createdAt
                      .toLocal()
                      .toString()
                      .split(' ')[1]
                      .substring(0, 5), // Time HH:MM
                  style: const TextStyle(color: Colors.grey),
                ),
              ],
            ),
          ),

          // Items List
          Expanded(
            child: FutureBuilder<List<TypedOrderItem>>(
              future: _itemsFuture,
              builder: (context, snapshot) {
                if (!snapshot.hasData)
                  return const Center(child: CircularProgressIndicator());

                return ListView.separated(
                  padding: const EdgeInsets.all(12),
                  itemCount: snapshot.data!.length,
                  separatorBuilder: (_, __) => const Divider(),
                  itemBuilder: (context, index) {
                    final itemData = snapshot.data![index];
                    return Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 8,
                            vertical: 4,
                          ),
                          decoration: BoxDecoration(
                            color: Colors.grey[800],
                            borderRadius: BorderRadius.circular(4),
                          ),
                          child: Text(
                            "${itemData.item.quantity}x",
                            style: const TextStyle(fontWeight: FontWeight.bold),
                          ),
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                itemData.product.name,
                                style: const TextStyle(fontSize: 16),
                              ),
                              if (itemData.item.notes != null &&
                                  itemData.item.notes!.isNotEmpty)
                                Text(
                                  "Note: ${itemData.item.notes}",
                                  style: const TextStyle(
                                    color: AppTheme.error,
                                    fontSize: 12,
                                  ),
                                ),
                            ],
                          ),
                        ),
                      ],
                    );
                  },
                );
              },
            ),
          ),

          // Footer Actions
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: SizedBox(
              width: double.infinity,
              height: 50,
              child: ElevatedButton(
                style: ElevatedButton.styleFrom(
                  backgroundColor: isPreparing
                      ? AppTheme.emerald
                      : Colors.orange,
                ),
                onPressed: () async {
                  String newStatus = isPreparing ? 'READY' : 'PREPARING';
                  await db.updateOrderStatus(widget.order.id, newStatus);

                  // Trigger sync to let server/cashiers know
                  ref.read(syncControllerProvider.notifier).performSync();
                },
                child: Text(isPreparing ? "MARK DONE" : "START COOKING"),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

================
File: qristal_mobile/lib/features/pos/services/order_service.dart
================
import 'package:drift/drift.dart';
import 'package:uuid/uuid.dart';
import '../../../database/database.dart';
import '../models/cart_item.dart';

class OrderService {
  final AppDatabase db;
  final Uuid uuid = const Uuid();

  OrderService(this.db);

  Future<void> placeOrder({
    required List<CartItem> cartItems,
    required String userId,
    String? tableId,
  }) async {
    final orderId = uuid.v4();
    final totalAmount = cartItems.fold(0.0, (sum, item) => sum + item.total);

    await db.transaction(() async {
      // 1. Create the Order Header
      await db.into(db.orders).insert(OrdersCompanion(
        id: Value(orderId),
        userId: Value(userId),
        tableId: Value(tableId),
        receiptNumber: Value(orderId.substring(0, 4).toUpperCase()), // Simple receipt ID
        totalAmount: Value(totalAmount),
        status: const Value('KITCHEN'), // Default status
        isSynced: const Value(false), // Mark as unsynced!
        createdAt: Value(DateTime.now()),
        updatedAt: Value(DateTime.now()),
      ));

      // 2. Create Order Items
      for (final item in cartItems) {
        await db.into(db.orderItems).insert(OrderItemsCompanion(
          id: Value(uuid.v4()),
          orderId: Value(orderId),
          productId: Value(item.product.id),
          quantity: Value(item.quantity),
          priceAtTimeOfOrder: Value(item.product.price),
          notes: Value(item.notes),
        ));
      }
    });
  }

  Future<void> closeOrder(String orderId, double totalAmount, List<Payment> payments) async {
    await db.transaction(() async {
      // 1. Update order status
      await (db.update(db.orders)..where((t) => t.id.equals(orderId)))
          .write(OrdersCompanion(
        status: const Value('CLOSED'),
        totalAmount: Value(totalAmount),
        isSynced: const Value(false), // Mark for sync again!
        updatedAt: Value(DateTime.now()),
      ));

      // 2. Insert payments
      for (final payment in payments) {
        await db.into(db.payments).insert(payment.toCompanion(true));
      }
    });
  }
}

================
File: qristal-dashboard/src/app/page.tsx
================
"use client";

import { useCallback, useEffect, useState } from 'react';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  ReferenceLine,
} from 'recharts';
import { io, Socket } from 'socket.io-client';

const SERVER_URL = 'https://qristal-pos-api.onrender.com';
const REFRESH_INTERVAL_MS = 10000;

type InventoryItem = {
  id: string;
  name: string;
  sku?: string;
  unitOfMeasure: string;
  currentStock: number;
  minimumStock: number;
  costPerUnit: number;
};

export default function Dashboard() {
  const [inventory, setInventory] = useState<InventoryItem[]>([]);
  const [loading, setLoading] = useState(true);

  const fetchInventory = useCallback(async () => {
    try {
      const response = await fetch(`${SERVER_URL}/inventory`, {
        cache: 'no-store',
      });
      const data = await response.json();
      setInventory(data);
    } catch (error) {
      console.error('Error fetching inventory:', error);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    void fetchInventory();

    const socket: Socket = io(SERVER_URL, {
      transports: ['websocket', 'polling'],
      reconnection: true,
    });

    socket.on('connect', () => {
      console.log('Dashboard connected to live server!');
    });

    socket.on('connect_error', (error) => {
      console.error('Socket connection error, relying on polling fallback:', error.message);
    });

    const handleInventoryUpdate = (updatedInventoryData: InventoryItem[]) => {
      console.log(' Real-time inventory update received!');
      setInventory(updatedInventoryData);
    };

    // Support both common event names to avoid missing updates because of naming mismatch.
    socket.on('inventoryUpdate', handleInventoryUpdate);
    socket.on('inventoryUpdated', handleInventoryUpdate);

    const refreshTimer = setInterval(() => {
      void fetchInventory();
    }, REFRESH_INTERVAL_MS);

    return () => {
      clearInterval(refreshTimer);
      socket.disconnect();
    };
  }, [fetchInventory]);

  if (loading) return <div className="p-8">Loading live data...</div>;

  return (
    <main className="min-h-screen bg-gray-50 p-8">
      <div className="max-w-6xl mx-auto">
        {/* Header */}
        <header className="flex justify-between items-center mb-8">
          <div>
            <h1 className="text-3xl font-bold text-gray-900">Qristal Dashboard</h1>
            <p className="text-gray-500">Real-time inventory & analytics</p>
          </div>
          <div className="bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold shadow">
            Owner Portal
          </div>
        </header>

        {/* Chart Section */}
        <div className="bg-white p-6 rounded-xl shadow-sm border border-gray-100 mb-8">
          <h2 className="text-xl font-bold text-gray-800 mb-6">Current Stock Levels</h2>
          <div className="h-80 w-full">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart data={inventory} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
                <CartesianGrid strokeDasharray="3 3" vertical={false} />
                <XAxis dataKey="name" axisLine={false} tickLine={false} />
                <YAxis axisLine={false} tickLine={false} />
                <Tooltip cursor={{ fill: '#f3f4f6' }} />
                <Legend />
                {/* Red line showing minimum safe stock level at 20 */}
                <ReferenceLine y={20} label="Low Stock Warning" stroke="red" strokeDasharray="3 3" />
                <Bar dataKey="currentStock" name="Current Stock" fill="#0EA5E9" radius={[4, 4, 0, 0]} />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </div>

        {/* Data Table Section */}
        <div className="bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Item Name</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">SKU</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Unit</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Current Stock</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Unit Cost</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {inventory.map((item) => (
                <tr key={item.id} className="hover:bg-gray-50 transition-colors">
                  <td className="px-6 py-4 whitespace-nowrap font-medium text-gray-900">{item.name}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-gray-500">{item.sku || 'N/A'}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-gray-500">{item.unitOfMeasure}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-gray-900">{item.currentStock}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-gray-500">UGX {item.costPerUnit}</td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    {item.currentStock > item.minimumStock ? (
                      <span className="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-100 text-green-800">
                        In Stock
                      </span>
                    ) : (
                      <span className="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-red-100 text-red-800">
                        Low Stock
                      </span>
                    )}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    </main>
  );
}

================
File: qristal_mobile/android/app/src/main/AndroidManifest.xml
================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.BLUETOOTH" />
<uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
<uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
<uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <application
        android:label="qristal POS"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>

================
File: qristal_mobile/lib/database/database.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $CategoriesTable extends Categories
    with TableInfo<$CategoriesTable, Category> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CategoriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _colorHexMeta = const VerificationMeta(
    'colorHex',
  );
  @override
  late final GeneratedColumn<String> colorHex = GeneratedColumn<String>(
    'color_hex',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    colorHex,
    sortOrder,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'categories';
  @override
  VerificationContext validateIntegrity(
    Insertable<Category> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('color_hex')) {
      context.handle(
        _colorHexMeta,
        colorHex.isAcceptableOrUnknown(data['color_hex']!, _colorHexMeta),
      );
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Category map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Category(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      colorHex: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}color_hex'],
      ),
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      ),
    );
  }

  @override
  $CategoriesTable createAlias(String alias) {
    return $CategoriesTable(attachedDatabase, alias);
  }
}

class Category extends DataClass implements Insertable<Category> {
  final String id;
  final String name;
  final String? colorHex;
  final int sortOrder;
  final DateTime? updatedAt;
  const Category({
    required this.id,
    required this.name,
    this.colorHex,
    required this.sortOrder,
    this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || colorHex != null) {
      map['color_hex'] = Variable<String>(colorHex);
    }
    map['sort_order'] = Variable<int>(sortOrder);
    if (!nullToAbsent || updatedAt != null) {
      map['updated_at'] = Variable<DateTime>(updatedAt);
    }
    return map;
  }

  CategoriesCompanion toCompanion(bool nullToAbsent) {
    return CategoriesCompanion(
      id: Value(id),
      name: Value(name),
      colorHex: colorHex == null && nullToAbsent
          ? const Value.absent()
          : Value(colorHex),
      sortOrder: Value(sortOrder),
      updatedAt: updatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAt),
    );
  }

  factory Category.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Category(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      colorHex: serializer.fromJson<String?>(json['colorHex']),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
      updatedAt: serializer.fromJson<DateTime?>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'colorHex': serializer.toJson<String?>(colorHex),
      'sortOrder': serializer.toJson<int>(sortOrder),
      'updatedAt': serializer.toJson<DateTime?>(updatedAt),
    };
  }

  Category copyWith({
    String? id,
    String? name,
    Value<String?> colorHex = const Value.absent(),
    int? sortOrder,
    Value<DateTime?> updatedAt = const Value.absent(),
  }) => Category(
    id: id ?? this.id,
    name: name ?? this.name,
    colorHex: colorHex.present ? colorHex.value : this.colorHex,
    sortOrder: sortOrder ?? this.sortOrder,
    updatedAt: updatedAt.present ? updatedAt.value : this.updatedAt,
  );
  Category copyWithCompanion(CategoriesCompanion data) {
    return Category(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      colorHex: data.colorHex.present ? data.colorHex.value : this.colorHex,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Category(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('colorHex: $colorHex, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name, colorHex, sortOrder, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Category &&
          other.id == this.id &&
          other.name == this.name &&
          other.colorHex == this.colorHex &&
          other.sortOrder == this.sortOrder &&
          other.updatedAt == this.updatedAt);
}

class CategoriesCompanion extends UpdateCompanion<Category> {
  final Value<String> id;
  final Value<String> name;
  final Value<String?> colorHex;
  final Value<int> sortOrder;
  final Value<DateTime?> updatedAt;
  final Value<int> rowid;
  const CategoriesCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.colorHex = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CategoriesCompanion.insert({
    required String id,
    required String name,
    this.colorHex = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name);
  static Insertable<Category> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? colorHex,
    Expression<int>? sortOrder,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (colorHex != null) 'color_hex': colorHex,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CategoriesCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String?>? colorHex,
    Value<int>? sortOrder,
    Value<DateTime?>? updatedAt,
    Value<int>? rowid,
  }) {
    return CategoriesCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      colorHex: colorHex ?? this.colorHex,
      sortOrder: sortOrder ?? this.sortOrder,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (colorHex.present) {
      map['color_hex'] = Variable<String>(colorHex.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CategoriesCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('colorHex: $colorHex, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProductsTable extends Products with TableInfo<$ProductsTable, Product> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProductsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _categoryIdMeta = const VerificationMeta(
    'categoryId',
  );
  @override
  late final GeneratedColumn<String> categoryId = GeneratedColumn<String>(
    'category_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES categories (id)',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
    'price',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isAvailableMeta = const VerificationMeta(
    'isAvailable',
  );
  @override
  late final GeneratedColumn<bool> isAvailable = GeneratedColumn<bool>(
    'is_available',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_available" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    categoryId,
    name,
    price,
    isAvailable,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'products';
  @override
  VerificationContext validateIntegrity(
    Insertable<Product> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('category_id')) {
      context.handle(
        _categoryIdMeta,
        categoryId.isAcceptableOrUnknown(data['category_id']!, _categoryIdMeta),
      );
    } else if (isInserting) {
      context.missing(_categoryIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('price')) {
      context.handle(
        _priceMeta,
        price.isAcceptableOrUnknown(data['price']!, _priceMeta),
      );
    } else if (isInserting) {
      context.missing(_priceMeta);
    }
    if (data.containsKey('is_available')) {
      context.handle(
        _isAvailableMeta,
        isAvailable.isAcceptableOrUnknown(
          data['is_available']!,
          _isAvailableMeta,
        ),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Product map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Product(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      categoryId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}category_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      price: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price'],
      )!,
      isAvailable: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_available'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      ),
    );
  }

  @override
  $ProductsTable createAlias(String alias) {
    return $ProductsTable(attachedDatabase, alias);
  }
}

class Product extends DataClass implements Insertable<Product> {
  final String id;
  final String categoryId;
  final String name;
  final double price;
  final bool isAvailable;
  final DateTime? updatedAt;
  const Product({
    required this.id,
    required this.categoryId,
    required this.name,
    required this.price,
    required this.isAvailable,
    this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['category_id'] = Variable<String>(categoryId);
    map['name'] = Variable<String>(name);
    map['price'] = Variable<double>(price);
    map['is_available'] = Variable<bool>(isAvailable);
    if (!nullToAbsent || updatedAt != null) {
      map['updated_at'] = Variable<DateTime>(updatedAt);
    }
    return map;
  }

  ProductsCompanion toCompanion(bool nullToAbsent) {
    return ProductsCompanion(
      id: Value(id),
      categoryId: Value(categoryId),
      name: Value(name),
      price: Value(price),
      isAvailable: Value(isAvailable),
      updatedAt: updatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAt),
    );
  }

  factory Product.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Product(
      id: serializer.fromJson<String>(json['id']),
      categoryId: serializer.fromJson<String>(json['categoryId']),
      name: serializer.fromJson<String>(json['name']),
      price: serializer.fromJson<double>(json['price']),
      isAvailable: serializer.fromJson<bool>(json['isAvailable']),
      updatedAt: serializer.fromJson<DateTime?>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'categoryId': serializer.toJson<String>(categoryId),
      'name': serializer.toJson<String>(name),
      'price': serializer.toJson<double>(price),
      'isAvailable': serializer.toJson<bool>(isAvailable),
      'updatedAt': serializer.toJson<DateTime?>(updatedAt),
    };
  }

  Product copyWith({
    String? id,
    String? categoryId,
    String? name,
    double? price,
    bool? isAvailable,
    Value<DateTime?> updatedAt = const Value.absent(),
  }) => Product(
    id: id ?? this.id,
    categoryId: categoryId ?? this.categoryId,
    name: name ?? this.name,
    price: price ?? this.price,
    isAvailable: isAvailable ?? this.isAvailable,
    updatedAt: updatedAt.present ? updatedAt.value : this.updatedAt,
  );
  Product copyWithCompanion(ProductsCompanion data) {
    return Product(
      id: data.id.present ? data.id.value : this.id,
      categoryId: data.categoryId.present
          ? data.categoryId.value
          : this.categoryId,
      name: data.name.present ? data.name.value : this.name,
      price: data.price.present ? data.price.value : this.price,
      isAvailable: data.isAvailable.present
          ? data.isAvailable.value
          : this.isAvailable,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Product(')
          ..write('id: $id, ')
          ..write('categoryId: $categoryId, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('isAvailable: $isAvailable, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, categoryId, name, price, isAvailable, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Product &&
          other.id == this.id &&
          other.categoryId == this.categoryId &&
          other.name == this.name &&
          other.price == this.price &&
          other.isAvailable == this.isAvailable &&
          other.updatedAt == this.updatedAt);
}

class ProductsCompanion extends UpdateCompanion<Product> {
  final Value<String> id;
  final Value<String> categoryId;
  final Value<String> name;
  final Value<double> price;
  final Value<bool> isAvailable;
  final Value<DateTime?> updatedAt;
  final Value<int> rowid;
  const ProductsCompanion({
    this.id = const Value.absent(),
    this.categoryId = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.isAvailable = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProductsCompanion.insert({
    required String id,
    required String categoryId,
    required String name,
    required double price,
    this.isAvailable = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       categoryId = Value(categoryId),
       name = Value(name),
       price = Value(price);
  static Insertable<Product> custom({
    Expression<String>? id,
    Expression<String>? categoryId,
    Expression<String>? name,
    Expression<double>? price,
    Expression<bool>? isAvailable,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (categoryId != null) 'category_id': categoryId,
      if (name != null) 'name': name,
      if (price != null) 'price': price,
      if (isAvailable != null) 'is_available': isAvailable,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProductsCompanion copyWith({
    Value<String>? id,
    Value<String>? categoryId,
    Value<String>? name,
    Value<double>? price,
    Value<bool>? isAvailable,
    Value<DateTime?>? updatedAt,
    Value<int>? rowid,
  }) {
    return ProductsCompanion(
      id: id ?? this.id,
      categoryId: categoryId ?? this.categoryId,
      name: name ?? this.name,
      price: price ?? this.price,
      isAvailable: isAvailable ?? this.isAvailable,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (categoryId.present) {
      map['category_id'] = Variable<String>(categoryId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (isAvailable.present) {
      map['is_available'] = Variable<bool>(isAvailable.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProductsCompanion(')
          ..write('id: $id, ')
          ..write('categoryId: $categoryId, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('isAvailable: $isAvailable, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OrdersTable extends Orders with TableInfo<$OrdersTable, Order> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OrdersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _receiptNumberMeta = const VerificationMeta(
    'receiptNumber',
  );
  @override
  late final GeneratedColumn<String> receiptNumber = GeneratedColumn<String>(
    'receipt_number',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _tableIdMeta = const VerificationMeta(
    'tableId',
  );
  @override
  late final GeneratedColumn<String> tableId = GeneratedColumn<String>(
    'table_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _totalAmountMeta = const VerificationMeta(
    'totalAmount',
  );
  @override
  late final GeneratedColumn<double> totalAmount = GeneratedColumn<double>(
    'total_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    receiptNumber,
    userId,
    tableId,
    totalAmount,
    status,
    createdAt,
    updatedAt,
    isSynced,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'orders';
  @override
  VerificationContext validateIntegrity(
    Insertable<Order> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('receipt_number')) {
      context.handle(
        _receiptNumberMeta,
        receiptNumber.isAcceptableOrUnknown(
          data['receipt_number']!,
          _receiptNumberMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_receiptNumberMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('table_id')) {
      context.handle(
        _tableIdMeta,
        tableId.isAcceptableOrUnknown(data['table_id']!, _tableIdMeta),
      );
    }
    if (data.containsKey('total_amount')) {
      context.handle(
        _totalAmountMeta,
        totalAmount.isAcceptableOrUnknown(
          data['total_amount']!,
          _totalAmountMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_totalAmountMeta);
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    } else if (isInserting) {
      context.missing(_statusMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Order map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Order(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      receiptNumber: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}receipt_number'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      tableId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}table_id'],
      ),
      totalAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}total_amount'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
    );
  }

  @override
  $OrdersTable createAlias(String alias) {
    return $OrdersTable(attachedDatabase, alias);
  }
}

class Order extends DataClass implements Insertable<Order> {
  final String id;
  final String receiptNumber;
  final String userId;
  final String? tableId;
  final double totalAmount;
  final String status;
  final DateTime createdAt;
  final DateTime updatedAt;
  final bool isSynced;
  const Order({
    required this.id,
    required this.receiptNumber,
    required this.userId,
    this.tableId,
    required this.totalAmount,
    required this.status,
    required this.createdAt,
    required this.updatedAt,
    required this.isSynced,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['receipt_number'] = Variable<String>(receiptNumber);
    map['user_id'] = Variable<String>(userId);
    if (!nullToAbsent || tableId != null) {
      map['table_id'] = Variable<String>(tableId);
    }
    map['total_amount'] = Variable<double>(totalAmount);
    map['status'] = Variable<String>(status);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['is_synced'] = Variable<bool>(isSynced);
    return map;
  }

  OrdersCompanion toCompanion(bool nullToAbsent) {
    return OrdersCompanion(
      id: Value(id),
      receiptNumber: Value(receiptNumber),
      userId: Value(userId),
      tableId: tableId == null && nullToAbsent
          ? const Value.absent()
          : Value(tableId),
      totalAmount: Value(totalAmount),
      status: Value(status),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      isSynced: Value(isSynced),
    );
  }

  factory Order.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Order(
      id: serializer.fromJson<String>(json['id']),
      receiptNumber: serializer.fromJson<String>(json['receiptNumber']),
      userId: serializer.fromJson<String>(json['userId']),
      tableId: serializer.fromJson<String?>(json['tableId']),
      totalAmount: serializer.fromJson<double>(json['totalAmount']),
      status: serializer.fromJson<String>(json['status']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      isSynced: serializer.fromJson<bool>(json['isSynced']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'receiptNumber': serializer.toJson<String>(receiptNumber),
      'userId': serializer.toJson<String>(userId),
      'tableId': serializer.toJson<String?>(tableId),
      'totalAmount': serializer.toJson<double>(totalAmount),
      'status': serializer.toJson<String>(status),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'isSynced': serializer.toJson<bool>(isSynced),
    };
  }

  Order copyWith({
    String? id,
    String? receiptNumber,
    String? userId,
    Value<String?> tableId = const Value.absent(),
    double? totalAmount,
    String? status,
    DateTime? createdAt,
    DateTime? updatedAt,
    bool? isSynced,
  }) => Order(
    id: id ?? this.id,
    receiptNumber: receiptNumber ?? this.receiptNumber,
    userId: userId ?? this.userId,
    tableId: tableId.present ? tableId.value : this.tableId,
    totalAmount: totalAmount ?? this.totalAmount,
    status: status ?? this.status,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    isSynced: isSynced ?? this.isSynced,
  );
  Order copyWithCompanion(OrdersCompanion data) {
    return Order(
      id: data.id.present ? data.id.value : this.id,
      receiptNumber: data.receiptNumber.present
          ? data.receiptNumber.value
          : this.receiptNumber,
      userId: data.userId.present ? data.userId.value : this.userId,
      tableId: data.tableId.present ? data.tableId.value : this.tableId,
      totalAmount: data.totalAmount.present
          ? data.totalAmount.value
          : this.totalAmount,
      status: data.status.present ? data.status.value : this.status,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Order(')
          ..write('id: $id, ')
          ..write('receiptNumber: $receiptNumber, ')
          ..write('userId: $userId, ')
          ..write('tableId: $tableId, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    receiptNumber,
    userId,
    tableId,
    totalAmount,
    status,
    createdAt,
    updatedAt,
    isSynced,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Order &&
          other.id == this.id &&
          other.receiptNumber == this.receiptNumber &&
          other.userId == this.userId &&
          other.tableId == this.tableId &&
          other.totalAmount == this.totalAmount &&
          other.status == this.status &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.isSynced == this.isSynced);
}

class OrdersCompanion extends UpdateCompanion<Order> {
  final Value<String> id;
  final Value<String> receiptNumber;
  final Value<String> userId;
  final Value<String?> tableId;
  final Value<double> totalAmount;
  final Value<String> status;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<bool> isSynced;
  final Value<int> rowid;
  const OrdersCompanion({
    this.id = const Value.absent(),
    this.receiptNumber = const Value.absent(),
    this.userId = const Value.absent(),
    this.tableId = const Value.absent(),
    this.totalAmount = const Value.absent(),
    this.status = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isSynced = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OrdersCompanion.insert({
    required String id,
    required String receiptNumber,
    required String userId,
    this.tableId = const Value.absent(),
    required double totalAmount,
    required String status,
    required DateTime createdAt,
    required DateTime updatedAt,
    this.isSynced = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       receiptNumber = Value(receiptNumber),
       userId = Value(userId),
       totalAmount = Value(totalAmount),
       status = Value(status),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<Order> custom({
    Expression<String>? id,
    Expression<String>? receiptNumber,
    Expression<String>? userId,
    Expression<String>? tableId,
    Expression<double>? totalAmount,
    Expression<String>? status,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<bool>? isSynced,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (receiptNumber != null) 'receipt_number': receiptNumber,
      if (userId != null) 'user_id': userId,
      if (tableId != null) 'table_id': tableId,
      if (totalAmount != null) 'total_amount': totalAmount,
      if (status != null) 'status': status,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (isSynced != null) 'is_synced': isSynced,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OrdersCompanion copyWith({
    Value<String>? id,
    Value<String>? receiptNumber,
    Value<String>? userId,
    Value<String?>? tableId,
    Value<double>? totalAmount,
    Value<String>? status,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<bool>? isSynced,
    Value<int>? rowid,
  }) {
    return OrdersCompanion(
      id: id ?? this.id,
      receiptNumber: receiptNumber ?? this.receiptNumber,
      userId: userId ?? this.userId,
      tableId: tableId ?? this.tableId,
      totalAmount: totalAmount ?? this.totalAmount,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      isSynced: isSynced ?? this.isSynced,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (receiptNumber.present) {
      map['receipt_number'] = Variable<String>(receiptNumber.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (tableId.present) {
      map['table_id'] = Variable<String>(tableId.value);
    }
    if (totalAmount.present) {
      map['total_amount'] = Variable<double>(totalAmount.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OrdersCompanion(')
          ..write('id: $id, ')
          ..write('receiptNumber: $receiptNumber, ')
          ..write('userId: $userId, ')
          ..write('tableId: $tableId, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isSynced: $isSynced, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OrderItemsTable extends OrderItems
    with TableInfo<$OrderItemsTable, OrderItem> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OrderItemsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _orderIdMeta = const VerificationMeta(
    'orderId',
  );
  @override
  late final GeneratedColumn<String> orderId = GeneratedColumn<String>(
    'order_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES orders (id)',
    ),
  );
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<String> productId = GeneratedColumn<String>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES products (id)',
    ),
  );
  static const VerificationMeta _quantityMeta = const VerificationMeta(
    'quantity',
  );
  @override
  late final GeneratedColumn<int> quantity = GeneratedColumn<int>(
    'quantity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _priceAtTimeOfOrderMeta =
      const VerificationMeta('priceAtTimeOfOrder');
  @override
  late final GeneratedColumn<double> priceAtTimeOfOrder =
      GeneratedColumn<double>(
        'price_at_time_of_order',
        aliasedName,
        false,
        type: DriftSqlType.double,
        requiredDuringInsert: true,
      );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    orderId,
    productId,
    quantity,
    priceAtTimeOfOrder,
    notes,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'order_items';
  @override
  VerificationContext validateIntegrity(
    Insertable<OrderItem> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('order_id')) {
      context.handle(
        _orderIdMeta,
        orderId.isAcceptableOrUnknown(data['order_id']!, _orderIdMeta),
      );
    } else if (isInserting) {
      context.missing(_orderIdMeta);
    }
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(
        _quantityMeta,
        quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta),
      );
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('price_at_time_of_order')) {
      context.handle(
        _priceAtTimeOfOrderMeta,
        priceAtTimeOfOrder.isAcceptableOrUnknown(
          data['price_at_time_of_order']!,
          _priceAtTimeOfOrderMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_priceAtTimeOfOrderMeta);
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OrderItem map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OrderItem(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      orderId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}order_id'],
      )!,
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_id'],
      )!,
      quantity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}quantity'],
      )!,
      priceAtTimeOfOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price_at_time_of_order'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
    );
  }

  @override
  $OrderItemsTable createAlias(String alias) {
    return $OrderItemsTable(attachedDatabase, alias);
  }
}

class OrderItem extends DataClass implements Insertable<OrderItem> {
  final String id;
  final String orderId;
  final String productId;
  final int quantity;
  final double priceAtTimeOfOrder;
  final String? notes;
  const OrderItem({
    required this.id,
    required this.orderId,
    required this.productId,
    required this.quantity,
    required this.priceAtTimeOfOrder,
    this.notes,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['order_id'] = Variable<String>(orderId);
    map['product_id'] = Variable<String>(productId);
    map['quantity'] = Variable<int>(quantity);
    map['price_at_time_of_order'] = Variable<double>(priceAtTimeOfOrder);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    return map;
  }

  OrderItemsCompanion toCompanion(bool nullToAbsent) {
    return OrderItemsCompanion(
      id: Value(id),
      orderId: Value(orderId),
      productId: Value(productId),
      quantity: Value(quantity),
      priceAtTimeOfOrder: Value(priceAtTimeOfOrder),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
    );
  }

  factory OrderItem.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OrderItem(
      id: serializer.fromJson<String>(json['id']),
      orderId: serializer.fromJson<String>(json['orderId']),
      productId: serializer.fromJson<String>(json['productId']),
      quantity: serializer.fromJson<int>(json['quantity']),
      priceAtTimeOfOrder: serializer.fromJson<double>(
        json['priceAtTimeOfOrder'],
      ),
      notes: serializer.fromJson<String?>(json['notes']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'orderId': serializer.toJson<String>(orderId),
      'productId': serializer.toJson<String>(productId),
      'quantity': serializer.toJson<int>(quantity),
      'priceAtTimeOfOrder': serializer.toJson<double>(priceAtTimeOfOrder),
      'notes': serializer.toJson<String?>(notes),
    };
  }

  OrderItem copyWith({
    String? id,
    String? orderId,
    String? productId,
    int? quantity,
    double? priceAtTimeOfOrder,
    Value<String?> notes = const Value.absent(),
  }) => OrderItem(
    id: id ?? this.id,
    orderId: orderId ?? this.orderId,
    productId: productId ?? this.productId,
    quantity: quantity ?? this.quantity,
    priceAtTimeOfOrder: priceAtTimeOfOrder ?? this.priceAtTimeOfOrder,
    notes: notes.present ? notes.value : this.notes,
  );
  OrderItem copyWithCompanion(OrderItemsCompanion data) {
    return OrderItem(
      id: data.id.present ? data.id.value : this.id,
      orderId: data.orderId.present ? data.orderId.value : this.orderId,
      productId: data.productId.present ? data.productId.value : this.productId,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      priceAtTimeOfOrder: data.priceAtTimeOfOrder.present
          ? data.priceAtTimeOfOrder.value
          : this.priceAtTimeOfOrder,
      notes: data.notes.present ? data.notes.value : this.notes,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OrderItem(')
          ..write('id: $id, ')
          ..write('orderId: $orderId, ')
          ..write('productId: $productId, ')
          ..write('quantity: $quantity, ')
          ..write('priceAtTimeOfOrder: $priceAtTimeOfOrder, ')
          ..write('notes: $notes')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, orderId, productId, quantity, priceAtTimeOfOrder, notes);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OrderItem &&
          other.id == this.id &&
          other.orderId == this.orderId &&
          other.productId == this.productId &&
          other.quantity == this.quantity &&
          other.priceAtTimeOfOrder == this.priceAtTimeOfOrder &&
          other.notes == this.notes);
}

class OrderItemsCompanion extends UpdateCompanion<OrderItem> {
  final Value<String> id;
  final Value<String> orderId;
  final Value<String> productId;
  final Value<int> quantity;
  final Value<double> priceAtTimeOfOrder;
  final Value<String?> notes;
  final Value<int> rowid;
  const OrderItemsCompanion({
    this.id = const Value.absent(),
    this.orderId = const Value.absent(),
    this.productId = const Value.absent(),
    this.quantity = const Value.absent(),
    this.priceAtTimeOfOrder = const Value.absent(),
    this.notes = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OrderItemsCompanion.insert({
    required String id,
    required String orderId,
    required String productId,
    required int quantity,
    required double priceAtTimeOfOrder,
    this.notes = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       orderId = Value(orderId),
       productId = Value(productId),
       quantity = Value(quantity),
       priceAtTimeOfOrder = Value(priceAtTimeOfOrder);
  static Insertable<OrderItem> custom({
    Expression<String>? id,
    Expression<String>? orderId,
    Expression<String>? productId,
    Expression<int>? quantity,
    Expression<double>? priceAtTimeOfOrder,
    Expression<String>? notes,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (orderId != null) 'order_id': orderId,
      if (productId != null) 'product_id': productId,
      if (quantity != null) 'quantity': quantity,
      if (priceAtTimeOfOrder != null)
        'price_at_time_of_order': priceAtTimeOfOrder,
      if (notes != null) 'notes': notes,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OrderItemsCompanion copyWith({
    Value<String>? id,
    Value<String>? orderId,
    Value<String>? productId,
    Value<int>? quantity,
    Value<double>? priceAtTimeOfOrder,
    Value<String?>? notes,
    Value<int>? rowid,
  }) {
    return OrderItemsCompanion(
      id: id ?? this.id,
      orderId: orderId ?? this.orderId,
      productId: productId ?? this.productId,
      quantity: quantity ?? this.quantity,
      priceAtTimeOfOrder: priceAtTimeOfOrder ?? this.priceAtTimeOfOrder,
      notes: notes ?? this.notes,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (orderId.present) {
      map['order_id'] = Variable<String>(orderId.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<String>(productId.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<int>(quantity.value);
    }
    if (priceAtTimeOfOrder.present) {
      map['price_at_time_of_order'] = Variable<double>(
        priceAtTimeOfOrder.value,
      );
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OrderItemsCompanion(')
          ..write('id: $id, ')
          ..write('orderId: $orderId, ')
          ..write('productId: $productId, ')
          ..write('quantity: $quantity, ')
          ..write('priceAtTimeOfOrder: $priceAtTimeOfOrder, ')
          ..write('notes: $notes, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PaymentsTable extends Payments with TableInfo<$PaymentsTable, Payment> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PaymentsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _orderIdMeta = const VerificationMeta(
    'orderId',
  );
  @override
  late final GeneratedColumn<String> orderId = GeneratedColumn<String>(
    'order_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES orders (id)',
    ),
  );
  static const VerificationMeta _methodMeta = const VerificationMeta('method');
  @override
  late final GeneratedColumn<String> method = GeneratedColumn<String>(
    'method',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _amountMeta = const VerificationMeta('amount');
  @override
  late final GeneratedColumn<double> amount = GeneratedColumn<double>(
    'amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _referenceMeta = const VerificationMeta(
    'reference',
  );
  @override
  late final GeneratedColumn<String> reference = GeneratedColumn<String>(
    'reference',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    orderId,
    method,
    amount,
    reference,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'payments';
  @override
  VerificationContext validateIntegrity(
    Insertable<Payment> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('order_id')) {
      context.handle(
        _orderIdMeta,
        orderId.isAcceptableOrUnknown(data['order_id']!, _orderIdMeta),
      );
    } else if (isInserting) {
      context.missing(_orderIdMeta);
    }
    if (data.containsKey('method')) {
      context.handle(
        _methodMeta,
        method.isAcceptableOrUnknown(data['method']!, _methodMeta),
      );
    } else if (isInserting) {
      context.missing(_methodMeta);
    }
    if (data.containsKey('amount')) {
      context.handle(
        _amountMeta,
        amount.isAcceptableOrUnknown(data['amount']!, _amountMeta),
      );
    } else if (isInserting) {
      context.missing(_amountMeta);
    }
    if (data.containsKey('reference')) {
      context.handle(
        _referenceMeta,
        reference.isAcceptableOrUnknown(data['reference']!, _referenceMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Payment map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Payment(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      orderId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}order_id'],
      )!,
      method: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}method'],
      )!,
      amount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}amount'],
      )!,
      reference: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reference'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $PaymentsTable createAlias(String alias) {
    return $PaymentsTable(attachedDatabase, alias);
  }
}

class Payment extends DataClass implements Insertable<Payment> {
  final String id;
  final String orderId;
  final String method;
  final double amount;
  final String? reference;
  final DateTime createdAt;
  const Payment({
    required this.id,
    required this.orderId,
    required this.method,
    required this.amount,
    this.reference,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['order_id'] = Variable<String>(orderId);
    map['method'] = Variable<String>(method);
    map['amount'] = Variable<double>(amount);
    if (!nullToAbsent || reference != null) {
      map['reference'] = Variable<String>(reference);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  PaymentsCompanion toCompanion(bool nullToAbsent) {
    return PaymentsCompanion(
      id: Value(id),
      orderId: Value(orderId),
      method: Value(method),
      amount: Value(amount),
      reference: reference == null && nullToAbsent
          ? const Value.absent()
          : Value(reference),
      createdAt: Value(createdAt),
    );
  }

  factory Payment.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Payment(
      id: serializer.fromJson<String>(json['id']),
      orderId: serializer.fromJson<String>(json['orderId']),
      method: serializer.fromJson<String>(json['method']),
      amount: serializer.fromJson<double>(json['amount']),
      reference: serializer.fromJson<String?>(json['reference']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'orderId': serializer.toJson<String>(orderId),
      'method': serializer.toJson<String>(method),
      'amount': serializer.toJson<double>(amount),
      'reference': serializer.toJson<String?>(reference),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  Payment copyWith({
    String? id,
    String? orderId,
    String? method,
    double? amount,
    Value<String?> reference = const Value.absent(),
    DateTime? createdAt,
  }) => Payment(
    id: id ?? this.id,
    orderId: orderId ?? this.orderId,
    method: method ?? this.method,
    amount: amount ?? this.amount,
    reference: reference.present ? reference.value : this.reference,
    createdAt: createdAt ?? this.createdAt,
  );
  Payment copyWithCompanion(PaymentsCompanion data) {
    return Payment(
      id: data.id.present ? data.id.value : this.id,
      orderId: data.orderId.present ? data.orderId.value : this.orderId,
      method: data.method.present ? data.method.value : this.method,
      amount: data.amount.present ? data.amount.value : this.amount,
      reference: data.reference.present ? data.reference.value : this.reference,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Payment(')
          ..write('id: $id, ')
          ..write('orderId: $orderId, ')
          ..write('method: $method, ')
          ..write('amount: $amount, ')
          ..write('reference: $reference, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, orderId, method, amount, reference, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Payment &&
          other.id == this.id &&
          other.orderId == this.orderId &&
          other.method == this.method &&
          other.amount == this.amount &&
          other.reference == this.reference &&
          other.createdAt == this.createdAt);
}

class PaymentsCompanion extends UpdateCompanion<Payment> {
  final Value<String> id;
  final Value<String> orderId;
  final Value<String> method;
  final Value<double> amount;
  final Value<String?> reference;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const PaymentsCompanion({
    this.id = const Value.absent(),
    this.orderId = const Value.absent(),
    this.method = const Value.absent(),
    this.amount = const Value.absent(),
    this.reference = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PaymentsCompanion.insert({
    required String id,
    required String orderId,
    required String method,
    required double amount,
    this.reference = const Value.absent(),
    required DateTime createdAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       orderId = Value(orderId),
       method = Value(method),
       amount = Value(amount),
       createdAt = Value(createdAt);
  static Insertable<Payment> custom({
    Expression<String>? id,
    Expression<String>? orderId,
    Expression<String>? method,
    Expression<double>? amount,
    Expression<String>? reference,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (orderId != null) 'order_id': orderId,
      if (method != null) 'method': method,
      if (amount != null) 'amount': amount,
      if (reference != null) 'reference': reference,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PaymentsCompanion copyWith({
    Value<String>? id,
    Value<String>? orderId,
    Value<String>? method,
    Value<double>? amount,
    Value<String?>? reference,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return PaymentsCompanion(
      id: id ?? this.id,
      orderId: orderId ?? this.orderId,
      method: method ?? this.method,
      amount: amount ?? this.amount,
      reference: reference ?? this.reference,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (orderId.present) {
      map['order_id'] = Variable<String>(orderId.value);
    }
    if (method.present) {
      map['method'] = Variable<String>(method.value);
    }
    if (amount.present) {
      map['amount'] = Variable<double>(amount.value);
    }
    if (reference.present) {
      map['reference'] = Variable<String>(reference.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PaymentsCompanion(')
          ..write('id: $id, ')
          ..write('orderId: $orderId, ')
          ..write('method: $method, ')
          ..write('amount: $amount, ')
          ..write('reference: $reference, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SeatingTablesTable extends SeatingTables
    with TableInfo<$SeatingTablesTable, SeatingTable> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SeatingTablesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('FREE'),
  );
  static const VerificationMeta _floorMeta = const VerificationMeta('floor');
  @override
  late final GeneratedColumn<String> floor = GeneratedColumn<String>(
    'floor',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('Main'),
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [id, name, status, floor, updatedAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'seating_tables';
  @override
  VerificationContext validateIntegrity(
    Insertable<SeatingTable> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('floor')) {
      context.handle(
        _floorMeta,
        floor.isAcceptableOrUnknown(data['floor']!, _floorMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SeatingTable map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SeatingTable(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      floor: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}floor'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      ),
    );
  }

  @override
  $SeatingTablesTable createAlias(String alias) {
    return $SeatingTablesTable(attachedDatabase, alias);
  }
}

class SeatingTable extends DataClass implements Insertable<SeatingTable> {
  final String id;
  final String name;
  final String status;
  final String floor;
  final DateTime? updatedAt;
  const SeatingTable({
    required this.id,
    required this.name,
    required this.status,
    required this.floor,
    this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    map['status'] = Variable<String>(status);
    map['floor'] = Variable<String>(floor);
    if (!nullToAbsent || updatedAt != null) {
      map['updated_at'] = Variable<DateTime>(updatedAt);
    }
    return map;
  }

  SeatingTablesCompanion toCompanion(bool nullToAbsent) {
    return SeatingTablesCompanion(
      id: Value(id),
      name: Value(name),
      status: Value(status),
      floor: Value(floor),
      updatedAt: updatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAt),
    );
  }

  factory SeatingTable.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SeatingTable(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      status: serializer.fromJson<String>(json['status']),
      floor: serializer.fromJson<String>(json['floor']),
      updatedAt: serializer.fromJson<DateTime?>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'status': serializer.toJson<String>(status),
      'floor': serializer.toJson<String>(floor),
      'updatedAt': serializer.toJson<DateTime?>(updatedAt),
    };
  }

  SeatingTable copyWith({
    String? id,
    String? name,
    String? status,
    String? floor,
    Value<DateTime?> updatedAt = const Value.absent(),
  }) => SeatingTable(
    id: id ?? this.id,
    name: name ?? this.name,
    status: status ?? this.status,
    floor: floor ?? this.floor,
    updatedAt: updatedAt.present ? updatedAt.value : this.updatedAt,
  );
  SeatingTable copyWithCompanion(SeatingTablesCompanion data) {
    return SeatingTable(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      status: data.status.present ? data.status.value : this.status,
      floor: data.floor.present ? data.floor.value : this.floor,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SeatingTable(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('floor: $floor, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name, status, floor, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SeatingTable &&
          other.id == this.id &&
          other.name == this.name &&
          other.status == this.status &&
          other.floor == this.floor &&
          other.updatedAt == this.updatedAt);
}

class SeatingTablesCompanion extends UpdateCompanion<SeatingTable> {
  final Value<String> id;
  final Value<String> name;
  final Value<String> status;
  final Value<String> floor;
  final Value<DateTime?> updatedAt;
  final Value<int> rowid;
  const SeatingTablesCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.floor = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SeatingTablesCompanion.insert({
    required String id,
    required String name,
    this.status = const Value.absent(),
    this.floor = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name);
  static Insertable<SeatingTable> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? status,
    Expression<String>? floor,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (status != null) 'status': status,
      if (floor != null) 'floor': floor,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SeatingTablesCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String>? status,
    Value<String>? floor,
    Value<DateTime?>? updatedAt,
    Value<int>? rowid,
  }) {
    return SeatingTablesCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      status: status ?? this.status,
      floor: floor ?? this.floor,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (floor.present) {
      map['floor'] = Variable<String>(floor.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SeatingTablesCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('floor: $floor, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $CategoriesTable categories = $CategoriesTable(this);
  late final $ProductsTable products = $ProductsTable(this);
  late final $OrdersTable orders = $OrdersTable(this);
  late final $OrderItemsTable orderItems = $OrderItemsTable(this);
  late final $PaymentsTable payments = $PaymentsTable(this);
  late final $SeatingTablesTable seatingTables = $SeatingTablesTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    categories,
    products,
    orders,
    orderItems,
    payments,
    seatingTables,
  ];
}

typedef $$CategoriesTableCreateCompanionBuilder =
    CategoriesCompanion Function({
      required String id,
      required String name,
      Value<String?> colorHex,
      Value<int> sortOrder,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });
typedef $$CategoriesTableUpdateCompanionBuilder =
    CategoriesCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String?> colorHex,
      Value<int> sortOrder,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });

final class $$CategoriesTableReferences
    extends BaseReferences<_$AppDatabase, $CategoriesTable, Category> {
  $$CategoriesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$ProductsTable, List<Product>> _productsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.products,
    aliasName: $_aliasNameGenerator(db.categories.id, db.products.categoryId),
  );

  $$ProductsTableProcessedTableManager get productsRefs {
    final manager = $$ProductsTableTableManager(
      $_db,
      $_db.products,
    ).filter((f) => f.categoryId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_productsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$CategoriesTableFilterComposer
    extends Composer<_$AppDatabase, $CategoriesTable> {
  $$CategoriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get colorHex => $composableBuilder(
    column: $table.colorHex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> productsRefs(
    Expression<bool> Function($$ProductsTableFilterComposer f) f,
  ) {
    final $$ProductsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.categoryId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableFilterComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CategoriesTableOrderingComposer
    extends Composer<_$AppDatabase, $CategoriesTable> {
  $$CategoriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get colorHex => $composableBuilder(
    column: $table.colorHex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$CategoriesTableAnnotationComposer
    extends Composer<_$AppDatabase, $CategoriesTable> {
  $$CategoriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get colorHex =>
      $composableBuilder(column: $table.colorHex, builder: (column) => column);

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> productsRefs<T extends Object>(
    Expression<T> Function($$ProductsTableAnnotationComposer a) f,
  ) {
    final $$ProductsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.categoryId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableAnnotationComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CategoriesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CategoriesTable,
          Category,
          $$CategoriesTableFilterComposer,
          $$CategoriesTableOrderingComposer,
          $$CategoriesTableAnnotationComposer,
          $$CategoriesTableCreateCompanionBuilder,
          $$CategoriesTableUpdateCompanionBuilder,
          (Category, $$CategoriesTableReferences),
          Category,
          PrefetchHooks Function({bool productsRefs})
        > {
  $$CategoriesTableTableManager(_$AppDatabase db, $CategoriesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CategoriesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CategoriesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CategoriesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> colorHex = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CategoriesCompanion(
                id: id,
                name: name,
                colorHex: colorHex,
                sortOrder: sortOrder,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                Value<String?> colorHex = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CategoriesCompanion.insert(
                id: id,
                name: name,
                colorHex: colorHex,
                sortOrder: sortOrder,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$CategoriesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({productsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (productsRefs) db.products],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (productsRefs)
                    await $_getPrefetchedData<
                      Category,
                      $CategoriesTable,
                      Product
                    >(
                      currentTable: table,
                      referencedTable: $$CategoriesTableReferences
                          ._productsRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$CategoriesTableReferences(
                            db,
                            table,
                            p0,
                          ).productsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.categoryId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$CategoriesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CategoriesTable,
      Category,
      $$CategoriesTableFilterComposer,
      $$CategoriesTableOrderingComposer,
      $$CategoriesTableAnnotationComposer,
      $$CategoriesTableCreateCompanionBuilder,
      $$CategoriesTableUpdateCompanionBuilder,
      (Category, $$CategoriesTableReferences),
      Category,
      PrefetchHooks Function({bool productsRefs})
    >;
typedef $$ProductsTableCreateCompanionBuilder =
    ProductsCompanion Function({
      required String id,
      required String categoryId,
      required String name,
      required double price,
      Value<bool> isAvailable,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });
typedef $$ProductsTableUpdateCompanionBuilder =
    ProductsCompanion Function({
      Value<String> id,
      Value<String> categoryId,
      Value<String> name,
      Value<double> price,
      Value<bool> isAvailable,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });

final class $$ProductsTableReferences
    extends BaseReferences<_$AppDatabase, $ProductsTable, Product> {
  $$ProductsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $CategoriesTable _categoryIdTable(_$AppDatabase db) =>
      db.categories.createAlias(
        $_aliasNameGenerator(db.products.categoryId, db.categories.id),
      );

  $$CategoriesTableProcessedTableManager get categoryId {
    final $_column = $_itemColumn<String>('category_id')!;

    final manager = $$CategoriesTableTableManager(
      $_db,
      $_db.categories,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_categoryIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$OrderItemsTable, List<OrderItem>>
  _orderItemsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.orderItems,
    aliasName: $_aliasNameGenerator(db.products.id, db.orderItems.productId),
  );

  $$OrderItemsTableProcessedTableManager get orderItemsRefs {
    final manager = $$OrderItemsTableTableManager(
      $_db,
      $_db.orderItems,
    ).filter((f) => f.productId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_orderItemsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ProductsTableFilterComposer
    extends Composer<_$AppDatabase, $ProductsTable> {
  $$ProductsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isAvailable => $composableBuilder(
    column: $table.isAvailable,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$CategoriesTableFilterComposer get categoryId {
    final $$CategoriesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.categoryId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableFilterComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> orderItemsRefs(
    Expression<bool> Function($$OrderItemsTableFilterComposer f) f,
  ) {
    final $$OrderItemsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.orderItems,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemsTableFilterComposer(
            $db: $db,
            $table: $db.orderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ProductsTableOrderingComposer
    extends Composer<_$AppDatabase, $ProductsTable> {
  $$ProductsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isAvailable => $composableBuilder(
    column: $table.isAvailable,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$CategoriesTableOrderingComposer get categoryId {
    final $$CategoriesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.categoryId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableOrderingComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ProductsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ProductsTable> {
  $$ProductsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<bool> get isAvailable => $composableBuilder(
    column: $table.isAvailable,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$CategoriesTableAnnotationComposer get categoryId {
    final $$CategoriesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.categoryId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableAnnotationComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> orderItemsRefs<T extends Object>(
    Expression<T> Function($$OrderItemsTableAnnotationComposer a) f,
  ) {
    final $$OrderItemsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.orderItems,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemsTableAnnotationComposer(
            $db: $db,
            $table: $db.orderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ProductsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ProductsTable,
          Product,
          $$ProductsTableFilterComposer,
          $$ProductsTableOrderingComposer,
          $$ProductsTableAnnotationComposer,
          $$ProductsTableCreateCompanionBuilder,
          $$ProductsTableUpdateCompanionBuilder,
          (Product, $$ProductsTableReferences),
          Product,
          PrefetchHooks Function({bool categoryId, bool orderItemsRefs})
        > {
  $$ProductsTableTableManager(_$AppDatabase db, $ProductsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ProductsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ProductsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ProductsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> categoryId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<double> price = const Value.absent(),
                Value<bool> isAvailable = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ProductsCompanion(
                id: id,
                categoryId: categoryId,
                name: name,
                price: price,
                isAvailable: isAvailable,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String categoryId,
                required String name,
                required double price,
                Value<bool> isAvailable = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ProductsCompanion.insert(
                id: id,
                categoryId: categoryId,
                name: name,
                price: price,
                isAvailable: isAvailable,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ProductsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({categoryId = false, orderItemsRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [if (orderItemsRefs) db.orderItems],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (categoryId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.categoryId,
                                    referencedTable: $$ProductsTableReferences
                                        ._categoryIdTable(db),
                                    referencedColumn: $$ProductsTableReferences
                                        ._categoryIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (orderItemsRefs)
                        await $_getPrefetchedData<
                          Product,
                          $ProductsTable,
                          OrderItem
                        >(
                          currentTable: table,
                          referencedTable: $$ProductsTableReferences
                              ._orderItemsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductsTableReferences(
                                db,
                                table,
                                p0,
                              ).orderItemsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.productId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ProductsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ProductsTable,
      Product,
      $$ProductsTableFilterComposer,
      $$ProductsTableOrderingComposer,
      $$ProductsTableAnnotationComposer,
      $$ProductsTableCreateCompanionBuilder,
      $$ProductsTableUpdateCompanionBuilder,
      (Product, $$ProductsTableReferences),
      Product,
      PrefetchHooks Function({bool categoryId, bool orderItemsRefs})
    >;
typedef $$OrdersTableCreateCompanionBuilder =
    OrdersCompanion Function({
      required String id,
      required String receiptNumber,
      required String userId,
      Value<String?> tableId,
      required double totalAmount,
      required String status,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<bool> isSynced,
      Value<int> rowid,
    });
typedef $$OrdersTableUpdateCompanionBuilder =
    OrdersCompanion Function({
      Value<String> id,
      Value<String> receiptNumber,
      Value<String> userId,
      Value<String?> tableId,
      Value<double> totalAmount,
      Value<String> status,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<bool> isSynced,
      Value<int> rowid,
    });

final class $$OrdersTableReferences
    extends BaseReferences<_$AppDatabase, $OrdersTable, Order> {
  $$OrdersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$OrderItemsTable, List<OrderItem>>
  _orderItemsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.orderItems,
    aliasName: $_aliasNameGenerator(db.orders.id, db.orderItems.orderId),
  );

  $$OrderItemsTableProcessedTableManager get orderItemsRefs {
    final manager = $$OrderItemsTableTableManager(
      $_db,
      $_db.orderItems,
    ).filter((f) => f.orderId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_orderItemsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$PaymentsTable, List<Payment>> _paymentsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.payments,
    aliasName: $_aliasNameGenerator(db.orders.id, db.payments.orderId),
  );

  $$PaymentsTableProcessedTableManager get paymentsRefs {
    final manager = $$PaymentsTableTableManager(
      $_db,
      $_db.payments,
    ).filter((f) => f.orderId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_paymentsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$OrdersTableFilterComposer
    extends Composer<_$AppDatabase, $OrdersTable> {
  $$OrdersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get receiptNumber => $composableBuilder(
    column: $table.receiptNumber,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get tableId => $composableBuilder(
    column: $table.tableId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> orderItemsRefs(
    Expression<bool> Function($$OrderItemsTableFilterComposer f) f,
  ) {
    final $$OrderItemsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.orderItems,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemsTableFilterComposer(
            $db: $db,
            $table: $db.orderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> paymentsRefs(
    Expression<bool> Function($$PaymentsTableFilterComposer f) f,
  ) {
    final $$PaymentsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.payments,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PaymentsTableFilterComposer(
            $db: $db,
            $table: $db.payments,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$OrdersTableOrderingComposer
    extends Composer<_$AppDatabase, $OrdersTable> {
  $$OrdersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get receiptNumber => $composableBuilder(
    column: $table.receiptNumber,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get tableId => $composableBuilder(
    column: $table.tableId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$OrdersTableAnnotationComposer
    extends Composer<_$AppDatabase, $OrdersTable> {
  $$OrdersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get receiptNumber => $composableBuilder(
    column: $table.receiptNumber,
    builder: (column) => column,
  );

  GeneratedColumn<String> get userId =>
      $composableBuilder(column: $table.userId, builder: (column) => column);

  GeneratedColumn<String> get tableId =>
      $composableBuilder(column: $table.tableId, builder: (column) => column);

  GeneratedColumn<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  Expression<T> orderItemsRefs<T extends Object>(
    Expression<T> Function($$OrderItemsTableAnnotationComposer a) f,
  ) {
    final $$OrderItemsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.orderItems,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemsTableAnnotationComposer(
            $db: $db,
            $table: $db.orderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> paymentsRefs<T extends Object>(
    Expression<T> Function($$PaymentsTableAnnotationComposer a) f,
  ) {
    final $$PaymentsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.payments,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PaymentsTableAnnotationComposer(
            $db: $db,
            $table: $db.payments,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$OrdersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OrdersTable,
          Order,
          $$OrdersTableFilterComposer,
          $$OrdersTableOrderingComposer,
          $$OrdersTableAnnotationComposer,
          $$OrdersTableCreateCompanionBuilder,
          $$OrdersTableUpdateCompanionBuilder,
          (Order, $$OrdersTableReferences),
          Order,
          PrefetchHooks Function({bool orderItemsRefs, bool paymentsRefs})
        > {
  $$OrdersTableTableManager(_$AppDatabase db, $OrdersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OrdersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OrdersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OrdersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> receiptNumber = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String?> tableId = const Value.absent(),
                Value<double> totalAmount = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<bool> isSynced = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OrdersCompanion(
                id: id,
                receiptNumber: receiptNumber,
                userId: userId,
                tableId: tableId,
                totalAmount: totalAmount,
                status: status,
                createdAt: createdAt,
                updatedAt: updatedAt,
                isSynced: isSynced,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String receiptNumber,
                required String userId,
                Value<String?> tableId = const Value.absent(),
                required double totalAmount,
                required String status,
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<bool> isSynced = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OrdersCompanion.insert(
                id: id,
                receiptNumber: receiptNumber,
                userId: userId,
                tableId: tableId,
                totalAmount: totalAmount,
                status: status,
                createdAt: createdAt,
                updatedAt: updatedAt,
                isSynced: isSynced,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$OrdersTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback:
              ({orderItemsRefs = false, paymentsRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (orderItemsRefs) db.orderItems,
                    if (paymentsRefs) db.payments,
                  ],
                  addJoins: null,
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (orderItemsRefs)
                        await $_getPrefetchedData<
                          Order,
                          $OrdersTable,
                          OrderItem
                        >(
                          currentTable: table,
                          referencedTable: $$OrdersTableReferences
                              ._orderItemsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$OrdersTableReferences(
                                db,
                                table,
                                p0,
                              ).orderItemsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.orderId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (paymentsRefs)
                        await $_getPrefetchedData<Order, $OrdersTable, Payment>(
                          currentTable: table,
                          referencedTable: $$OrdersTableReferences
                              ._paymentsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$OrdersTableReferences(
                                db,
                                table,
                                p0,
                              ).paymentsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.orderId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$OrdersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OrdersTable,
      Order,
      $$OrdersTableFilterComposer,
      $$OrdersTableOrderingComposer,
      $$OrdersTableAnnotationComposer,
      $$OrdersTableCreateCompanionBuilder,
      $$OrdersTableUpdateCompanionBuilder,
      (Order, $$OrdersTableReferences),
      Order,
      PrefetchHooks Function({bool orderItemsRefs, bool paymentsRefs})
    >;
typedef $$OrderItemsTableCreateCompanionBuilder =
    OrderItemsCompanion Function({
      required String id,
      required String orderId,
      required String productId,
      required int quantity,
      required double priceAtTimeOfOrder,
      Value<String?> notes,
      Value<int> rowid,
    });
typedef $$OrderItemsTableUpdateCompanionBuilder =
    OrderItemsCompanion Function({
      Value<String> id,
      Value<String> orderId,
      Value<String> productId,
      Value<int> quantity,
      Value<double> priceAtTimeOfOrder,
      Value<String?> notes,
      Value<int> rowid,
    });

final class $$OrderItemsTableReferences
    extends BaseReferences<_$AppDatabase, $OrderItemsTable, OrderItem> {
  $$OrderItemsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $OrdersTable _orderIdTable(_$AppDatabase db) => db.orders.createAlias(
    $_aliasNameGenerator(db.orderItems.orderId, db.orders.id),
  );

  $$OrdersTableProcessedTableManager get orderId {
    final $_column = $_itemColumn<String>('order_id')!;

    final manager = $$OrdersTableTableManager(
      $_db,
      $_db.orders,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orderIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ProductsTable _productIdTable(_$AppDatabase db) =>
      db.products.createAlias(
        $_aliasNameGenerator(db.orderItems.productId, db.products.id),
      );

  $$ProductsTableProcessedTableManager get productId {
    final $_column = $_itemColumn<String>('product_id')!;

    final manager = $$ProductsTableTableManager(
      $_db,
      $_db.products,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$OrderItemsTableFilterComposer
    extends Composer<_$AppDatabase, $OrderItemsTable> {
  $$OrderItemsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get priceAtTimeOfOrder => $composableBuilder(
    column: $table.priceAtTimeOfOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  $$OrdersTableFilterComposer get orderId {
    final $$OrdersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.orders,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrdersTableFilterComposer(
            $db: $db,
            $table: $db.orders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductsTableFilterComposer get productId {
    final $$ProductsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableFilterComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OrderItemsTableOrderingComposer
    extends Composer<_$AppDatabase, $OrderItemsTable> {
  $$OrderItemsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get priceAtTimeOfOrder => $composableBuilder(
    column: $table.priceAtTimeOfOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  $$OrdersTableOrderingComposer get orderId {
    final $$OrdersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.orders,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrdersTableOrderingComposer(
            $db: $db,
            $table: $db.orders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductsTableOrderingComposer get productId {
    final $$ProductsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableOrderingComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OrderItemsTableAnnotationComposer
    extends Composer<_$AppDatabase, $OrderItemsTable> {
  $$OrderItemsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<double> get priceAtTimeOfOrder => $composableBuilder(
    column: $table.priceAtTimeOfOrder,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  $$OrdersTableAnnotationComposer get orderId {
    final $$OrdersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.orders,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrdersTableAnnotationComposer(
            $db: $db,
            $table: $db.orders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductsTableAnnotationComposer get productId {
    final $$ProductsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableAnnotationComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OrderItemsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OrderItemsTable,
          OrderItem,
          $$OrderItemsTableFilterComposer,
          $$OrderItemsTableOrderingComposer,
          $$OrderItemsTableAnnotationComposer,
          $$OrderItemsTableCreateCompanionBuilder,
          $$OrderItemsTableUpdateCompanionBuilder,
          (OrderItem, $$OrderItemsTableReferences),
          OrderItem,
          PrefetchHooks Function({bool orderId, bool productId})
        > {
  $$OrderItemsTableTableManager(_$AppDatabase db, $OrderItemsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OrderItemsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OrderItemsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OrderItemsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> orderId = const Value.absent(),
                Value<String> productId = const Value.absent(),
                Value<int> quantity = const Value.absent(),
                Value<double> priceAtTimeOfOrder = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OrderItemsCompanion(
                id: id,
                orderId: orderId,
                productId: productId,
                quantity: quantity,
                priceAtTimeOfOrder: priceAtTimeOfOrder,
                notes: notes,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String orderId,
                required String productId,
                required int quantity,
                required double priceAtTimeOfOrder,
                Value<String?> notes = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OrderItemsCompanion.insert(
                id: id,
                orderId: orderId,
                productId: productId,
                quantity: quantity,
                priceAtTimeOfOrder: priceAtTimeOfOrder,
                notes: notes,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$OrderItemsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({orderId = false, productId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (orderId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.orderId,
                                referencedTable: $$OrderItemsTableReferences
                                    ._orderIdTable(db),
                                referencedColumn: $$OrderItemsTableReferences
                                    ._orderIdTable(db)
                                    .id,
                              )
                              as T;
                    }
                    if (productId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.productId,
                                referencedTable: $$OrderItemsTableReferences
                                    ._productIdTable(db),
                                referencedColumn: $$OrderItemsTableReferences
                                    ._productIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$OrderItemsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OrderItemsTable,
      OrderItem,
      $$OrderItemsTableFilterComposer,
      $$OrderItemsTableOrderingComposer,
      $$OrderItemsTableAnnotationComposer,
      $$OrderItemsTableCreateCompanionBuilder,
      $$OrderItemsTableUpdateCompanionBuilder,
      (OrderItem, $$OrderItemsTableReferences),
      OrderItem,
      PrefetchHooks Function({bool orderId, bool productId})
    >;
typedef $$PaymentsTableCreateCompanionBuilder =
    PaymentsCompanion Function({
      required String id,
      required String orderId,
      required String method,
      required double amount,
      Value<String?> reference,
      required DateTime createdAt,
      Value<int> rowid,
    });
typedef $$PaymentsTableUpdateCompanionBuilder =
    PaymentsCompanion Function({
      Value<String> id,
      Value<String> orderId,
      Value<String> method,
      Value<double> amount,
      Value<String?> reference,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$PaymentsTableReferences
    extends BaseReferences<_$AppDatabase, $PaymentsTable, Payment> {
  $$PaymentsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $OrdersTable _orderIdTable(_$AppDatabase db) => db.orders.createAlias(
    $_aliasNameGenerator(db.payments.orderId, db.orders.id),
  );

  $$OrdersTableProcessedTableManager get orderId {
    final $_column = $_itemColumn<String>('order_id')!;

    final manager = $$OrdersTableTableManager(
      $_db,
      $_db.orders,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orderIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$PaymentsTableFilterComposer
    extends Composer<_$AppDatabase, $PaymentsTable> {
  $$PaymentsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get method => $composableBuilder(
    column: $table.method,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reference => $composableBuilder(
    column: $table.reference,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$OrdersTableFilterComposer get orderId {
    final $$OrdersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.orders,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrdersTableFilterComposer(
            $db: $db,
            $table: $db.orders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PaymentsTableOrderingComposer
    extends Composer<_$AppDatabase, $PaymentsTable> {
  $$PaymentsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get method => $composableBuilder(
    column: $table.method,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reference => $composableBuilder(
    column: $table.reference,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$OrdersTableOrderingComposer get orderId {
    final $$OrdersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.orders,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrdersTableOrderingComposer(
            $db: $db,
            $table: $db.orders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PaymentsTableAnnotationComposer
    extends Composer<_$AppDatabase, $PaymentsTable> {
  $$PaymentsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get method =>
      $composableBuilder(column: $table.method, builder: (column) => column);

  GeneratedColumn<double> get amount =>
      $composableBuilder(column: $table.amount, builder: (column) => column);

  GeneratedColumn<String> get reference =>
      $composableBuilder(column: $table.reference, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$OrdersTableAnnotationComposer get orderId {
    final $$OrdersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.orders,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrdersTableAnnotationComposer(
            $db: $db,
            $table: $db.orders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PaymentsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PaymentsTable,
          Payment,
          $$PaymentsTableFilterComposer,
          $$PaymentsTableOrderingComposer,
          $$PaymentsTableAnnotationComposer,
          $$PaymentsTableCreateCompanionBuilder,
          $$PaymentsTableUpdateCompanionBuilder,
          (Payment, $$PaymentsTableReferences),
          Payment,
          PrefetchHooks Function({bool orderId})
        > {
  $$PaymentsTableTableManager(_$AppDatabase db, $PaymentsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PaymentsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PaymentsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PaymentsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> orderId = const Value.absent(),
                Value<String> method = const Value.absent(),
                Value<double> amount = const Value.absent(),
                Value<String?> reference = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PaymentsCompanion(
                id: id,
                orderId: orderId,
                method: method,
                amount: amount,
                reference: reference,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String orderId,
                required String method,
                required double amount,
                Value<String?> reference = const Value.absent(),
                required DateTime createdAt,
                Value<int> rowid = const Value.absent(),
              }) => PaymentsCompanion.insert(
                id: id,
                orderId: orderId,
                method: method,
                amount: amount,
                reference: reference,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$PaymentsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({orderId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (orderId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.orderId,
                                referencedTable: $$PaymentsTableReferences
                                    ._orderIdTable(db),
                                referencedColumn: $$PaymentsTableReferences
                                    ._orderIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$PaymentsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PaymentsTable,
      Payment,
      $$PaymentsTableFilterComposer,
      $$PaymentsTableOrderingComposer,
      $$PaymentsTableAnnotationComposer,
      $$PaymentsTableCreateCompanionBuilder,
      $$PaymentsTableUpdateCompanionBuilder,
      (Payment, $$PaymentsTableReferences),
      Payment,
      PrefetchHooks Function({bool orderId})
    >;
typedef $$SeatingTablesTableCreateCompanionBuilder =
    SeatingTablesCompanion Function({
      required String id,
      required String name,
      Value<String> status,
      Value<String> floor,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });
typedef $$SeatingTablesTableUpdateCompanionBuilder =
    SeatingTablesCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String> status,
      Value<String> floor,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });

class $$SeatingTablesTableFilterComposer
    extends Composer<_$AppDatabase, $SeatingTablesTable> {
  $$SeatingTablesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get floor => $composableBuilder(
    column: $table.floor,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SeatingTablesTableOrderingComposer
    extends Composer<_$AppDatabase, $SeatingTablesTable> {
  $$SeatingTablesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get floor => $composableBuilder(
    column: $table.floor,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SeatingTablesTableAnnotationComposer
    extends Composer<_$AppDatabase, $SeatingTablesTable> {
  $$SeatingTablesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get floor =>
      $composableBuilder(column: $table.floor, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$SeatingTablesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SeatingTablesTable,
          SeatingTable,
          $$SeatingTablesTableFilterComposer,
          $$SeatingTablesTableOrderingComposer,
          $$SeatingTablesTableAnnotationComposer,
          $$SeatingTablesTableCreateCompanionBuilder,
          $$SeatingTablesTableUpdateCompanionBuilder,
          (
            SeatingTable,
            BaseReferences<_$AppDatabase, $SeatingTablesTable, SeatingTable>,
          ),
          SeatingTable,
          PrefetchHooks Function()
        > {
  $$SeatingTablesTableTableManager(_$AppDatabase db, $SeatingTablesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SeatingTablesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SeatingTablesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SeatingTablesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String> floor = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SeatingTablesCompanion(
                id: id,
                name: name,
                status: status,
                floor: floor,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                Value<String> status = const Value.absent(),
                Value<String> floor = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SeatingTablesCompanion.insert(
                id: id,
                name: name,
                status: status,
                floor: floor,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SeatingTablesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SeatingTablesTable,
      SeatingTable,
      $$SeatingTablesTableFilterComposer,
      $$SeatingTablesTableOrderingComposer,
      $$SeatingTablesTableAnnotationComposer,
      $$SeatingTablesTableCreateCompanionBuilder,
      $$SeatingTablesTableUpdateCompanionBuilder,
      (
        SeatingTable,
        BaseReferences<_$AppDatabase, $SeatingTablesTable, SeatingTable>,
      ),
      SeatingTable,
      PrefetchHooks Function()
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$CategoriesTableTableManager get categories =>
      $$CategoriesTableTableManager(_db, _db.categories);
  $$ProductsTableTableManager get products =>
      $$ProductsTableTableManager(_db, _db.products);
  $$OrdersTableTableManager get orders =>
      $$OrdersTableTableManager(_db, _db.orders);
  $$OrderItemsTableTableManager get orderItems =>
      $$OrderItemsTableTableManager(_db, _db.orderItems);
  $$PaymentsTableTableManager get payments =>
      $$PaymentsTableTableManager(_db, _db.payments);
  $$SeatingTablesTableTableManager get seatingTables =>
      $$SeatingTablesTableTableManager(_db, _db.seatingTables);
}

================
File: qristal_mobile/lib/main.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'core/theme/app_theme.dart';
import 'features/auth/screens/login_screen.dart';
import 'features/tables/screens/floor_plan_screen.dart';
import 'services/websocket_service.dart';

void main() {
  runApp(const ProviderScope(child: QristalApp()));
}

class QristalApp extends ConsumerWidget { // Change to ConsumerWidget
  const QristalApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    ref.read(webSocketProvider); 
    return MaterialApp(
      title: 'Qristal POS',
      debugShowCheckedModeBanner: false,
      theme: AppTheme.darkTheme,
      home: const LoginScreen(),
      routes: {'/home': (context) => const FloorPlanScreen()},
    );
  }
}

================
File: qristal_mobile/lib/database/database.dart
================
import 'dart:io';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import 'package:sqlite3/sqlite3.dart';
import 'package:sqlite3_flutter_libs/sqlite3_flutter_libs.dart';

part 'database.g.dart';

// 1. Categories Table
class Categories extends Table {
  TextColumn get id => text()();
  TextColumn get name => text()();
  TextColumn get colorHex => text().nullable()();
  // Fixed: .defaultValue -> .withDefault
  IntColumn get sortOrder => integer().withDefault(const Constant(0))();
  DateTimeColumn get updatedAt => dateTime().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

// 2. Products Table
class Products extends Table {
  TextColumn get id => text()();
  TextColumn get categoryId => text().references(Categories, #id)();
  TextColumn get name => text()();
  RealColumn get price => real()();
  BoolColumn get isAvailable => boolean().withDefault(const Constant(true))();
  DateTimeColumn get updatedAt => dateTime().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

// 3. Orders Table
class Orders extends Table {
  TextColumn get id => text()();
  TextColumn get receiptNumber => text()();
  TextColumn get userId => text()();
  TextColumn get tableId => text().nullable()();
  RealColumn get totalAmount => real()();
  TextColumn get status => text()();
  DateTimeColumn get createdAt => dateTime()();
  DateTimeColumn get updatedAt => dateTime()();

  // Local-only flag to track what needs to be uploaded
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};
}

// 4. OrderItems Table (This was missing!)
class OrderItems extends Table {
  TextColumn get id => text()();
  TextColumn get orderId => text().references(Orders, #id)();
  TextColumn get productId => text().references(Products, #id)();
  IntColumn get quantity => integer()();
  RealColumn get priceAtTimeOfOrder => real()();
  TextColumn get notes => text().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

class Payments extends Table {
  TextColumn get id => text()();
  TextColumn get orderId => text().references(Orders, #id)();
  TextColumn get method => text()(); // 'CASH', 'MOBILE_MONEY', etc.
  RealColumn get amount => real()();
  TextColumn get reference => text().nullable()(); // Trans ID
  DateTimeColumn get createdAt => dateTime()();

  @override
  Set<Column> get primaryKey => {id};
}

class SeatingTables extends Table {
  TextColumn get id => text()();
  TextColumn get name => text()();
  TextColumn get status => text().withDefault(const Constant('FREE'))();
  TextColumn get floor => text().withDefault(const Constant('Main'))();
  DateTimeColumn get updatedAt => dateTime().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

// Database Registry
@DriftDatabase(tables: [Categories, Products, Orders, OrderItems, Payments, SeatingTables])
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 3; // Bump version

  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onUpgrade: (Migrator m, int from, int to) async {
        if (from < 3) {
          await m.createTable(seatingTables);
        }
      },
    );
  }


  Stream<List<Order>> watchKitchenOrders() {
    return (select(orders)
          ..where((t) => t.status.isIn(['KITCHEN', 'PREPARING']))
          ..orderBy([(t) => OrderingTerm(expression: t.createdAt)]))
        .watch();
  }

  // 2. Get Items for a specific Order (Joined with Product info)
  Future<List<TypedOrderItem>> getOrderItems(String orderId) async {
    final query = select(orderItems).join([
      innerJoin(products, products.id.equalsExp(orderItems.productId)),
    ])..where(orderItems.orderId.equals(orderId));

    final rows = await query.get();

    return rows.map((row) {
      return TypedOrderItem(
        item: row.readTable(orderItems),
        product: row.readTable(products),
      );
    }).toList();
  }

  // 3. Update Order Status
  Future<void> updateOrderStatus(String id, String newStatus) async {
    await (update(orders)..where((t) => t.id.equals(id))).write(
      OrdersCompanion(
        status: Value(newStatus),
        updatedAt: Value(DateTime.now()), // Important for Sync!
        isSynced: const Value(false), // Mark as dirty so it syncs up
      ),
    );
  }
}

// Helper class to hold joined data
class TypedOrderItem {
  final OrderItem item;
  final Product product;
  TypedOrderItem({required this.item, required this.product});
}



LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    // 1. Get the folder
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'db.sqlite'));

    // 2. FOR ANDROID: Load the native library specifically
    if (Platform.isAndroid) {
      await applyWorkaroundToOpenSqlite3OnOldAndroidVersions();

      // Optional: Explicitly tell sqlite3 where to look if the workaround fails,
      // though the line above usually fixes it.
      final cachebase = (await getTemporaryDirectory()).path;
      sqlite3.tempDirectory = cachebase;
    }

    // 3. Create the database
    return NativeDatabase.createInBackground(file);
  });
}

================
File: qristal_mobile/lib/features/auth/screens/login_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:qristal_mobile/core/theme/app_theme.dart';
import '../../sync/providers/sync_provider.dart';
import '../../tables/screens/floor_plan_screen.dart';
import '../providers/auth_provider.dart';

class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({super.key});

  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends ConsumerState<LoginScreen> {
  final TextEditingController _userController = TextEditingController();
  final TextEditingController _pinController = TextEditingController();

  // Listen to state changes
  void _listenToAuthChanges() {
    ref.listen(authControllerProvider, (previous, next) async {
      if (next.error != null) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(next.error!), backgroundColor: AppTheme.error),
        );
      }

      if (next.isAuthenticated) {
        // --- ADD THIS BLOCK ---
        // Trigger initial sync before moving to dashboard
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text("Authentication successful. Syncing data..."),
          ),
        );

        await ref.read(syncControllerProvider.notifier).performSync();
        // ----------------------

        if (context.mounted) {
          Navigator.pushReplacement(
            context,
            MaterialPageRoute(builder: (_) => const FloorPlanScreen()),
          );
        }
      }
    });
  }

  void _handleLogin() {
    final userId =
        '20e712c3-e030-4bc5-ac2b-cafd92dc055f'; // _userController.text.trim();
    final pin =
        _pinController.text.trim(); // '1234'; // _pinController.text.trim();

    if (userId.isEmpty || pin.isEmpty) return;

    ref.read(authControllerProvider.notifier).login(userId, pin);
  }

  @override
  Widget build(BuildContext context) {
    _listenToAuthChanges();
    final authState = ref.watch(authControllerProvider);

    return Scaffold(
      body: Row(
        children: [
          // LEFT SIDE: Branding / Art
          Expanded(
            flex: 2,
            child: Container(
              color: AppTheme.surface,
              child: const Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      Icons.point_of_sale,
                      size: 100,
                      color: AppTheme.qristalBlue,
                    ),
                    SizedBox(height: 20),
                    Text(
                      "Qristal POS",
                      style: TextStyle(
                        fontSize: 40,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    ),
                    Text(
                      "Enterprise Grade. Startup Ready.",
                      style: TextStyle(color: Colors.grey),
                    ),
                  ],
                ),
              ),
            ),
          ),

          // RIGHT SIDE: Login Form
          Expanded(
            flex: 3,
            child: Padding(
              padding: const EdgeInsets.all(40.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  const Text(
                    "Staff Access",
                    style: TextStyle(fontSize: 24, fontWeight: FontWeight.w600),
                  ),
                  const SizedBox(height: 30),

                  // User ID Input (Paste your seeded UUID here)
                  TextField(
                    controller: _userController,
                    decoration: const InputDecoration(
                      labelText: "Operator ID",
                      prefixIcon: Icon(Icons.badge),
                    ),
                  ),
                  const SizedBox(height: 20),

                  // PIN Input
                  TextField(
                    controller: _pinController,
                    obscureText: true,
                    keyboardType: TextInputType.number,
                    decoration: const InputDecoration(
                      labelText: "Access PIN",
                      prefixIcon: Icon(Icons.lock),
                    ),
                    onSubmitted: (_) => _handleLogin(),
                  ),
                  const SizedBox(height: 40),

                  // Login Button
                  SizedBox(
                    height: 60,
                    child: ElevatedButton(
                      onPressed: authState.isLoading ? null : _handleLogin,
                      child: authState.isLoading
                          ? const CircularProgressIndicator(color: Colors.white)
                          : const Text("UNLOCK TERMINAL"),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

================
File: qristal_mobile/windows/flutter/generated_plugin_registrant.cc
================
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"

#include <connectivity_plus/connectivity_plus_windows_plugin.h>
#include <flutter_secure_storage_windows/flutter_secure_storage_windows_plugin.h>
#include <permission_handler_windows/permission_handler_windows_plugin.h>
#include <print_bluetooth_thermal/print_bluetooth_thermal_plugin_c_api.h>
#include <sqlite3_flutter_libs/sqlite3_flutter_libs_plugin.h>

void RegisterPlugins(flutter::PluginRegistry* registry) {
  ConnectivityPlusWindowsPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("ConnectivityPlusWindowsPlugin"));
  FlutterSecureStorageWindowsPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("FlutterSecureStorageWindowsPlugin"));
  PermissionHandlerWindowsPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("PermissionHandlerWindowsPlugin"));
  PrintBluetoothThermalPluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("PrintBluetoothThermalPluginCApi"));
  Sqlite3FlutterLibsPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("Sqlite3FlutterLibsPlugin"));
}

================
File: qristal_mobile/windows/flutter/generated_plugins.cmake
================
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
  connectivity_plus
  flutter_secure_storage_windows
  permission_handler_windows
  print_bluetooth_thermal
  sqlite3_flutter_libs
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/windows plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/windows plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)

================
File: qristal_mobile/lib/features/pos/providers/cart_provider.dart
================
import 'package:drift/drift.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import '../../../core/providers/database_provider.dart';
import '../../../database/database.dart';
import '../../hardware/services/printer_service.dart';
import '../../auth/providers/auth_provider.dart';
import '../../sync/providers/sync_provider.dart';
import '../../tables/screens/floor_plan_screen.dart';
import '../models/cart_item.dart';
import '../services/order_service.dart';
import '../widgets/payment_modal.dart';

class CartNotifier extends StateNotifier<List<CartItem>> {
  final AppDatabase db;
  final String? userId;
  final String userName;
  final PrinterService printerService; // <--- ADD THIS
  final Ref ref;

  CartNotifier(
    this.db,
    this.userId,
    this.userName,
    this.printerService,
    this.ref,
  ) : super([]);

  void addToCart(Product product) {
    final existingIndex = state.indexWhere(
      (item) => item.product.id == product.id,
    );

    if (existingIndex >= 0) {
      // Item exists, increment quantity
      final existingItem = state[existingIndex];
      final updatedItem = existingItem.copyWith(
        quantity: existingItem.quantity + 1,
      );

      // Update state immutably
      state = [
        ...state.sublist(0, existingIndex),
        updatedItem,
        ...state.sublist(existingIndex + 1),
      ];
    } else {
      // Add new item
      state = [...state, CartItem(product: product)];
    }
  }

  void removeFromCart(Product product) {
    state = state.where((item) => item.product.id != product.id).toList();
  }

  void clearCart() {
    state = [];
  }

  double get totalAmount => state.fold(0, (sum, item) => sum + item.total);

  // Future<void> placeOrder() async {
  //   if (state.isEmpty || userId == null) return;

  //   final orderId = const Uuid().v4();
  //   final total = totalAmount; // using the getter
  //   final now = DateTime.now();

  //   // 1. Transaction to save Order + Items safely
  //   await db.transaction(() async {
  //     // Create Header
  //     await db
  //         .into(db.orders)
  //         .insert(
  //           OrdersCompanion(
  //             id: Value(orderId),
  //             receiptNumber: Value(
  //               orderId.substring(0, 8).toUpperCase(),
  //             ), // Simple receipt #
  //             userId: Value(userId!),
  //             totalAmount: Value(total),
  //             status: const Value('KITCHEN'), // Send straight to kitchen
  //             createdAt: Value(now),
  //             updatedAt: Value(now),
  //             isSynced: const Value(false),
  //           ),
  //         );

  //     // Create Items
  //     for (var cartItem in state) {
  //       await db
  //           .into(db.orderItems)
  //           .insert(
  //             OrderItemsCompanion(
  //               id: Value(const Uuid().v4()),
  //               orderId: Value(orderId),
  //               productId: Value(cartItem.product.id),
  //               quantity: Value(cartItem.quantity),
  //               priceAtTimeOfOrder: Value(cartItem.product.price),
  //               notes: Value(cartItem.notes),
  //             ),
  //           );
  //     }
  //   });

  //   // 2. Clear UI
  //   state = [];

  //   // 3. Trigger Background Sync immediately so Kitchen sees it
  //   ref.read(syncControllerProvider.notifier).performSync();
  // }

  Future<void> checkout(BuildContext context) async {
    if (state.isEmpty || userId == null) return;

    final total = totalAmount;

    // Show the Dialog
    showDialog(
      context: context,
      builder: (_) => PaymentModal(
        totalAmount: total,
        onConfirmed: (method, tendered, refCode) async {
          await _finalizeOrder(total, method, tendered, refCode);
        },
      ),
    );
  }

  Future<void> _finalizeOrder(
    double total,
    String method,
    double tendered,
    String? refCode,
  ) async {
    final orderId = const Uuid().v4();
    final now = DateTime.now();
    final tableId = ref.read(activeTableIdProvider);

    await db.transaction(() async {
      // 1. Order
      await db
          .into(db.orders)
          .insert(
            OrdersCompanion(
              id: Value(orderId),
              receiptNumber: Value(
                orderId.substring(0, 4).toUpperCase(),
              ), // Short code
              userId: Value(userId!),
              tableId: Value(tableId),
              totalAmount: Value(total),
              status: const Value('CLOSED'), // Closed because it is paid
              isSynced: const Value(false),
              createdAt: Value(now),
              updatedAt: Value(now),
            ),
          );
      //If a table was selected, update its status to OCCUPIED locally
      if (tableId != null) {
        await (db.update(db.seatingTables)..where((t) => t.id.equals(tableId)))
            .write(SeatingTablesCompanion(status: const Value('OCCUPIED')));
      }
      // 2. Items
      for (var cartItem in state) {
        await db
            .into(db.orderItems)
            .insert(
              OrderItemsCompanion(
                id: Value(const Uuid().v4()),
                orderId: Value(orderId),
                productId: Value(cartItem.product.id),
                quantity: Value(cartItem.quantity),
                priceAtTimeOfOrder: Value(cartItem.product.price),
              ),
            );
      }

      // 3. Payment
      await db
          .into(db.payments)
          .insert(
            PaymentsCompanion(
              id: Value(const Uuid().v4()),
              orderId: Value(orderId),
              method: Value(method),
              amount: Value(total), // We record the bill amount, not tendered
              reference: Value(refCode),
              createdAt: Value(now),
            ),
          );
    });

    // 2. Trigger Print
    try {
      await printerService.printReceipt(
        orderId: orderId,
        items: state, // The current cart items
        total: total,
        tendered: tendered,
        paymentMethod: method,
        cashierName: userName,
      );
    } catch (e) {
      if (kDebugMode) {
        print("Printing failed (Device might not be connected): $e");
      }
    }

    // 3. Clear State & Sync
    state = [];
    ref.read(syncControllerProvider.notifier).performSync();
  }
}

final cartProvider = StateNotifierProvider<CartNotifier, List<CartItem>>((ref) {
  final db = ref.watch(databaseProvider);
  final printerService = ref.watch(
    printerServiceProvider,
  ); // <--- INJECT PRINTER SERVICE
  final authState = ref.watch(authControllerProvider);

  final currentUserId = authState.userId;
  final currentUserName = authState.userId ?? 'Cashier';

  return CartNotifier(db, currentUserId, currentUserName, printerService, ref);
});
// Add a Provider for OrderService
final orderServiceProvider = Provider(
  (ref) => OrderService(ref.watch(databaseProvider)),
);
// Update the Cart Controller to handle checkout
final checkoutProvider = FutureProvider.family<void, String>((
  ref,
  userId,
) async {
  final cart = ref.read(cartProvider);
  if (cart.isEmpty) return;

  final orderService = ref.read(orderServiceProvider);

  // Place the order locally
  await orderService.placeOrder(
    cartItems: cart,
    userId: userId,
    // tableId: null for now (Takeaway)
  );

  // Clear cart UI
  ref.read(cartProvider.notifier).clearCart();
});

================
File: qristal_mobile/lib/features/pos/screens/dashboard_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/theme/app_theme.dart';
import '../../hardware/screens/printer_settings_screen.dart';
import '../../kitchen/screens/kitchen_screen.dart';
import '../../sync/providers/sync_provider.dart';
import '../../sync/providers/sync_queue_provider.dart';
import '../providers/menu_provider.dart';
import '../providers/cart_provider.dart';

class DashboardScreen extends ConsumerWidget {
  const DashboardScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Watch sync state to show loading indicator if needed

    final syncQueue = ref.watch(syncQueueProvider);
    return Scaffold(
      appBar: AppBar(
        title: const Text("Qristal POS - Cashier"),
        backgroundColor: AppTheme.surface,
        actions: [
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Row(
              children: [
                if (syncQueue.pendingOrders > 0)
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 2,
                    ),
                    decoration: BoxDecoration(
                      color: Colors.orange,
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      "${syncQueue.pendingOrders} Pending",
                      style: const TextStyle(fontWeight: FontWeight.bold),
                    ),
                  ),
                const SizedBox(width: 8),
                _buildSyncIcon(syncQueue.status),
              ],
            ),
          ),
          // Navigation to Kitchen Display System
          IconButton(
            icon: const Icon(Icons.soup_kitchen),
            tooltip: 'Kitchen Display',
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(builder: (_) => const KitchenScreen()),
              );
            },
          ),
          // Navigation to Printer Settings
          IconButton(
            icon: const Icon(Icons.print),
            tooltip: 'Printer Settings',
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (_) => const PrinterSettingsScreen(),
                ),
              );
            },
          ),

          const SizedBox(width: 20),
        ],
      ),
      body: Row(
        children: [
          // 1. LEFT COLUMN: Categories
          Expanded(
            flex: 2,
            child: Container(
              color: AppTheme.surface,
              child: const CategoryList(),
            ),
          ),

          // 2. MIDDLE COLUMN: Products Grid
          Expanded(
            flex: 5,
            child: Container(
              color: AppTheme.background,
              padding: const EdgeInsets.all(8),
              child: const ProductGrid(),
            ),
          ),

          // 3. RIGHT COLUMN: Cart / Ticket
          Expanded(
            flex: 3,
            child: Container(color: Colors.white, child: const CartView()),
          ),
        ],
      ),
    );
  }
}

// --- WIDGETS ---

Widget _buildSyncIcon(ConnectionStatus status) {
  switch (status) {
    case ConnectionStatus.syncing:
      return const SizedBox(
        width: 20,
        height: 20,
        child: CircularProgressIndicator(
          color: AppTheme.qristalBlue,
          strokeWidth: 2,
        ),
      );
    case ConnectionStatus.offline:
      return const Icon(Icons.cloud_off, color: Colors.grey);
    case ConnectionStatus.error:
      return const Icon(Icons.error_outline, color: AppTheme.error);
    case ConnectionStatus.online:
      return const Icon(Icons.cloud_done, color: AppTheme.emerald);
  }
}

class CategoryList extends ConsumerWidget {
  const CategoryList({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final categoriesAsync = ref.watch(categoriesStreamProvider);
    final selectedId = ref.watch(selectedCategoryProvider);

    return categoriesAsync.when(
      data: (categories) => ListView.builder(
        itemCount: categories.length,
        itemBuilder: (context, index) {
          final cat = categories[index];
          final isSelected = cat.id == selectedId;

          return InkWell(
            onTap: () =>
                ref.read(selectedCategoryProvider.notifier).state = cat.id,
            child: Container(
              height: 80,
              alignment: Alignment.centerLeft,
              padding: const EdgeInsets.symmetric(horizontal: 16),
              color: isSelected ? AppTheme.qristalBlue.withOpacity(0.2) : null,
              child: Row(
                children: [
                  Container(
                    width: 6,
                    height: 80,
                    color: hexToColor(cat.colorHex) ?? Colors.grey,
                  ),
                  const SizedBox(width: 12),
                  Text(
                    cat.name,
                    style: TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 16,
                      color: isSelected ? AppTheme.qristalBlue : Colors.white,
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, stack) => Center(child: Text('Error: $err')),
    );
  }

  Color? hexToColor(String? hex) {
    if (hex == null) return null;
    return Color(int.parse(hex.replaceFirst('#', '0xFF')));
  }
}

class ProductGrid extends ConsumerWidget {
  const ProductGrid({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final productsAsync = ref.watch(productsStreamProvider);

    return productsAsync.when(
      data: (products) => GridView.builder(
        gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 3, // 3 Columns of products
          childAspectRatio: 1.2,
          crossAxisSpacing: 8,
          mainAxisSpacing: 8,
        ),
        itemCount: products.length,
        itemBuilder: (context, index) {
          final product = products[index];
          return Card(
            color: AppTheme.surface,
            elevation: 2,
            child: InkWell(
              onTap: () {
                // ADD TO CART ACTION
                ref.read(cartProvider.notifier).addToCart(product);
              },
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(
                    product.name,
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                    textAlign: TextAlign.center,
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    "UGX ${product.price.toStringAsFixed(0)}",
                    style: const TextStyle(
                      fontSize: 14,
                      color: AppTheme.emerald,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, stack) => Center(child: Text('Error: $err')),
    );
  }
}

class CartView extends ConsumerWidget {
  const CartView({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final cartItems = ref.watch(cartProvider);
    final cartNotifier = ref.read(cartProvider.notifier);

    return Column(
      children: [
        // Ticket Header
        Container(
          padding: const EdgeInsets.all(16),
          color: Colors.grey[100],
          width: double.infinity,
          child: Row(
            children: [
              const Text(
                "Current Order",
                style: TextStyle(
                  color: Colors.black,
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
              IconButton(
                icon: const Icon(Icons.delete_sweep, color: Colors.red),
                onPressed: () {
                  // Clear Cart
                  cartNotifier.clearCart();
                },
              ),
            ],
          ),
        ),

        // Cart List
        Expanded(
          child: cartItems.isEmpty
              ? const Center(
                  child: Text(
                    "Cart is empty",
                    style: TextStyle(color: Colors.grey),
                  ),
                )
              : ListView.separated(
                  padding: const EdgeInsets.all(8),
                  itemCount: cartItems.length,
                  separatorBuilder: (ctx, i) => const Divider(),
                  itemBuilder: (context, index) {
                    final item = cartItems[index];
                    return ListTile(
                      title: Text(
                        item.product.name,
                        style: const TextStyle(color: Colors.black87),
                      ),
                      subtitle: Text(
                        "UGX ${item.product.price.toStringAsFixed(0)} x ${item.quantity}",
                        style: const TextStyle(color: Colors.black54),
                      ),
                      trailing: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text(
                            "UGX ${item.total.toStringAsFixed(0)}",
                            style: const TextStyle(
                              color: Colors.black,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          IconButton(
                            icon: const Icon(
                              Icons.remove_circle_outline,
                              color: Colors.red,
                            ),
                            onPressed: () {
                              cartNotifier.removeFromCart(item.product);
                            },
                          ),
                        ],
                      ),
                    );
                  },
                ),
        ),

        // Total & Checkout
        Container(
          padding: const EdgeInsets.all(16),
          color: Colors.grey[200],
          child: Column(
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  const Text(
                    "TOTAL",
                    style: TextStyle(
                      color: Colors.black,
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  Text(
                    "UGX ${cartNotifier.totalAmount.toStringAsFixed(0)}",
                    style: const TextStyle(
                      color: AppTheme.emerald,
                      fontSize: 28,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              SizedBox(
                width: double.infinity,
                height: 60,
                child: ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppTheme.emerald,
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(8),
                    ),
                  ),
                  onPressed: cartItems.isEmpty
                      ? null
                      : () async {
                          // 1. Get current user (you might need a UserProvider to store the logged-in ID)
                          // For MVP, we can grab it from SecureStorage or pass it down.
                          // Let's assume we have a simple provider for current user ID:
                          //  const userId =
                          //      "YOUR_LOGGED_IN_USER_ID"; // Replace this with actual state later

                          // 2. Save to Local DB (Instant)
                          // await ref
                          //     .read(orderServiceProvider)
                          //     .placeOrder(cartItems: cartItems, userId: userId);
                          ref.read(cartProvider.notifier).checkout(context);
                          // 3. Clear UI
                          ref.read(cartProvider.notifier).clearCart();

                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(content: Text("Order Saved ! ")),
                          );

                          // 4. Trigger Background Sync to Cloud
                          // We don't await this because we want the UI to be unblocked immediately
                          ref
                              .read(syncControllerProvider.notifier)
                              .performSync();
                        },
                  child: const Text("CHARGE", style: TextStyle(fontSize: 24)),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

================
File: qristal_mobile/lib/services/sync_service.dart
================
import 'dart:convert';
import 'package:drift/drift.dart';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:drift/drift.dart' as drift;
import 'package:shared_preferences/shared_preferences.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import '../../../core/constants/api_constants.dart';
import '../../../database/database.dart';

class SyncService {
  final AppDatabase db;
  final _storage = const FlutterSecureStorage();

  SyncService(this.db);

  Future<void> syncData() async {
    final token = await _storage.read(key: 'jwt_token');
    if (token == null) throw Exception("Not Authenticated");

    // 1. PUSH local changes first (so server has latest sales)
    await _pushToWeb(token);

    // 2. PULL remote changes (menu updates)
    await pullFromWeb(token); // (Your existing pull logic moves here)
  }

  Future<void> pullFromWeb(String token) async {
    final prefs = await SharedPreferences.getInstance();
    final String? lastSync = prefs.getString('last_sync_timestamp');

    // 1. Prepare Query Params
    String url = '${ApiConstants.baseUrl}/sync/pull';
    if (lastSync != null) {
      url += '?lastSyncTimestamp=$lastSync';
    }

    try {
      // 2. Fetch Data
      final response = await http.get(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $token',
        },
      );

      if (response.statusCode != 200) {
        throw Exception('Sync failed: ${response.body}');
      }

      final data = jsonDecode(response.body);
      final changes = data['changes'];
      final newTimestamp = data['timestamp'];

      // 3. Insert into SQLite (Batch Transaction for Performance)
      await db.batch((batch) {
        // --- Categories ---
        if (changes['categories'] != null) {
          for (var item in changes['categories']) {
            batch.insert(
              db.categories,
              CategoriesCompanion(
                id: drift.Value(item['id']),
                name: drift.Value(item['name']),
                colorHex: drift.Value(item['colorHex']),
                sortOrder: drift.Value(item['sortOrder']),
                updatedAt: drift.Value(DateTime.parse(item['updatedAt'])),
              ),
              mode: drift.InsertMode.insertOrReplace,
            );
          }
        }

        // --- Products ---
        if (changes['products'] != null) {
          for (var item in changes['products']) {
            // Ensure price is treated as double
            double price = double.tryParse(item['price'].toString()) ?? 0.0;

            batch.insert(
              db.products,
              ProductsCompanion(
                id: drift.Value(item['id']),
                categoryId: drift.Value(item['categoryId']),
                name: drift.Value(item['name']),
                price: drift.Value(price),
                isAvailable: drift.Value(item['isAvailable']),
                updatedAt: drift.Value(DateTime.parse(item['updatedAt'])),
              ),
              mode: drift.InsertMode.insertOrReplace,
            );
          }
        }

        // --- Users (Optional, for offline login check later) ---
        // You would handle users similarly here

        // --- Orders ---
        if (changes['orders'] != null) {
          for (var item in changes['orders']) {
            batch.insert(
              db.orders,
              OrdersCompanion(
                id: drift.Value(item['id']),
                receiptNumber: drift.Value(item['receiptNumber']),
                userId: drift.Value(item['userId']),
                tableId: drift.Value(item['tableId']),
                totalAmount: drift.Value(
                  double.tryParse(item['totalAmount'].toString()) ?? 0.0,
                ),
                status: drift.Value(item['status']),
                createdAt: drift.Value(DateTime.parse(item['createdAt'])),
                updatedAt: drift.Value(
                  DateTime.parse(item['updatedAt'] ?? item['createdAt']),
                ),
                isSynced: const drift.Value(true),
              ),
              mode: drift.InsertMode.insertOrReplace,
            );
          }
        }

        // --- Order Items ---
        if (changes['orderItems'] != null) {
          for (var item in changes['orderItems']) {
            batch.insert(
              db.orderItems,
              OrderItemsCompanion(
                id: drift.Value(item['id']),
                orderId: drift.Value(item['orderId']),
                productId: drift.Value(item['productId']),
                quantity: drift.Value(item['quantity']),
                priceAtTimeOfOrder: drift.Value(
                  double.tryParse(item['priceAtTimeOfOrder'].toString()) ?? 0.0,
                ),
                notes: drift.Value(item['notes']),
              ),
              mode: drift.InsertMode.insertOrReplace,
            );
          }
        }

        // --- Payments ---
        if (changes['payments'] != null) {
          for (var item in changes['payments']) {
            batch.insert(
              db.payments,
              PaymentsCompanion(
                id: drift.Value(item['id']),
                orderId: drift.Value(item['orderId']),
                method: drift.Value(item['method']),
                amount: drift.Value(
                  double.tryParse(item['amount'].toString()) ?? 0.0,
                ),
                reference: drift.Value(item['reference']),
                createdAt: drift.Value(DateTime.parse(item['createdAt'])),
              ),
              mode: drift.InsertMode.insertOrReplace,
            );
          }
        }

        // --- Tables ---
        if (changes['seatingTables'] != null) {
          // Ensure your backend API returns this key
          for (var item in changes['seatingTables']) {
            batch.insert(
              db.seatingTables,
              SeatingTablesCompanion(
                id: drift.Value(item['id']),
                name: drift.Value(item['name']),
                status: drift.Value(item['status']),
                floor: drift.Value(item['floor']),
                updatedAt: drift.Value(DateTime.parse(item['updatedAt'])),
              ),
              mode: drift.InsertMode.insertOrReplace,
            );
          }
        }
      });

      // 4. Save new timestamp
      await prefs.setString('last_sync_timestamp', newTimestamp);
      if (kDebugMode) {
        print("Sync Completed Successfully. Timestamp: $newTimestamp");
      }
    } catch (e) {
      if (kDebugMode) {
        print("Sync Error: $e");
      }
      rethrow;
    }
  }

  Future<void> _pushToWeb(String token) async {
    // 1. Find unsynced orders
    final unsyncedOrders = await (db.select(
      db.orders,
    )..where((t) => t.isSynced.equals(false))).get();

    if (unsyncedOrders.isEmpty) return;

    if (kDebugMode) {
      print("Found ${unsyncedOrders.length} orders to push.");
    }

    List<Map<String, dynamic>> ordersPayload = [];
    List<Map<String, dynamic>> itemsPayload = [];
    List<Map<String, dynamic>> paymentsPayload = []; // -> ADDED FOR PAYMENTS

    for (final order in unsyncedOrders) {
      ordersPayload.add({
        'id': order.id,
        'receiptNumber': order.receiptNumber,
        'userId': order.userId,
        'tableId': order.tableId,
        'totalAmount': order.totalAmount,
        'status': order.status,
        'createdAt': order.createdAt.toIso8601String(),
      });

      // Fetch related items
      final items = await (db.select(
        db.orderItems,
      )..where((t) => t.orderId.equals(order.id))).get();
      for (final item in items) {
        itemsPayload.add({
          'id': item.id,
          'orderId': item.orderId,
          'productId': item.productId,
          'quantity': item.quantity,
          'priceAtTimeOfOrder': item.priceAtTimeOfOrder,
          'notes': item.notes,
        });
      }

      // Fetch related payments -> ADDED FOR PAYMENTS
      final payments = await (db.select(
        db.payments,
      )..where((t) => t.orderId.equals(order.id))).get();
      for (final pay in payments) {
        paymentsPayload.add({
          'id': pay.id,
          'orderId': pay.orderId,
          'method': pay.method,
          'amount': pay.amount,
          'reference': pay.reference,
          'createdAt': pay.createdAt.toIso8601String(),
        });
      }
    }

    try {
      final response = await http
          .post(
        Uri.parse('${ApiConstants.baseUrl}${ApiConstants.syncPushEndpoint}'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $token',
        },
        // Include payments in the payload!
        body: jsonEncode({
          'orders': ordersPayload,
          'orderItems': itemsPayload,
          'payments': paymentsPayload,
        }),
          )
          .timeout(const Duration(seconds: 20));

      if (response.statusCode == 201 || response.statusCode == 200) {
        await db.transaction(() async {
          for (final order in unsyncedOrders) {
            await (db.update(db.orders)..where((t) => t.id.equals(order.id)))
                .write(const OrdersCompanion(isSynced: Value(true)));
          }
        });
        if (kDebugMode) print(" Sync Push Successful!");
      } else {
        if (kDebugMode) {
          print(" Push failed: ${response.statusCode} - ${response.body}");
        }
        throw Exception('Push failed: ${response.statusCode} - ${response.body}');
      }
    } catch (e) {
      if (kDebugMode) print(" Connection error during push: $e");
      rethrow;
    }
  }
}

================
File: qristal_mobile/pubspec.lock
================
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  _fe_analyzer_shared:
    dependency: transitive
    description:
      name: _fe_analyzer_shared
      sha256: "8d7ff3948166b8ec5da0fbb5962000926b8e02f2ed9b3e51d1738905fbd4c98d"
      url: "https://pub.dev"
    source: hosted
    version: "93.0.0"
  analyzer:
    dependency: transitive
    description:
      name: analyzer
      sha256: de7148ed2fcec579b19f122c1800933dfa028f6d9fd38a152b04b1516cec120b
      url: "https://pub.dev"
    source: hosted
    version: "10.0.1"
  archive:
    dependency: transitive
    description:
      name: archive
      sha256: a96e8b390886ee8abb49b7bd3ac8df6f451c621619f52a26e815fdcf568959ff
      url: "https://pub.dev"
    source: hosted
    version: "4.0.9"
  args:
    dependency: transitive
    description:
      name: args
      sha256: d0481093c50b1da8910eb0bb301626d4d8eb7284aa739614d2b394ee09e3ea04
      url: "https://pub.dev"
    source: hosted
    version: "2.7.0"
  async:
    dependency: transitive
    description:
      name: async
      sha256: "758e6d74e971c3e5aceb4110bfd6698efc7f501675bcfe0c775459a8140750eb"
      url: "https://pub.dev"
    source: hosted
    version: "2.13.0"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      sha256: "8aab1771e1243a5063b8b0ff68042d67334e3feab9e95b9490f9a6ebf73b42ea"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  build:
    dependency: transitive
    description:
      name: build
      sha256: "275bf6bb2a00a9852c28d4e0b410da1d833a734d57d39d44f94bfc895a484ec3"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.4"
  build_config:
    dependency: transitive
    description:
      name: build_config
      sha256: "4f64382b97504dc2fcdf487d5aae33418e08b4703fc21249e4db6d804a4d0187"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.0"
  build_daemon:
    dependency: transitive
    description:
      name: build_daemon
      sha256: bf05f6e12cfea92d3c09308d7bcdab1906cd8a179b023269eed00c071004b957
      url: "https://pub.dev"
    source: hosted
    version: "4.1.1"
  build_runner:
    dependency: "direct dev"
    description:
      name: build_runner
      sha256: "39ad4ca8a2876779737c60e4228b4bcd35d4352ef7e14e47514093edc012c734"
      url: "https://pub.dev"
    source: hosted
    version: "2.11.1"
  built_collection:
    dependency: transitive
    description:
      name: built_collection
      sha256: "376e3dd27b51ea877c28d525560790aee2e6fbb5f20e2f85d5081027d94e2100"
      url: "https://pub.dev"
    source: hosted
    version: "5.1.1"
  built_value:
    dependency: transitive
    description:
      name: built_value
      sha256: "6ae8a6435a8c6520c7077b107e77f1fb4ba7009633259a4d49a8afd8e7efc5e9"
      url: "https://pub.dev"
    source: hosted
    version: "8.12.4"
  characters:
    dependency: transitive
    description:
      name: characters
      sha256: f71061c654a3380576a52b451dd5532377954cf9dbd272a78fc8479606670803
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  charcode:
    dependency: transitive
    description:
      name: charcode
      sha256: fb0f1107cac15a5ea6ef0a6ef71a807b9e4267c713bb93e00e92d737cc8dbd8a
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  checked_yaml:
    dependency: transitive
    description:
      name: checked_yaml
      sha256: "959525d3162f249993882720d52b7e0c833978df229be20702b33d48d91de70f"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.4"
  cli_util:
    dependency: transitive
    description:
      name: cli_util
      sha256: ff6785f7e9e3c38ac98b2fb035701789de90154024a75b6cb926445e83197d1c
      url: "https://pub.dev"
    source: hosted
    version: "0.4.2"
  clock:
    dependency: transitive
    description:
      name: clock
      sha256: fddb70d9b5277016c77a80201021d40a2247104d9f4aa7bab7157b7e3f05b84b
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  code_builder:
    dependency: transitive
    description:
      name: code_builder
      sha256: "6a6cab2ba4680d6423f34a9b972a4c9a94ebe1b62ecec4e1a1f2cba91fd1319d"
      url: "https://pub.dev"
    source: hosted
    version: "4.11.1"
  collection:
    dependency: transitive
    description:
      name: collection
      sha256: "2f5709ae4d3d59dd8f7cd309b4e023046b57d8a6c82130785d2b0e5868084e76"
      url: "https://pub.dev"
    source: hosted
    version: "1.19.1"
  connectivity_plus:
    dependency: "direct main"
    description:
      name: connectivity_plus
      sha256: "33bae12a398f841c6cda09d1064212957265869104c478e5ad51e2fb26c3973c"
      url: "https://pub.dev"
    source: hosted
    version: "7.0.0"
  connectivity_plus_platform_interface:
    dependency: transitive
    description:
      name: connectivity_plus_platform_interface
      sha256: "42657c1715d48b167930d5f34d00222ac100475f73d10162ddf43e714932f204"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.1"
  convert:
    dependency: transitive
    description:
      name: convert
      sha256: b30acd5944035672bc15c6b7a8b47d773e41e2f17de064350988c5d02adb1c68
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
  crypto:
    dependency: transitive
    description:
      name: crypto
      sha256: c8ea0233063ba03258fbcf2ca4d6dadfefe14f02fab57702265467a19f27fadf
      url: "https://pub.dev"
    source: hosted
    version: "3.0.7"
  csslib:
    dependency: transitive
    description:
      name: csslib
      sha256: "09bad715f418841f976c77db72d5398dc1253c21fb9c0c7f0b0b985860b2d58e"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.2"
  cupertino_icons:
    dependency: "direct main"
    description:
      name: cupertino_icons
      sha256: ba631d1c7f7bef6b729a622b7b752645a2d076dba9976925b8f25725a30e1ee6
      url: "https://pub.dev"
    source: hosted
    version: "1.0.8"
  dart_style:
    dependency: transitive
    description:
      name: dart_style
      sha256: "15a7db352c8fc6a4d2bc475ba901c25b39fe7157541da4c16eacce6f8be83e49"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.5"
  dbus:
    dependency: transitive
    description:
      name: dbus
      sha256: d0c98dcd4f5169878b6cf8f6e0a52403a9dff371a3e2f019697accbf6f44a270
      url: "https://pub.dev"
    source: hosted
    version: "0.7.12"
  drift:
    dependency: "direct main"
    description:
      name: drift
      sha256: "970cd188fddb111b26ea6a9b07a62bf5c2432d74147b8122c67044ae3b97e99e"
      url: "https://pub.dev"
    source: hosted
    version: "2.31.0"
  drift_dev:
    dependency: "direct dev"
    description:
      name: drift_dev
      sha256: "917184b2fb867b70a548a83bf0d36268423b38d39968c06cce4905683da49587"
      url: "https://pub.dev"
    source: hosted
    version: "2.31.0"
  esc_pos_utils_plus:
    dependency: "direct main"
    description:
      name: esc_pos_utils_plus
      sha256: "2a22d281cb6f04600ba3ebd607ad8df03a4b2446d814007d22525bab4d50c2ff"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.4"
  fake_async:
    dependency: transitive
    description:
      name: fake_async
      sha256: "5368f224a74523e8d2e7399ea1638b37aecfca824a3cc4dfdf77bf1fa905ac44"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.3"
  ffi:
    dependency: transitive
    description:
      name: ffi
      sha256: "6d7fd89431262d8f3125e81b50d3847a091d846eafcd4fdb88dd06f36d705a45"
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  file:
    dependency: transitive
    description:
      name: file
      sha256: a3b4f84adafef897088c160faf7dfffb7696046cb13ae90b508c2cbc95d3b8d4
      url: "https://pub.dev"
    source: hosted
    version: "7.0.1"
  fixnum:
    dependency: transitive
    description:
      name: fixnum
      sha256: b6dc7065e46c974bc7c5f143080a6764ec7a4be6da1285ececdc37be96de53be
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  flutter:
    dependency: "direct main"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_lints:
    dependency: "direct dev"
    description:
      name: flutter_lints
      sha256: "5398f14efa795ffb7a33e9b6a08798b26a180edac4ad7db3f231e40f82ce11e1"
      url: "https://pub.dev"
    source: hosted
    version: "5.0.0"
  flutter_riverpod:
    dependency: "direct main"
    description:
      name: flutter_riverpod
      sha256: "9532ee6db4a943a1ed8383072a2e3eeda041db5657cdf6d2acecf3c21ecbe7e1"
      url: "https://pub.dev"
    source: hosted
    version: "2.6.1"
  flutter_secure_storage:
    dependency: "direct main"
    description:
      name: flutter_secure_storage
      sha256: da922f2aab2d733db7e011a6bcc4a825b844892d4edd6df83ff156b09a9b2e40
      url: "https://pub.dev"
    source: hosted
    version: "10.0.0"
  flutter_secure_storage_darwin:
    dependency: transitive
    description:
      name: flutter_secure_storage_darwin
      sha256: "8878c25136a79def1668c75985e8e193d9d7d095453ec28730da0315dc69aee3"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.0"
  flutter_secure_storage_linux:
    dependency: transitive
    description:
      name: flutter_secure_storage_linux
      sha256: "2b5c76dce569ab752d55a1cee6a2242bcc11fdba927078fb88c503f150767cda"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.0"
  flutter_secure_storage_platform_interface:
    dependency: transitive
    description:
      name: flutter_secure_storage_platform_interface
      sha256: "8ceea1223bee3c6ac1a22dabd8feefc550e4729b3675de4b5900f55afcb435d6"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.1"
  flutter_secure_storage_web:
    dependency: transitive
    description:
      name: flutter_secure_storage_web
      sha256: "6a1137df62b84b54261dca582c1c09ea72f4f9a4b2fcee21b025964132d5d0c3"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.0"
  flutter_secure_storage_windows:
    dependency: transitive
    description:
      name: flutter_secure_storage_windows
      sha256: "3b7c8e068875dfd46719ff57c90d8c459c87f2302ed6b00ff006b3c9fcad1613"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.0"
  flutter_test:
    dependency: "direct dev"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_web_plugins:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  glob:
    dependency: transitive
    description:
      name: glob
      sha256: c3f1ee72c96f8f78935e18aa8cecced9ab132419e8625dc187e1c2408efc20de
      url: "https://pub.dev"
    source: hosted
    version: "2.1.3"
  graphs:
    dependency: transitive
    description:
      name: graphs
      sha256: "741bbf84165310a68ff28fe9e727332eef1407342fca52759cb21ad8177bb8d0"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.2"
  html:
    dependency: transitive
    description:
      name: html
      sha256: "6d1264f2dffa1b1101c25a91dff0dc2daee4c18e87cd8538729773c073dbf602"
      url: "https://pub.dev"
    source: hosted
    version: "0.15.6"
  http:
    dependency: "direct main"
    description:
      name: http
      sha256: "87721a4a50b19c7f1d49001e51409bddc46303966ce89a65af4f4e6004896412"
      url: "https://pub.dev"
    source: hosted
    version: "1.6.0"
  http_multi_server:
    dependency: transitive
    description:
      name: http_multi_server
      sha256: aa6199f908078bb1c5efb8d8638d4ae191aac11b311132c3ef48ce352fb52ef8
      url: "https://pub.dev"
    source: hosted
    version: "3.2.2"
  http_parser:
    dependency: transitive
    description:
      name: http_parser
      sha256: "178d74305e7866013777bab2c3d8726205dc5a4dd935297175b19a23a2e66571"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.2"
  image:
    dependency: transitive
    description:
      name: image
      sha256: f9881ff4998044947ec38d098bc7c8316ae1186fa786eddffdb867b9bc94dfce
      url: "https://pub.dev"
    source: hosted
    version: "4.8.0"
  intl:
    dependency: "direct main"
    description:
      name: intl
      sha256: "3df61194eb431efc39c4ceba583b95633a403f46c9fd341e550ce0bfa50e9aa5"
      url: "https://pub.dev"
    source: hosted
    version: "0.20.2"
  io:
    dependency: transitive
    description:
      name: io
      sha256: dfd5a80599cf0165756e3181807ed3e77daf6dd4137caaad72d0b7931597650b
      url: "https://pub.dev"
    source: hosted
    version: "1.0.5"
  json_annotation:
    dependency: transitive
    description:
      name: json_annotation
      sha256: cb09e7dac6210041fad964ed7fbee004f14258b4eca4040f72d1234062ace4c8
      url: "https://pub.dev"
    source: hosted
    version: "4.11.0"
  json_serializable:
    dependency: "direct dev"
    description:
      name: json_serializable
      sha256: "44729f5c45748e6748f6b9a57ab8f7e4336edc8ae41fc295070e3814e616a6c0"
      url: "https://pub.dev"
    source: hosted
    version: "6.13.0"
  leak_tracker:
    dependency: transitive
    description:
      name: leak_tracker
      sha256: "33e2e26bdd85a0112ec15400c8cbffea70d0f9c3407491f672a2fad47915e2de"
      url: "https://pub.dev"
    source: hosted
    version: "11.0.2"
  leak_tracker_flutter_testing:
    dependency: transitive
    description:
      name: leak_tracker_flutter_testing
      sha256: "1dbc140bb5a23c75ea9c4811222756104fbcd1a27173f0c34ca01e16bea473c1"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.10"
  leak_tracker_testing:
    dependency: transitive
    description:
      name: leak_tracker_testing
      sha256: "8d5a2d49f4a66b49744b23b018848400d23e54caf9463f4eb20df3eb8acb2eb1"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.2"
  lints:
    dependency: transitive
    description:
      name: lints
      sha256: c35bb79562d980e9a453fc715854e1ed39e24e7d0297a880ef54e17f9874a9d7
      url: "https://pub.dev"
    source: hosted
    version: "5.1.1"
  logging:
    dependency: transitive
    description:
      name: logging
      sha256: c8245ada5f1717ed44271ed1c26b8ce85ca3228fd2ffdb75468ab01979309d61
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  matcher:
    dependency: transitive
    description:
      name: matcher
      sha256: dc58c723c3c24bf8d3e2d3ad3f2f9d7bd9cf43ec6feaa64181775e60190153f2
      url: "https://pub.dev"
    source: hosted
    version: "0.12.17"
  material_color_utilities:
    dependency: transitive
    description:
      name: material_color_utilities
      sha256: f7142bb1154231d7ea5f96bc7bde4bda2a0945d2806bb11670e30b850d56bdec
      url: "https://pub.dev"
    source: hosted
    version: "0.11.1"
  meta:
    dependency: transitive
    description:
      name: meta
      sha256: e3641ec5d63ebf0d9b41bd43201a66e3fc79a65db5f61fc181f04cd27aab950c
      url: "https://pub.dev"
    source: hosted
    version: "1.16.0"
  mime:
    dependency: transitive
    description:
      name: mime
      sha256: "41a20518f0cb1256669420fdba0cd90d21561e560ac240f26ef8322e45bb7ed6"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
  nm:
    dependency: transitive
    description:
      name: nm
      sha256: "2c9aae4127bdc8993206464fcc063611e0e36e72018696cd9631023a31b24254"
      url: "https://pub.dev"
    source: hosted
    version: "0.5.0"
  package_config:
    dependency: transitive
    description:
      name: package_config
      sha256: f096c55ebb7deb7e384101542bfba8c52696c1b56fca2eb62827989ef2353bbc
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  path:
    dependency: "direct main"
    description:
      name: path
      sha256: "75cca69d1490965be98c73ceaea117e8a04dd21217b37b292c9ddbec0d955bc5"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.1"
  path_provider:
    dependency: "direct main"
    description:
      name: path_provider
      sha256: "50c5dd5b6e1aaf6fb3a78b33f6aa3afca52bf903a8a5298f53101fdaee55bbcd"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.5"
  path_provider_android:
    dependency: transitive
    description:
      name: path_provider_android
      sha256: f2c65e21139ce2c3dad46922be8272bb5963516045659e71bb16e151c93b580e
      url: "https://pub.dev"
    source: hosted
    version: "2.2.22"
  path_provider_foundation:
    dependency: transitive
    description:
      name: path_provider_foundation
      sha256: "6d13aece7b3f5c5a9731eaf553ff9dcbc2eff41087fd2df587fd0fed9a3eb0c4"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.1"
  path_provider_linux:
    dependency: transitive
    description:
      name: path_provider_linux
      sha256: f7a1fe3a634fe7734c8d3f2766ad746ae2a2884abe22e241a8b301bf5cac3279
      url: "https://pub.dev"
    source: hosted
    version: "2.2.1"
  path_provider_platform_interface:
    dependency: transitive
    description:
      name: path_provider_platform_interface
      sha256: "88f5779f72ba699763fa3a3b06aa4bf6de76c8e5de842cf6f29e2e06476c2334"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  path_provider_windows:
    dependency: transitive
    description:
      name: path_provider_windows
      sha256: bd6f00dbd873bfb70d0761682da2b3a2c2fccc2b9e84c495821639601d81afe7
      url: "https://pub.dev"
    source: hosted
    version: "2.3.0"
  permission_handler:
    dependency: "direct main"
    description:
      name: permission_handler
      sha256: bc917da36261b00137bbc8896bf1482169cd76f866282368948f032c8c1caae1
      url: "https://pub.dev"
    source: hosted
    version: "12.0.1"
  permission_handler_android:
    dependency: transitive
    description:
      name: permission_handler_android
      sha256: "1e3bc410ca1bf84662104b100eb126e066cb55791b7451307f9708d4007350e6"
      url: "https://pub.dev"
    source: hosted
    version: "13.0.1"
  permission_handler_apple:
    dependency: transitive
    description:
      name: permission_handler_apple
      sha256: f000131e755c54cf4d84a5d8bd6e4149e262cc31c5a8b1d698de1ac85fa41023
      url: "https://pub.dev"
    source: hosted
    version: "9.4.7"
  permission_handler_html:
    dependency: transitive
    description:
      name: permission_handler_html
      sha256: "38f000e83355abb3392140f6bc3030660cfaef189e1f87824facb76300b4ff24"
      url: "https://pub.dev"
    source: hosted
    version: "0.1.3+5"
  permission_handler_platform_interface:
    dependency: transitive
    description:
      name: permission_handler_platform_interface
      sha256: eb99b295153abce5d683cac8c02e22faab63e50679b937fa1bf67d58bb282878
      url: "https://pub.dev"
    source: hosted
    version: "4.3.0"
  permission_handler_windows:
    dependency: transitive
    description:
      name: permission_handler_windows
      sha256: "1a790728016f79a41216d88672dbc5df30e686e811ad4e698bfc51f76ad91f1e"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.1"
  petitparser:
    dependency: transitive
    description:
      name: petitparser
      sha256: "91bd59303e9f769f108f8df05e371341b15d59e995e6806aefab827b58336675"
      url: "https://pub.dev"
    source: hosted
    version: "7.0.2"
  platform:
    dependency: transitive
    description:
      name: platform
      sha256: "5d6b1b0036a5f331ebc77c850ebc8506cbc1e9416c27e59b439f917a902a4984"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.6"
  plugin_platform_interface:
    dependency: transitive
    description:
      name: plugin_platform_interface
      sha256: "4820fbfdb9478b1ebae27888254d445073732dae3d6ea81f0b7e06d5dedc3f02"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.8"
  pool:
    dependency: transitive
    description:
      name: pool
      sha256: "978783255c543aa3586a1b3c21f6e9d720eb315376a915872c61ef8b5c20177d"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.2"
  posix:
    dependency: transitive
    description:
      name: posix
      sha256: "6323a5b0fa688b6a010df4905a56b00181479e6d10534cecfecede2aa55add61"
      url: "https://pub.dev"
    source: hosted
    version: "6.0.3"
  print_bluetooth_thermal:
    dependency: "direct main"
    description:
      name: print_bluetooth_thermal
      sha256: "17b204a5340174c02acf5f6caf7279b5000344f1f1e1bcd01dbdbf912bce6e46"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.9"
  pub_semver:
    dependency: transitive
    description:
      name: pub_semver
      sha256: "5bfcf68ca79ef689f8990d1160781b4bad40a3bd5e5218ad4076ddb7f4081585"
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  pubspec_parse:
    dependency: transitive
    description:
      name: pubspec_parse
      sha256: "0560ba233314abbed0a48a2956f7f022cce7c3e1e73df540277da7544cad4082"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.0"
  recase:
    dependency: transitive
    description:
      name: recase
      sha256: e4eb4ec2dcdee52dcf99cb4ceabaffc631d7424ee55e56f280bc039737f89213
      url: "https://pub.dev"
    source: hosted
    version: "4.1.0"
  riverpod:
    dependency: transitive
    description:
      name: riverpod
      sha256: "59062512288d3056b2321804332a13ffdd1bf16df70dcc8e506e411280a72959"
      url: "https://pub.dev"
    source: hosted
    version: "2.6.1"
  shared_preferences:
    dependency: "direct main"
    description:
      name: shared_preferences
      sha256: "2939ae520c9024cb197fc20dee269cd8cdbf564c8b5746374ec6cacdc5169e64"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.4"
  shared_preferences_android:
    dependency: transitive
    description:
      name: shared_preferences_android
      sha256: cbc40be9be1c5af4dab4d6e0de4d5d3729e6f3d65b89d21e1815d57705644a6f
      url: "https://pub.dev"
    source: hosted
    version: "2.4.20"
  shared_preferences_foundation:
    dependency: transitive
    description:
      name: shared_preferences_foundation
      sha256: "4e7eaffc2b17ba398759f1151415869a34771ba11ebbccd1b0145472a619a64f"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.6"
  shared_preferences_linux:
    dependency: transitive
    description:
      name: shared_preferences_linux
      sha256: "580abfd40f415611503cae30adf626e6656dfb2f0cee8f465ece7b6defb40f2f"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shared_preferences_platform_interface:
    dependency: transitive
    description:
      name: shared_preferences_platform_interface
      sha256: "57cbf196c486bc2cf1f02b85784932c6094376284b3ad5779d1b1c6c6a816b80"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shared_preferences_web:
    dependency: transitive
    description:
      name: shared_preferences_web
      sha256: c49bd060261c9a3f0ff445892695d6212ff603ef3115edbb448509d407600019
      url: "https://pub.dev"
    source: hosted
    version: "2.4.3"
  shared_preferences_windows:
    dependency: transitive
    description:
      name: shared_preferences_windows
      sha256: "94ef0f72b2d71bc3e700e025db3710911bd51a71cefb65cc609dd0d9a982e3c1"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shelf:
    dependency: transitive
    description:
      name: shelf
      sha256: e7dd780a7ffb623c57850b33f43309312fc863fb6aa3d276a754bb299839ef12
      url: "https://pub.dev"
    source: hosted
    version: "1.4.2"
  shelf_web_socket:
    dependency: transitive
    description:
      name: shelf_web_socket
      sha256: "3632775c8e90d6c9712f883e633716432a27758216dfb61bd86a8321c0580925"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.0"
  sky_engine:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  socket_io_client:
    dependency: "direct main"
    description:
      name: socket_io_client
      sha256: ef6c989e5eee8d04baf18482ec3d7699b91bc41e279794a99d8e3bef897b074a
      url: "https://pub.dev"
    source: hosted
    version: "3.1.4"
  socket_io_common:
    dependency: transitive
    description:
      name: socket_io_common
      sha256: "162fbaecbf4bf9a9372a62a341b3550b51dcef2f02f3e5830a297fd48203d45b"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.1"
  source_gen:
    dependency: transitive
    description:
      name: source_gen
      sha256: "1d562a3c1f713904ebbed50d2760217fd8a51ca170ac4b05b0db490699dbac17"
      url: "https://pub.dev"
    source: hosted
    version: "4.2.0"
  source_helper:
    dependency: transitive
    description:
      name: source_helper
      sha256: "4a85e90b50694e652075cbe4575665539d253e6ec10e46e76b45368ab5e3caae"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.10"
  source_span:
    dependency: transitive
    description:
      name: source_span
      sha256: "56a02f1f4cd1a2d96303c0144c93bd6d909eea6bee6bf5a0e0b685edbd4c47ab"
      url: "https://pub.dev"
    source: hosted
    version: "1.10.2"
  sqlite3:
    dependency: "direct main"
    description:
      name: sqlite3
      sha256: "3145bd74dcdb4fd6f5c6dda4d4e4490a8087d7f286a14dee5d37087290f0f8a2"
      url: "https://pub.dev"
    source: hosted
    version: "2.9.4"
  sqlite3_flutter_libs:
    dependency: "direct main"
    description:
      name: sqlite3_flutter_libs
      sha256: "1e800ebe7f85a80a66adacaa6febe4d5f4d8b75f244e9838a27cb2ffc7aec08d"
      url: "https://pub.dev"
    source: hosted
    version: "0.5.41"
  sqlparser:
    dependency: transitive
    description:
      name: sqlparser
      sha256: "337e9997f7141ffdd054259128553c348635fa318f7ca492f07a4ab76f850d19"
      url: "https://pub.dev"
    source: hosted
    version: "0.43.1"
  stack_trace:
    dependency: transitive
    description:
      name: stack_trace
      sha256: "8b27215b45d22309b5cddda1aa2b19bdfec9df0e765f2de506401c071d38d1b1"
      url: "https://pub.dev"
    source: hosted
    version: "1.12.1"
  state_notifier:
    dependency: transitive
    description:
      name: state_notifier
      sha256: b8677376aa54f2d7c58280d5a007f9e8774f1968d1fb1c096adcb4792fba29bb
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  stream_channel:
    dependency: transitive
    description:
      name: stream_channel
      sha256: "969e04c80b8bcdf826f8f16579c7b14d780458bd97f56d107d3950fdbeef059d"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  stream_transform:
    dependency: transitive
    description:
      name: stream_transform
      sha256: ad47125e588cfd37a9a7f86c7d6356dde8dfe89d071d293f80ca9e9273a33871
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  string_scanner:
    dependency: transitive
    description:
      name: string_scanner
      sha256: "921cd31725b72fe181906c6a94d987c78e3b98c2e205b397ea399d4054872b43"
      url: "https://pub.dev"
    source: hosted
    version: "1.4.1"
  term_glyph:
    dependency: transitive
    description:
      name: term_glyph
      sha256: "7f554798625ea768a7518313e58f83891c7f5024f88e46e7182a4558850a4b8e"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.2"
  test_api:
    dependency: transitive
    description:
      name: test_api
      sha256: "522f00f556e73044315fa4585ec3270f1808a4b186c936e612cab0b565ff1e00"
      url: "https://pub.dev"
    source: hosted
    version: "0.7.6"
  typed_data:
    dependency: transitive
    description:
      name: typed_data
      sha256: f9049c039ebfeb4cf7a7104a675823cd72dba8297f264b6637062516699fa006
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  uuid:
    dependency: "direct main"
    description:
      name: uuid
      sha256: a11b666489b1954e01d992f3d601b1804a33937b5a8fe677bd26b8a9f96f96e8
      url: "https://pub.dev"
    source: hosted
    version: "4.5.2"
  vector_math:
    dependency: transitive
    description:
      name: vector_math
      sha256: d530bd74fea330e6e364cda7a85019c434070188383e1cd8d9777ee586914c5b
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  vm_service:
    dependency: transitive
    description:
      name: vm_service
      sha256: "45caa6c5917fa127b5dbcfbd1fa60b14e583afdc08bfc96dda38886ca252eb60"
      url: "https://pub.dev"
    source: hosted
    version: "15.0.2"
  watcher:
    dependency: transitive
    description:
      name: watcher
      sha256: "1398c9f081a753f9226febe8900fce8f7d0a67163334e1c94a2438339d79d635"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.1"
  web:
    dependency: transitive
    description:
      name: web
      sha256: "868d88a33d8a87b18ffc05f9f030ba328ffefba92d6c127917a2ba740f9cfe4a"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  web_socket:
    dependency: transitive
    description:
      name: web_socket
      sha256: "34d64019aa8e36bf9842ac014bb5d2f5586ca73df5e4d9bf5c936975cae6982c"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.1"
  web_socket_channel:
    dependency: transitive
    description:
      name: web_socket_channel
      sha256: d645757fb0f4773d602444000a8131ff5d48c9e47adfe9772652dd1a4f2d45c8
      url: "https://pub.dev"
    source: hosted
    version: "3.0.3"
  win32:
    dependency: transitive
    description:
      name: win32
      sha256: d7cb55e04cd34096cd3a79b3330245f54cb96a370a1c27adb3c84b917de8b08e
      url: "https://pub.dev"
    source: hosted
    version: "5.15.0"
  win_ble:
    dependency: transitive
    description:
      name: win_ble
      sha256: "2a867e13c4b355b101fc2c6e2ac85eeebf965db34eca46856f8b478e93b41e96"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  xdg_directories:
    dependency: transitive
    description:
      name: xdg_directories
      sha256: "7a3f37b05d989967cdddcbb571f1ea834867ae2faa29725fd085180e0883aa15"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  xml:
    dependency: transitive
    description:
      name: xml
      sha256: "971043b3a0d3da28727e40ed3e0b5d18b742fa5a68665cca88e74b7876d5e025"
      url: "https://pub.dev"
    source: hosted
    version: "6.6.1"
  yaml:
    dependency: transitive
    description:
      name: yaml
      sha256: b9da305ac7c39faa3f030eccd175340f968459dae4af175130b3fc47e40d76ce
      url: "https://pub.dev"
    source: hosted
    version: "3.1.3"
sdks:
  dart: ">=3.9.0 <4.0.0"
  flutter: ">=3.35.0"

================
File: qristal_mobile/pubspec.yaml
================
name: qristal_mobile
description: "Qristal POS Mobile App."

publish_to: 'none' # Remove this line if you wish to publish to pub.dev


version: 1.0.1+2

environment:
  sdk: ^3.9.0


dependencies:
  flutter:
    sdk: flutter


  cupertino_icons: ^1.0.6
  path_provider: ^2.1.5
  path: ^1.9.0
  drift: ^2.21.0
  http: ^1.6.0
  flutter_secure_storage: ^10.0.0
  flutter_riverpod: ^2.6.1
  uuid: ^4.5.2
  shared_preferences: ^2.3.3
  sqlite3_flutter_libs: ^0.5.41
  sqlite3: ^2.9.4
  
  intl: ^0.20.2
  permission_handler: ^12.0.1
  print_bluetooth_thermal: ^1.1.9
  esc_pos_utils_plus: ^2.0.4
  connectivity_plus: ^7.0.0
  socket_io_client: ^3.1.4


dev_dependencies:
  flutter_test:
    sdk: flutter

  flutter_lints: ^5.0.0
  drift_dev: ^2.14.1
  build_runner: ^2.4.8
  json_serializable: ^6.7.1


# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/assets-and-images/#resolution-aware

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/assets-and-images/#from-packages

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/custom-fonts/#from-packages





================================================================
End of Codebase
================================================================
