This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.idx/
  dev.nix
qristal_api/
  prisma/
    migrations/
      20260219201451_init/
        migration.sql
      20260221192920_add_payments/
        migration.sql
      20260221210510_add_tables/
        migration.sql
      20260222111806_add_inventory/
        migration.sql
      20260223065237_add_shifts/
        migration.sql
      20260223142342_add_branch_id_to_all/
        migration.sql
      20260223143013_add_branch_id_to_all/
        migration.sql
      20260223145956_add_branch_isolation/
        migration.sql
      20260223230500_add_shift_id_to_payments/
        migration.sql
      20260224090000_add_audit_and_sync_logs/
        migration.sql
      20260226120000_add_order_item_routing_modifiers_sides/
        migration.sql
      20260226132850_update_schema/
        migration.sql
      20260226143000_add_product_customization_metadata/
        migration.sql
      20260227173450_modif/
        migration.sql
      migration_lock.toml
    schema.prisma
    schema.prisma.save
    seed.ts
  scripts/
    create-main-entry.cjs
  src/
    auth/
      auth.controller.spec.ts
      auth.controller.ts
      auth.module.ts
      auth.service.spec.ts
      auth.service.ts
      jwt.strategy.ts
    events/
      events.gateway.spec.ts
      events.gateway.ts
      events.module.ts
    inventory/
      inventory.controller.spec.ts
      inventory.controller.ts
      inventory.module.ts
      inventory.service.spec.ts
      inventory.service.ts
    menu/
      categories.controller.spec.ts
      categories.controller.ts
      menu.module.ts
      menu.service.spec.ts
      menu.service.ts
      modifier-groups.controller.ts
      product.dto.spec.ts
      product.dto.ts
      products.controller.spec.ts
      products.controller.ts
      sides.controller.ts
    prisma/
      prisma.module.ts
      prisma.service.ts
    reports/
      reports.controller.spec.ts
      reports.controller.ts
      reports.module.ts
      reports.service.spec.ts
      reports.service.ts
    seating/
      seating.controller.spec.ts
      seating.controller.ts
      seating.module.ts
      seating.service.spec.ts
      seating.service.ts
    sync/
      sync.controller.spec.ts
      sync.controller.ts
      sync.module.ts
      sync.service.spec.ts
      sync.service.ts
    users/
      users.controller.spec.ts
      users.controller.ts
      users.module.ts
      users.service.spec.ts
      users.service.ts
    app.controller.spec.ts
    app.controller.ts
    app.module.ts
    app.service.ts
    main.ts
  test/
    app.e2e-spec.ts
    jest-e2e.json
  .git
  .gitignore
  .prettierrc
  .repomixignore
  docker-compose.yaml
  eslint.config.mjs
  nest-cli.json
  package.json
  prisma.config.ts
  README.md
  repomix.config.json
  tsconfig.build.json
  tsconfig.json
qristal_dashboard/
  public/
    logo-512.png
  src/
    app/
      admin/
        analytics/
          page.tsx
        inventory/
          page.tsx
        menu/
          page.tsx
        tables/
          page.tsx
        users/
          page.tsx
        layout.tsx
        page.tsx
      login/
        page.tsx
      reports/
        page.tsx
      favicon.ico
      globals.css
      layout.tsx
      page.tsx
    components/
      withAuth.tsx
    context/
      AuthContext.tsx
  .git
  .gitignore
  eslint.config.mjs
  next.config.ts
  package.json
  postcss.config.mjs
  README.md
  tsconfig.json
qristal_mobile/
  .idx/
    dev.nix
  .vscode/
    settings.json
  android/
    app/
      src/
        debug/
          AndroidManifest.xml
        main/
          kotlin/
            com/
              truthysystems/
                qristal_mobile/
                  MainActivity.kt
          res/
            drawable/
              launch_background.xml
            drawable-v21/
              launch_background.xml
            mipmap-anydpi-v26/
              ic_launcher.xml
            mipmap-hdpi/
              ic_launcher_background.png
              ic_launcher_foreground.png
              ic_launcher_monochrome.png
              ic_launcher.png
            mipmap-mdpi/
              ic_launcher_background.png
              ic_launcher_foreground.png
              ic_launcher_monochrome.png
              ic_launcher.png
            mipmap-xhdpi/
              ic_launcher_background.png
              ic_launcher_foreground.png
              ic_launcher_monochrome.png
              ic_launcher.png
            mipmap-xxhdpi/
              ic_launcher_background.png
              ic_launcher_foreground.png
              ic_launcher_monochrome.png
              ic_launcher.png
            mipmap-xxxhdpi/
              ic_launcher_background.png
              ic_launcher_foreground.png
              ic_launcher_monochrome.png
              ic_launcher.png
            values/
              styles.xml
            values-night/
              styles.xml
          AndroidManifest.xml
        profile/
          AndroidManifest.xml
      build.gradle.kts
    gradle/
      wrapper/
        gradle-wrapper.properties
    .gitignore
    build.gradle.kts
    gradle.properties
    settings.gradle.kts
  lib/
    core/
      constants/
        api_constants.dart
        role_constants.dart
      providers/
        database_provider.dart
      theme/
        app_theme.dart
    database/
      database.dart
      database.g.dart
    features/
      auth/
        providers/
          auth_provider.dart
        screens/
          login_screen.dart
        services/
          auth_service.dart
      hardware/
        screens/
          printer_settings_screen.dart
        services/
          printer_service.dart
          receipt_generator.dart
      kitchen/
        screens/
          kitchen_screen.dart
      pos/
        models/
          cart_item.dart
        providers/
          cart_provider.dart
          menu_provider.dart
        screens/
          dashboard_screen.dart
        services/
          order_service.dart
        widgets/
          payment_modal.dart
      shifts/
        providers/
          shift_provider.dart
        screens/
          close_shift_screen.dart
          open_shift_dialog.dart
      sync/
        providers/
          sync_provider.dart
          sync_queue_provider.dart
      tables/
        screens/
          floor_plan_screen.dart
    services/
      sync_service.dart
      websocket_service.dart
    main.dart
  test/
    widget_test.dart
  windows/
    flutter/
      CMakeLists.txt
      generated_plugin_registrant.cc
      generated_plugin_registrant.h
      generated_plugins.cmake
    runner/
      resources/
        app_icon.ico
      CMakeLists.txt
      flutter_window.cpp
      flutter_window.h
      main.cpp
      resource.h
      runner.exe.manifest
      Runner.rc
      utils.cpp
      utils.h
      win32_window.cpp
      win32_window.h
    .gitignore
    CMakeLists.txt
  .git
  .gitignore
  .metadata
  .repomixignore
  analysis_options.yaml
  pubspec.lock
  pubspec.yaml
  README.md
  repomix.config.json
gitmodules.txt
README.md
repomix.config.json

================================================================
Files
================================================================

================
File: qristal_api/prisma/migrations/20260219201451_init/migration.sql
================
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('OWNER', 'MANAGER', 'CASHIER', 'WAITER', 'KITCHEN');

-- CreateEnum
CREATE TYPE "OrderStatus" AS ENUM ('OPEN', 'KITCHEN', 'SERVED', 'CLOSED', 'VOIDED');

-- CreateTable
CREATE TABLE "users" (
    "id" TEXT NOT NULL,
    "pin" TEXT NOT NULL,
    "role" "Role" NOT NULL DEFAULT 'WAITER',
    "full_name" TEXT NOT NULL,
    "branch_id" TEXT NOT NULL,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "deleted_at" TIMESTAMP(3),

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "categories" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "color_hex" TEXT,
    "sort_order" INTEGER NOT NULL DEFAULT 0,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "deleted_at" TIMESTAMP(3),

    CONSTRAINT "categories_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "products" (
    "id" TEXT NOT NULL,
    "category_id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "price" DECIMAL(10,2) NOT NULL,
    "is_available" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "deleted_at" TIMESTAMP(3),

    CONSTRAINT "products_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "orders" (
    "id" TEXT NOT NULL,
    "receipt_number" TEXT NOT NULL,
    "user_id" TEXT NOT NULL,
    "table_id" TEXT,
    "total_amount" DECIMAL(10,2) NOT NULL,
    "status" "OrderStatus" NOT NULL DEFAULT 'OPEN',
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "orders_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "order_items" (
    "id" TEXT NOT NULL,
    "order_id" TEXT NOT NULL,
    "product_id" TEXT NOT NULL,
    "quantity" INTEGER NOT NULL,
    "price_at_time_of_order" DECIMAL(10,2) NOT NULL,
    "notes" TEXT,

    CONSTRAINT "order_items_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_pin_key" ON "users"("pin");

-- AddForeignKey
ALTER TABLE "products" ADD CONSTRAINT "products_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "categories"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "orders" ADD CONSTRAINT "orders_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "order_items" ADD CONSTRAINT "order_items_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "orders"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "order_items" ADD CONSTRAINT "order_items_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "products"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

================
File: qristal_api/prisma/migrations/20260221192920_add_payments/migration.sql
================
-- CreateEnum
CREATE TYPE "PaymentMethod" AS ENUM ('CASH', 'CARD', 'MOBILE_MONEY', 'OTHER');

-- CreateTable
CREATE TABLE "payments" (
    "id" TEXT NOT NULL,
    "order_id" TEXT NOT NULL,
    "method" "PaymentMethod" NOT NULL,
    "amount" DECIMAL(10,2) NOT NULL,
    "reference" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "payments_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "payments" ADD CONSTRAINT "payments_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "orders"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

================
File: qristal_api/prisma/migrations/20260221210510_add_tables/migration.sql
================
-- CreateTable
CREATE TABLE "seating_tables" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "status" TEXT NOT NULL DEFAULT 'FREE',
    "capacity" INTEGER NOT NULL DEFAULT 4,
    "floor" TEXT NOT NULL DEFAULT 'Main',
    "x" INTEGER NOT NULL DEFAULT 0,
    "y" INTEGER NOT NULL DEFAULT 0,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "deleted_at" TIMESTAMP(3),

    CONSTRAINT "seating_tables_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "orders" ADD CONSTRAINT "orders_table_id_fkey" FOREIGN KEY ("table_id") REFERENCES "seating_tables"("id") ON DELETE SET NULL ON UPDATE CASCADE;

================
File: qristal_api/prisma/migrations/20260222111806_add_inventory/migration.sql
================
-- CreateTable
CREATE TABLE "inventory_items" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "sku" TEXT,
    "unitOfMeasure" TEXT NOT NULL,
    "currentStock" DECIMAL(10,4) NOT NULL DEFAULT 0,
    "minimumStock" DECIMAL(10,4) NOT NULL DEFAULT 0,
    "costPerUnit" DECIMAL(10,2) NOT NULL DEFAULT 0,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "inventory_items_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "recipe_ingredients" (
    "id" TEXT NOT NULL,
    "product_id" TEXT NOT NULL,
    "inventory_item_id" TEXT NOT NULL,
    "amount" DECIMAL(10,4) NOT NULL,

    CONSTRAINT "recipe_ingredients_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "inventory_items_sku_key" ON "inventory_items"("sku");

-- AddForeignKey
ALTER TABLE "recipe_ingredients" ADD CONSTRAINT "recipe_ingredients_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "products"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "recipe_ingredients" ADD CONSTRAINT "recipe_ingredients_inventory_item_id_fkey" FOREIGN KEY ("inventory_item_id") REFERENCES "inventory_items"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

================
File: qristal_api/prisma/migrations/20260223065237_add_shifts/migration.sql
================
-- AlterTable
ALTER TABLE "orders" ADD COLUMN     "shift_id" TEXT;

-- CreateTable
CREATE TABLE "shifts" (
    "id" TEXT NOT NULL,
    "user_id" TEXT NOT NULL,
    "opening_time" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "closing_time" TIMESTAMP(3),
    "starting_cash" DECIMAL(10,2) NOT NULL DEFAULT 0,
    "expected_cash" DECIMAL(10,2),
    "actual_cash" DECIMAL(10,2),
    "notes" TEXT,

    CONSTRAINT "shifts_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "orders" ADD CONSTRAINT "orders_shift_id_fkey" FOREIGN KEY ("shift_id") REFERENCES "shifts"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "shifts" ADD CONSTRAINT "shifts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

================
File: qristal_api/prisma/migrations/20260223142342_add_branch_id_to_all/migration.sql
================
-- AlterTable
ALTER TABLE "categories" ADD COLUMN     "branch_id" TEXT;

-- AlterTable
ALTER TABLE "inventory_items" ADD COLUMN     "branch_id" TEXT;

-- AlterTable
ALTER TABLE "products" ADD COLUMN     "branch_id" TEXT;

-- AlterTable
ALTER TABLE "seating_tables" ADD COLUMN     "branch_id" TEXT;

================
File: qristal_api/prisma/migrations/20260223143013_add_branch_id_to_all/migration.sql
================
/*
  Warnings:

  - Made the column `branch_id` on table `categories` required. This step will fail if there are existing NULL values in that column.
  - Made the column `branch_id` on table `inventory_items` required. This step will fail if there are existing NULL values in that column.
  - Made the column `branch_id` on table `products` required. This step will fail if there are existing NULL values in that column.
  - Made the column `branch_id` on table `seating_tables` required. This step will fail if there are existing NULL values in that column.

*/
-- AlterTable
ALTER TABLE "categories" ALTER COLUMN "branch_id" SET NOT NULL;

-- AlterTable
ALTER TABLE "inventory_items" ALTER COLUMN "branch_id" SET NOT NULL;

-- AlterTable
ALTER TABLE "products" ALTER COLUMN "branch_id" SET NOT NULL;

-- AlterTable
ALTER TABLE "seating_tables" ALTER COLUMN "branch_id" SET NOT NULL;

================
File: qristal_api/prisma/migrations/20260223145956_add_branch_isolation/migration.sql
================
-- DropIndex
DROP INDEX "inventory_items_sku_key";

-- AlterTable
ALTER TABLE "categories" ALTER COLUMN "branch_id" SET DEFAULT 'BRANCH-01';

-- AlterTable
ALTER TABLE "inventory_items" ALTER COLUMN "branch_id" SET DEFAULT 'BRANCH-01';

-- AlterTable
ALTER TABLE "orders" ADD COLUMN     "branch_id" TEXT NOT NULL DEFAULT 'BRANCH-01';

-- AlterTable
ALTER TABLE "products" ALTER COLUMN "branch_id" SET DEFAULT 'BRANCH-01';

-- AlterTable
ALTER TABLE "seating_tables" ALTER COLUMN "branch_id" SET DEFAULT 'BRANCH-01';

-- AlterTable
ALTER TABLE "shifts" ADD COLUMN     "branch_id" TEXT NOT NULL DEFAULT 'BRANCH-01';

================
File: qristal_api/prisma/migrations/20260223230500_add_shift_id_to_payments/migration.sql
================
-- AlterTable
ALTER TABLE "payments" ADD COLUMN "shift_id" TEXT;

-- AddForeignKey
ALTER TABLE "payments" ADD CONSTRAINT "payments_shift_id_fkey" FOREIGN KEY ("shift_id") REFERENCES "shifts"("id") ON DELETE SET NULL ON UPDATE CASCADE;

================
File: qristal_api/prisma/migrations/20260224090000_add_audit_and_sync_logs/migration.sql
================
-- CreateEnum
CREATE TYPE "AuditAction" AS ENUM ('VOID', 'DISCOUNT', 'CASH_IN', 'CASH_OUT');

-- CreateEnum
CREATE TYPE "SyncDirection" AS ENUM ('PULL', 'PUSH');

-- CreateEnum
CREATE TYPE "SyncStatus" AS ENUM ('SUCCESS', 'FAILED');

-- CreateTable
CREATE TABLE "audit_logs" (
    "id" TEXT NOT NULL,
    "branch_id" TEXT NOT NULL DEFAULT 'BRANCH-01',
    "user_id" TEXT,
    "action" "AuditAction" NOT NULL,
    "order_id" TEXT,
    "metadata" JSONB,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "audit_logs_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "sync_logs" (
    "id" TEXT NOT NULL,
    "branch_id" TEXT NOT NULL DEFAULT 'BRANCH-01',
    "direction" "SyncDirection" NOT NULL,
    "status" "SyncStatus" NOT NULL,
    "started_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "finished_at" TIMESTAMP(3),
    "records_pushed" INTEGER NOT NULL DEFAULT 0,
    "records_pulled" INTEGER NOT NULL DEFAULT 0,
    "error_message" TEXT,

    CONSTRAINT "sync_logs_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "audit_logs" ADD CONSTRAINT "audit_logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

================
File: qristal_api/prisma/migrations/20260226120000_add_order_item_routing_modifiers_sides/migration.sql
================
-- AlterTable
ALTER TABLE "order_items" ADD COLUMN "route_to" TEXT;

-- CreateTable
CREATE TABLE "order_item_modifiers" (
    "id" TEXT NOT NULL,
    "order_item_id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "price_delta" DECIMAL(10,2) NOT NULL DEFAULT 0,
    "route_to" TEXT,

    CONSTRAINT "order_item_modifiers_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "order_item_sides" (
    "id" TEXT NOT NULL,
    "order_item_id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "quantity" INTEGER NOT NULL DEFAULT 1,
    "price_delta" DECIMAL(10,2) NOT NULL DEFAULT 0,
    "route_to" TEXT,

    CONSTRAINT "order_item_sides_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "order_item_modifiers" ADD CONSTRAINT "order_item_modifiers_order_item_id_fkey" FOREIGN KEY ("order_item_id") REFERENCES "order_items"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "order_item_sides" ADD CONSTRAINT "order_item_sides_order_item_id_fkey" FOREIGN KEY ("order_item_id") REFERENCES "order_items"("id") ON DELETE CASCADE ON UPDATE CASCADE;

================
File: qristal_api/prisma/migrations/20260226132850_update_schema/migration.sql
================
/*
  Warnings:

  - Added the required column `updated_at` to the `shifts` table without a default value. This is not possible if the table is not empty.

*/
-- AlterTable
ALTER TABLE "shifts" ADD COLUMN     "updated_at" TIMESTAMP(3) NOT NULL;

================
File: qristal_api/prisma/migrations/20260226143000_add_product_customization_metadata/migration.sql
================
-- CreateEnum
CREATE TYPE "ProductionArea" AS ENUM ('KITCHEN', 'BARISTA', 'BAR', 'RETAIL', 'OTHER');

-- AlterTable
ALTER TABLE "products"
ADD COLUMN "production_area" "ProductionArea" NOT NULL DEFAULT 'KITCHEN',
ADD COLUMN "modifier_groups" TEXT[] DEFAULT ARRAY[]::TEXT[],
ADD COLUMN "sides" TEXT[] DEFAULT ARRAY[]::TEXT[];

================
File: qristal_api/prisma/migrations/20260227173450_modif/migration.sql
================
-- CreateTable
CREATE TABLE "modifier_groups" (
    "id" TEXT NOT NULL,
    "branch_id" TEXT NOT NULL DEFAULT 'BRANCH-01',
    "name" TEXT NOT NULL,
    "min_select" INTEGER NOT NULL DEFAULT 0,
    "max_select" INTEGER,
    "is_required" BOOLEAN NOT NULL DEFAULT false,
    "sort_order" INTEGER NOT NULL DEFAULT 0,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "deleted_at" TIMESTAMP(3),

    CONSTRAINT "modifier_groups_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "modifiers" (
    "id" TEXT NOT NULL,
    "modifier_group_id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "price_delta" DECIMAL(10,2) NOT NULL DEFAULT 0,
    "production_area" "ProductionArea" NOT NULL DEFAULT 'KITCHEN',
    "is_available" BOOLEAN NOT NULL DEFAULT true,
    "sort_order" INTEGER NOT NULL DEFAULT 0,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "deleted_at" TIMESTAMP(3),

    CONSTRAINT "modifiers_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "sides_library" (
    "id" TEXT NOT NULL,
    "branch_id" TEXT NOT NULL DEFAULT 'BRANCH-01',
    "name" TEXT NOT NULL,
    "price_delta" DECIMAL(10,2) NOT NULL DEFAULT 0,
    "production_area" "ProductionArea" NOT NULL DEFAULT 'KITCHEN',
    "is_available" BOOLEAN NOT NULL DEFAULT true,
    "sort_order" INTEGER NOT NULL DEFAULT 0,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "deleted_at" TIMESTAMP(3),

    CONSTRAINT "sides_library_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "product_modifier_groups" (
    "id" TEXT NOT NULL,
    "product_id" TEXT NOT NULL,
    "modifier_group_id" TEXT NOT NULL,
    "sort_order" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "product_modifier_groups_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "product_sides" (
    "id" TEXT NOT NULL,
    "product_id" TEXT NOT NULL,
    "side_id" TEXT NOT NULL,
    "sort_order" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "product_sides_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "modifier_groups_branch_id_name_key" ON "modifier_groups"("branch_id", "name");

-- CreateIndex
CREATE UNIQUE INDEX "modifiers_modifier_group_id_name_key" ON "modifiers"("modifier_group_id", "name");

-- CreateIndex
CREATE UNIQUE INDEX "sides_library_branch_id_name_key" ON "sides_library"("branch_id", "name");

-- CreateIndex
CREATE UNIQUE INDEX "product_modifier_groups_product_id_modifier_group_id_key" ON "product_modifier_groups"("product_id", "modifier_group_id");

-- CreateIndex
CREATE UNIQUE INDEX "product_sides_product_id_side_id_key" ON "product_sides"("product_id", "side_id");

-- AddForeignKey
ALTER TABLE "modifiers" ADD CONSTRAINT "modifiers_modifier_group_id_fkey" FOREIGN KEY ("modifier_group_id") REFERENCES "modifier_groups"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "product_modifier_groups" ADD CONSTRAINT "product_modifier_groups_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "products"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "product_modifier_groups" ADD CONSTRAINT "product_modifier_groups_modifier_group_id_fkey" FOREIGN KEY ("modifier_group_id") REFERENCES "modifier_groups"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "product_sides" ADD CONSTRAINT "product_sides_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "products"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "product_sides" ADD CONSTRAINT "product_sides_side_id_fkey" FOREIGN KEY ("side_id") REFERENCES "sides_library"("id") ON DELETE CASCADE ON UPDATE CASCADE;

================
File: qristal_api/prisma/migrations/migration_lock.toml
================
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"

================
File: qristal_api/prisma/schema.prisma
================
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ------------------------------------------------------
// 1. AUTH & STAFF
// ------------------------------------------------------
enum Role {
  OWNER
  MANAGER
  CASHIER
  WAITER
  KITCHEN
}

enum ProductionArea {
  KITCHEN
  BARISTA
  BAR
  RETAIL
  OTHER
}

model User {
  id       String  @id @default(uuid())
  pin      String  @unique // Hashed PIN for terminal login
  role     Role    @default(WAITER)
  fullName String  @map("full_name")
  branchId String  @map("branch_id") // Ready for Phase 3 (Multi-branch)
  isActive Boolean @default(true) @map("is_active")

  // Relations
  orders    Order[]
  shifts    Shift[]
  auditLogs AuditLog[]

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at") // Soft delete

  @@map("users")
}

// ------------------------------------------------------
// 2. MENU & PRODUCTS (Server is source of truth)
// ------------------------------------------------------
model Category {
  id        String  @id @default(uuid())
  branchId     String    @default("BRANCH-01") @map("branch_id")
  name      String
  colorHex  String? @map("color_hex") // For the POS UI (e.g., #FF5733)
  sortOrder Int     @default(0) @map("sort_order")

  products Product[]

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at") // Used by terminal to detect changes
  deletedAt DateTime? @map("deleted_at")

  @@map("categories")
}

model Product {
  id          String  @id @default(uuid())
  categoryId  String  @map("category_id")
  name        String
  price       Decimal @db.Decimal(10, 2)
  isAvailable Boolean @default(true) @map("is_available")
  productionArea ProductionArea @default(KITCHEN) @map("production_area")
  sortOrder      Int     @default(0) @map("sort_order")

  category   Category    @relation(fields: [categoryId], references: [id])
  orderItems OrderItem[]
  productModifierGroups ProductModifierGroup[]
  productSides          ProductSide[]

  branchId     String    @default("BRANCH-01") @map("branch_id")

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at") // The sync engine monitors this field heavily!
  deletedAt DateTime? @map("deleted_at")

  recipe RecipeIngredient[]

  @@map("products")
}

// ------------------------------------------------------
// 3. ORDERS (Terminals are source of truth, pushed to server)
// ------------------------------------------------------
enum OrderStatus {
  OPEN
  KITCHEN
  SERVED
  CLOSED
  VOIDED
}

model Order {
  id            String      @id @default(uuid()) // Terminals generate this UUID
  branchId      String      @default("BRANCH-01") @map("branch_id")
  receiptNumber String      @map("receipt_number") // e.g., ORD-0001
  userId        String      @map("user_id") // Waiter who took the order
  tableId       String?     @map("table_id") // Nullable for takeaway
  shiftId       String?     @map("shift_id")
  totalAmount   Decimal     @map("total_amount") @db.Decimal(10, 2)
  status        OrderStatus @default(OPEN)

  user     User        @relation(fields: [userId], references: [id])
  items    OrderItem[]
  shift    Shift?      @relation(fields: [shiftId], references: [id])
  payments Payment[]

  table SeatingTable? @relation(fields: [tableId], references: [id])

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("orders")
}

model OrderItem {
  id                 String  @id @default(uuid())
  orderId            String  @map("order_id")
  productId          String  @map("product_id")
  quantity           Int
  priceAtTimeOfOrder Decimal @map("price_at_time_of_order") @db.Decimal(10, 2) // Financial integrity
  routeTo            String? @map("route_to")
  notes              String? // e.g. "Extra spicy"

  order      Order                @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product    Product              @relation(fields: [productId], references: [id])
  modifiers  OrderItemModifier[]
  sides      OrderItemSide[]

  @@map("order_items")
}

model OrderItemModifier {
  id          String  @id @default(uuid())
  orderItemId String  @map("order_item_id")
  name        String
  priceDelta  Decimal @default(0) @map("price_delta") @db.Decimal(10, 2)
  routeTo     String? @map("route_to")

  orderItem OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Cascade)

  @@map("order_item_modifiers")
}

model OrderItemSide {
  id          String  @id @default(uuid())
  orderItemId String  @map("order_item_id")
  name        String
  quantity    Int     @default(1)
  priceDelta  Decimal @default(0) @map("price_delta") @db.Decimal(10, 2)
  routeTo     String? @map("route_to")

  orderItem OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Cascade)

  @@map("order_item_sides")
}

model ModifierGroup {
  id        String @id @default(uuid())
  branchId  String @default("BRANCH-01") @map("branch_id")
  name      String
  minSelect Int    @default(0) @map("min_select")
  maxSelect Int?   @map("max_select")
  isRequired Boolean @default(false) @map("is_required")
  sortOrder Int    @default(0) @map("sort_order")

  modifiers Modifier[]
  products  ProductModifierGroup[]

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at")

  @@unique([branchId, name])
  @@map("modifier_groups")
}

model Modifier {
  id              String  @id @default(uuid())
  modifierGroupId String  @map("modifier_group_id")
  name            String
  priceDelta      Decimal @default(0) @map("price_delta") @db.Decimal(10, 2)
  productionArea  ProductionArea @default(KITCHEN) @map("production_area")
  isAvailable     Boolean @default(true) @map("is_available")
  sortOrder       Int     @default(0) @map("sort_order")

  modifierGroup ModifierGroup @relation(fields: [modifierGroupId], references: [id], onDelete: Cascade)

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at")

  @@unique([modifierGroupId, name])
  @@map("modifiers")
}
model Side {
  id            String  @id @default(uuid())
  branchId      String  @default("BRANCH-01") @map("branch_id")
  name          String
  priceDelta    Decimal @default(0) @map("price_delta") @db.Decimal(10, 2)
  productionArea ProductionArea @default(KITCHEN) @map("production_area")
  isAvailable   Boolean @default(true) @map("is_available")
  sortOrder     Int     @default(0) @map("sort_order")

  products ProductSide[]

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at")

  @@unique([branchId, name])
  @@map("sides_library")
}

model ProductModifierGroup {
  id              String @id @default(uuid())
  productId       String @map("product_id")
  modifierGroupId String @map("modifier_group_id")
  sortOrder       Int    @default(0) @map("sort_order")

  product       Product       @relation(fields: [productId], references: [id], onDelete: Cascade)
  modifierGroup ModifierGroup @relation(fields: [modifierGroupId], references: [id], onDelete: Cascade)

  @@unique([productId, modifierGroupId])
  @@map("product_modifier_groups")
}

model ProductSide {
  id        String @id @default(uuid())
  productId String @map("product_id")
  sideId    String @map("side_id")
  sortOrder Int    @default(0) @map("sort_order")

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  side    Side    @relation(fields: [sideId], references: [id], onDelete: Cascade)

  @@unique([productId, sideId])
  @@map("product_sides")
}
enum PaymentMethod {
  CASH
  CARD
  MOBILE_MONEY
  OTHER
}

enum AuditAction {
  VOID
  DISCOUNT
  CASH_IN
  CASH_OUT
}

enum SyncDirection {
  PULL
  PUSH
}

enum SyncStatus {
  SUCCESS
  FAILED
}

model Payment {
  id        String        @id @default(uuid())
  orderId   String        @map("order_id")
  shiftId   String?       @map("shift_id")
  method    PaymentMethod
  amount    Decimal       @db.Decimal(10, 2)
  reference String? // For Mobile Money Ref / Card Auth Code
  createdAt DateTime      @default(now()) @map("created_at")

  order Order @relation(fields: [orderId], references: [id])
  shift Shift? @relation(fields: [shiftId], references: [id])

  @@map("payments")
}

model SeatingTable {
  id       String @id @default(uuid())
  branchId     String    @default("BRANCH-01") @map("branch_id")
  name     String // e.g., "T-1", "Bar-2"
  status   String @default("FREE") // FREE, OCCUPIED, RESERVED
  capacity Int    @default(4)
  floor    String @default("Main") // Main, Terrace, VIP

  // Coordinates for future Drag-n-Drop UI
  x Int @default(0)
  y Int @default(0)

  orders Order[]

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at")

  @@map("seating_tables")
}

// ------------------------------------------------------
// 4. INVENTORY & RECIPES
// ------------------------------------------------------

model InventoryItem {
  id            String  @id @default(uuid())
  branchId     String    @default("BRANCH-01") @map("branch_id")
  name          String // e.g., "Coffee Beans", "Milk", "Burger Bun"
  sku           String?
  unitOfMeasure String // e.g., "Kg", "Liters", "Pieces", "Grams"
  currentStock  Decimal @default(0) @db.Decimal(10, 4)
  minimumStock  Decimal @default(0) @db.Decimal(10, 4) // For low stock alerts
  costPerUnit   Decimal @default(0) @db.Decimal(10, 2)

  recipeIngredients RecipeIngredient[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("inventory_items")
}

// A Recipe links a Product (what you sell) to InventoryItems (what you use)
model RecipeIngredient {
  id              String @id @default(uuid())
  productId       String @map("product_id")
  inventoryItemId String @map("inventory_item_id")

  // How much of the inventory item is used to make ONE of the product
  // e.g., 1 Cappuccino uses 15 (amount) Grams (from InventoryItem unit) of Coffee Beans
  amount Decimal @db.Decimal(10, 4)

  product       Product       @relation(fields: [productId], references: [id], onDelete: Cascade)
  inventoryItem InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Restrict)

  @@map("recipe_ingredients")
}

model Shift {
  id          String    @id @default(uuid())
  branchId     String    @default("BRANCH-01") @map("branch_id")
  userId      String    @map("user_id")
  openingTime DateTime  @default(now()) @map("opening_time")
  closingTime DateTime? @map("closing_time")

  startingCash Decimal  @default(0) @map("starting_cash") @db.Decimal(10, 2)
  expectedCash Decimal? @map("expected_cash") @db.Decimal(10, 2)
  actualCash   Decimal? @map("actual_cash") @db.Decimal(10, 2)

  notes String?

  user     User      @relation(fields: [userId], references: [id])
  orders   Order[]   // A shift has many orders
  payments Payment[]

  updatedAt DateTime  @updatedAt @map("updated_at")

  @@map("shifts")
}

model AuditLog {
  id        String      @id @default(uuid())
  branchId  String      @default("BRANCH-01") @map("branch_id")
  userId    String?     @map("user_id")
  action    AuditAction
  orderId   String?     @map("order_id")
  metadata  Json?
  createdAt DateTime    @default(now()) @map("created_at")

  user User? @relation(fields: [userId], references: [id])

  @@map("audit_logs")
}

model SyncLog {
  id            String        @id @default(uuid())
  branchId      String        @default("BRANCH-01") @map("branch_id")
  direction     SyncDirection
  status        SyncStatus
  startedAt     DateTime      @default(now()) @map("started_at")
  finishedAt    DateTime?     @map("finished_at")
  recordsPushed Int           @default(0) @map("records_pushed")
  recordsPulled Int           @default(0) @map("records_pulled")
  errorMessage  String?       @map("error_message")

  @@map("sync_logs")
}

================
File: qristal_api/prisma/schema.prisma.save
================
generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
}

// ------------------------------------------------------
// 1. AUTH & STAFF
// ------------------------------------------------------
enum Role {
  OWNER
  MANAGER
  CASHIER
  WAITER
  KITCHEN
}

model User {
  id           String    @id @default(uuid())
  pin          String    @unique // Hashed PIN for terminal login
  role         Role      @default(WAITER)
  fullName     String    @map("full_name")
  branchId     String    @map("branch_id") // Ready for Phase 3 (Multi-branch)
  isActive     Boolean   @default(true) @map("is_active")
  
  // Relations
  orders       Order[]
  
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")
  deletedAt    DateTime? @map("deleted_at") // Soft delete

  @@map("users")
}

// ------------------------------------------------------
// 2. MENU & PRODUCTS (Server is source of truth)
// ------------------------------------------------------
model Category {
  id           String    @id @default(uuid())
  name         String
  colorHex     String?   @map("color_hex") // For the POS UI (e.g., #FF5733)
  sortOrder    Int       @default(0) @map("sort_order")
  
  products     Product[]

  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at") // Used by terminal to detect changes
  deletedAt    DateTime? @map("deleted_at")

  @@map("categories")
}

model Product {
  id           String    @id @default(uuid())
  categoryId   String    @map("category_id")
  name         String
  price        Decimal   @db.Decimal(10, 2)
  isAvailable  Boolean   @default(true) @map("is_available")

  category     Category  @relation(fields: [categoryId], references: [id])
  orderItems   OrderItem[]

  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at") // The sync engine monitors this field heavily!
  deletedAt    DateTime? @map("deleted_at")

  @@map("products")
}

// ------------------------------------------------------
// 3. ORDERS (Terminals are source of truth, pushed to server)
// ------------------------------------------------------
enum OrderStatus {
  OPEN
  KITCHEN
  SERVED
  CLOSED
  VOIDED
}

model Order {
  id            String      @id @default(uuid()) // Terminals generate this UUID
  receiptNumber String      @map("receipt_number") // e.g., ORD-0001
  userId        String      @map("user_id") // Waiter who took the order
  tableId       String?     @map("table_id") // Nullable for takeaway
  totalAmount   Decimal     @db.Decimal(10, 2) @map("total_amount")
  status        OrderStatus @default(OPEN)
  
  user          User        @relation(fields: [userId], references: [id])
  items         OrderItem[]

  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")

  @@map("orders")
}

model OrderItem {
  id                  String   @id @default(uuid())
  orderId             String   @map("order_id")
  productId           String   @map("product_id")
  quantity            Int
  priceAtTimeOfOrder  Decimal  @db.Decimal(10, 2) @map("price_at_time_of_order") // Financial integrity
  notes               String?  // e.g. "Extra spicy"
  
  order               Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product             Product  @relation(fields: [productId], references: [id])

  @@map("order_items")
}
x

================
File: qristal_api/prisma/seed.ts
================
import { PrismaClient } from '@prisma/client';
import * as bcrypt from 'bcrypt';

const prisma = new PrismaClient();

async function main() {
  console.log('Clearing database...');
  await prisma.orderItem.deleteMany();
  await prisma.order.deleteMany();
  await prisma.product.deleteMany();
  await prisma.category.deleteMany();
  await prisma.user.deleteMany();
  await prisma.inventoryItem.deleteMany();
  await prisma.recipeIngredient.deleteMany();
  await prisma.seatingTable.deleteMany();


  console.log('Seeding data...');

  // 1. Create a User
  const hashedPin = await bcrypt.hash('1234', 10);
  const admin = await prisma.user.create({
    data: {
      fullName: 'Admin User',
      pin: hashedPin,
      role: 'OWNER',
      branchId: 'BRANCH-01',
      isActive: true,
    },
  });

  // 2. Create Categories
  const catDrinks = await prisma.category.create({
    data: { name: 'Drinks', colorHex: '#3498db', sortOrder: 1 },
  });

  const catFood = await prisma.category.create({
    data: { name: 'Food', colorHex: '#e67e22', sortOrder: 2 },
  });

  // 3. Create Products
  await prisma.product.createMany({
    data: [
      {
        categoryId: catDrinks.id,
        name: 'Coffee',
        price: 2.50,
        isAvailable: true,
      },
      {
        categoryId: catDrinks.id,
        name: 'Soda',
        price: 1.50,
        isAvailable: true,
      },
      {
        categoryId: catFood.id,
        name: 'Burger',
        price: 8.50,
        isAvailable: true,
      },
      {
        categoryId: catFood.id,
        name: 'Fries',
        price: 3.00,
        isAvailable: true,
      },
    ],
  });

  console.log('Seeding Inventory...');
  
  const coffeeBeans = await prisma.inventoryItem.create({
    data: { name: 'Espresso Beans', unitOfMeasure: 'Grams', currentStock: 5000, costPerUnit: 0.05 }
  });

  const milk = await prisma.inventoryItem.create({
     data: { name: 'Whole Milk', unitOfMeasure: 'Liters', currentStock: 20, costPerUnit: 2000 }
  });

  const bun = await prisma.inventoryItem.create({
    data: { name: 'Brioche Bun', unitOfMeasure: 'Pieces', currentStock: 100, costPerUnit: 500 }
  });

  const beefPatty = await prisma.inventoryItem.create({
    data: { name: 'Beef Patty 150g', unitOfMeasure: 'Pieces', currentStock: 100, costPerUnit: 2500 }
  });

  console.log('Creating Recipes...');
  
  // Find the Coffee product we created earlier
  const coffee = await prisma.product.findFirst({ where: { name: 'Coffee' }});
  if (coffee) {
    await prisma.recipeIngredient.createMany({
        data: [
            { productId: coffee.id, inventoryItemId: coffeeBeans.id, amount: 18 }, // 18 grams of beans
            { productId: coffee.id, inventoryItemId: milk.id, amount: 0.2 },       // 200ml milk
        ]
    });
  }

  // Find the Burger product
  const burger = await prisma.product.findFirst({ where: { name: 'Burger' }});
  if (burger) {
    await prisma.recipeIngredient.createMany({
        data: [
            { productId: burger.id, inventoryItemId: bun.id, amount: 1 }, 
            { productId: burger.id, inventoryItemId: beefPatty.id, amount: 1 },
        ]
    });
  }
  
  console.log('Seeding Tables...');
  await prisma.seatingTable.createMany({
    data: [
      { name: 'T-01', status: 'FREE', floor: 'Main', x: 0, y: 0 },
      { name: 'T-02', status: 'FREE', floor: 'Main', x: 1, y: 0 },
      { name: 'T-03', status: 'OCCUPIED', floor: 'Main', x: 2, y: 0 }, // Mocking an active table
      { name: 'VIP-1', status: 'FREE', floor: 'VIP', x: 0, y: 1 },
    ]
  });

  console.log('Seed data created successfully!');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

================
File: qristal_api/scripts/create-main-entry.cjs
================
const { writeFileSync } = require('node:fs');
const { join } = require('node:path');

const entrypointPath = join(__dirname, '..', 'dist', 'main.js');
writeFileSync(entrypointPath, "require('./src/main.js');\n", 'utf8');
console.log(`Created ${entrypointPath}`);

================
File: qristal_api/src/auth/auth.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AuthController } from './auth.controller';

describe('AuthController', () => {
  let controller: AuthController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
    }).compile();

    controller = module.get<AuthController>(AuthController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: qristal_api/src/auth/auth.controller.ts
================
// src/auth/auth.controller.ts
import { Controller, Post, Body, UnauthorizedException } from '@nestjs/common';
import { AuthService } from './auth.service';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('login')
  async login(@Body() body: { id: string; pin: string }) {
    const user = await this.authService.validateUser(body.id, body.pin);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }
    return this.authService.login(user);
  }
}

================
File: qristal_api/src/auth/auth.module.ts
================
// src/auth/auth.module.ts
import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { JwtStrategy } from './jwt.strategy';

@Module({
  imports: [
    PassportModule,
    JwtModule.register({
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '24h' },
    }),
  ],
  providers: [AuthService, JwtStrategy],
  controllers: [AuthController],
})
export class AuthModule {}

================
File: qristal_api/src/auth/auth.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from './auth.service';

describe('AuthService', () => {
  let service: AuthService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [AuthService],
    }).compile();

    service = module.get<AuthService>(AuthService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: qristal_api/src/auth/auth.service.ts
================
// src/auth/auth.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { PrismaService } from '../prisma/prisma.service';
import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  constructor(
    private prisma: PrismaService,
    private jwtService: JwtService
  ) {}

  async validateUser(userId: string, pin: string): Promise<any> {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
    });

    if (user && (await bcrypt.compare(pin, user.pin))) {
      const { pin, ...result } = user;
      return result;
    }
    return null;
  }

  async login(user: any) {
    const payload = { sub: user.id, role: user.role, branchId: user.branchId };
    return {
      access_token: this.jwtService.sign(payload),
      user: user
    };
  }
}

================
File: qristal_api/src/auth/jwt.strategy.ts
================
// src/auth/jwt.strategy.ts
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: process.env.JWT_SECRET,
    });
  }

  async validate(payload: any) {
    // This return value is added to Request object (req.user)
    return { userId: payload.sub, role: payload.role, branchId: payload.branchId };
  }
}

================
File: qristal_api/src/events/events.gateway.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { EventsGateway } from './events.gateway';

describe('EventsGateway', () => {
  let gateway: EventsGateway;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [EventsGateway],
    }).compile();

    gateway = module.get<EventsGateway>(EventsGateway);
  });

  it('should be defined', () => {
    expect(gateway).toBeDefined();
  });
});

================
File: qristal_api/src/events/events.gateway.ts
================
import {
  WebSocketGateway,
  WebSocketServer,
  OnGatewayConnection,
  OnGatewayDisconnect,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Logger } from '@nestjs/common';

// Allow any origin for now to avoid CORS issues during dev/testing across devices
@WebSocketGateway({
  cors: {
    origin: '*',
  },
})
export class EventsGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  private logger: Logger = new Logger('EventsGateway');

  handleConnection(client: Socket) {
    this.logger.log(`Client connected: ${client.id}`);
  }

  handleDisconnect(client: Socket) {
    this.logger.log(`Client disconnected: ${client.id}`);
  }

  // --- Methods to emit events from other services ---

  // Call this when an order is received from the POS
  emitNewOrder(orderData: any) {
    this.server.emit('newOrder', orderData);
  }

  // Call this when inventory is updated
  emitInventoryUpdate(inventoryData: any) {
    this.server.emit('inventoryUpdate', inventoryData);
  }
}

================
File: qristal_api/src/events/events.module.ts
================
import { Module } from '@nestjs/common';
import { EventsGateway } from './events.gateway';

@Module({
  providers: [EventsGateway],
  exports: [EventsGateway], // Export the gateway to be used in other modules
})
export class EventsModule {}

================
File: qristal_api/src/inventory/inventory.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { InventoryController } from './inventory.controller';

describe('InventoryController', () => {
  let controller: InventoryController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [InventoryController],
    }).compile();

    controller = module.get<InventoryController>(InventoryController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: qristal_api/src/inventory/inventory.controller.ts
================
import { Controller, Get, Post, Body, Put, Patch, Param, Delete, UseGuards, Request } from '@nestjs/common';
import { InventoryService } from './inventory.service';
import { AuthGuard } from '@nestjs/passport';

@Controller('inventory')
@UseGuards(AuthGuard('jwt'))
export class InventoryController {
  constructor(private readonly inventoryService: InventoryService) {}

  @Get()
  async getInventory(@Request() req) {
    return this.inventoryService.getInventoryStatus(req.user.branchId);
  }

  @Post()
  async create(@Request() req, @Body() data: any) {
    return this.inventoryService.createInventoryItem(req.user.branchId, data);
  }

  @Patch(':id/restock')
  async restock(@Request() req, @Param('id') id: string, @Body('amount') amount: number) {
    return this.inventoryService.restockItem(id, req.user.branchId, amount);
  }

  @Put(':id')
  async update(@Request() req, @Param('id') id: string, @Body() data: any) {
    return this.inventoryService.updateInventoryItem(id, req.user.branchId, data);
  }

  @Delete(':id')
  async remove(@Request() req, @Param('id') id: string) {
    return this.inventoryService.deleteInventoryItem(id, req.user.branchId);
  }
}

================
File: qristal_api/src/inventory/inventory.module.ts
================
import { Module } from '@nestjs/common';
import { InventoryService } from './inventory.service';
import { InventoryController } from './inventory.controller';

@Module({
  controllers: [InventoryController],
  providers: [InventoryService],
  exports: [InventoryService], // <-- Crucial: Export so SyncModule can use it
})
export class InventoryModule {}

================
File: qristal_api/src/inventory/inventory.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { InventoryService } from './inventory.service';

describe('InventoryService', () => {
  let service: InventoryService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [InventoryService],
    }).compile();

    service = module.get<InventoryService>(InventoryService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: qristal_api/src/inventory/inventory.service.ts
================
import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class InventoryService {
  private readonly logger = new Logger(InventoryService.name);

  constructor(private prisma: PrismaService) {}

  

  // --- CREATE ---
  async createInventoryItem(branchId: string, data: any) {
    return this.prisma.inventoryItem.create({
      data: {
        ...data,
        branchId,
        currentStock: Number(data.currentStock || 0),
        minimumStock: Number(data.minimumStock || 0),
        costPerUnit: Number(data.costPerUnit || 0),
      },
    });
  }

  // --- RESTOCK (Increment) ---
  async restockItem(id: string, branchId: string, amount: number) {
    return this.prisma.inventoryItem.update({
      where: { id, branchId },
      data: {
        currentStock: {
          increment: Number(amount),
        },
      },
    });
  }

  // --- UPDATE ---
  async updateInventoryItem(id: string, branchId: string, data: any) {
    return this.prisma.inventoryItem.update({
      where: { id, branchId },
      data: {
        name: data.name,
        unitOfMeasure: data.unitOfMeasure,
        minimumStock: data.minimumStock ? Number(data.minimumStock) : undefined,
        costPerUnit: data.costPerUnit ? Number(data.costPerUnit) : undefined,
      },
    });
  }

  // --- DELETE ---
  async deleteInventoryItem(id: string, branchId: string) {
    return this.prisma.inventoryItem.delete({
      where: { id, branchId },
    });
  }


  /**
   * Processes inventory deductions for a given order.
   * This should be called after an order is successfully synced from the POS.
   */
  async deductStockForOrder(orderId: string) {
    try {
      // 1. Fetch the order and its items
      const order = await this.prisma.order.findUnique({
        where: { id: orderId },
        include: { items: true },
      });

      if (!order) {
        this.logger.error(`Order ${orderId} not found for inventory deduction.`);
        return;
      }

      this.logger.log(`Processing inventory for Order: ${order.receiptNumber}`);

      // 2. Loop through each item in the order
      for (const orderItem of order.items) {
        
        // 3. Find the recipe for this product
        const recipeIngredients = await this.prisma.recipeIngredient.findMany({
          where: { productId: orderItem.productId },
        });

        if (recipeIngredients.length === 0) {
            // It's a product without a recipe (maybe a retail item), skip deduction or handle retail logic.
            continue; 
        }

        // 4. Calculate total deduction and update inventory
        for (const ingredient of recipeIngredients) {
            // quantity ordered * amount needed per item
            const totalDeduction = Number(orderItem.quantity) * Number(ingredient.amount);

            await this.prisma.inventoryItem.update({
                where: { id: ingredient.inventoryItemId },
                data: {
                    currentStock: {
                        decrement: totalDeduction
                    }
                }
            });

            this.logger.debug(`Deducted ${totalDeduction} from InventoryItem ${ingredient.inventoryItemId}`);
        }
      }
    } catch (error) {
        this.logger.error(`Failed to deduct inventory for order ${orderId}: ${error.message}`);
    }
  }

   // --- READ ---
   async getInventoryStatus(branchId: string) {
    return this.prisma.inventoryItem.findMany({
      where: { branchId },
      orderBy: { currentStock: 'asc' }, // Lowest stock first
    });
  }
}

================
File: qristal_api/src/menu/categories.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { CategoriesController } from './categories.controller';

describe('CategoriesController', () => {
  let controller: CategoriesController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [CategoriesController],
    }).compile();

    controller = module.get<CategoriesController>(CategoriesController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: qristal_api/src/menu/categories.controller.ts
================
import { Controller, Get, Post, Body, Put, Param, Delete, UseGuards, Request } from '@nestjs/common';
import { MenuService } from './menu.service';
import { AuthGuard } from '@nestjs/passport';

@Controller('categories')
@UseGuards(AuthGuard('jwt'))
export class CategoriesController {
  constructor(private readonly menuService: MenuService) {}

  @Get()
  findAll(@Request() req) { return this.menuService.getCategories(req.user.branchId); }

  @Post()
  create(@Request() req, @Body() data: any) { return this.menuService.createCategory(req.user.branchId, data); }

  @Put(':id')
  update(@Request() req, @Param('id') id: string, @Body() data: any) { return this.menuService.updateCategory(id, req.user.branchId, data); }

  @Delete(':id')
  remove(@Request() req, @Param('id') id: string) { return this.menuService.deleteCategory(id, req.user.branchId); }
}

================
File: qristal_api/src/menu/menu.module.ts
================
import { Module } from '@nestjs/common';
import { CategoriesController } from './categories.controller';
import { ProductsController } from './products.controller';
import { MenuService } from './menu.service';
import { ModifierGroupsController } from './modifier-groups.controller';
import { SidesController } from './sides.controller';

@Module({
  controllers: [CategoriesController, ProductsController, ModifierGroupsController, SidesController],
  providers: [MenuService]
})
export class MenuModule {}

================
File: qristal_api/src/menu/menu.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { PrismaService } from '../prisma/prisma.service';
import { MenuService } from './menu.service';

describe('MenuService', () => {
  let service: MenuService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        MenuService,
        {
          provide: PrismaService,
          useValue: {
            category: {
              findMany: jest.fn(),
              create: jest.fn(),
              update: jest.fn(),
              delete: jest.fn(),
            },
            product: {
              findMany: jest.fn(),
              create: jest.fn(),
              update: jest.fn(),
              delete: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    service = module.get<MenuService>(MenuService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: qristal_api/src/menu/menu.service.ts
================
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class MenuService {
  constructor(private prisma: PrismaService) { }

  // --- CATEGORIES ---
  getCategories(branchId: string) {
    return this.prisma.category.findMany({ where: { branchId }, orderBy: { sortOrder: 'asc' } });
  }
  createCategory(branchId: string, data: any) {
    return this.prisma.category.create({ data: { ...data, branchId } });
  }
  updateCategory(id: string, branchId: string, data: any) {
    return this.prisma.category.update({ where: { id, branchId }, data });
  }
  deleteCategory(id: string, branchId: string) {
    return this.prisma.category.delete({ where: { id, branchId } });
  }

  // --- PRODUCTS ---
  getProducts(branchId: string) {
    return this.prisma.product.findMany({
      where: { branchId, deletedAt: null },
      include: {
        category: true,
        // productModifierGroups: { include: { modifierGroup: { include: { modifiers: true } } } },
        // productSides: { include: { side: true } },
      },
      orderBy: [{ sortOrder: 'asc' }, { name: 'asc' }],
    });
  }

  createProduct(branchId: string, data: any) {
    const { categoryId, modifierGroupIds, sideIds, ...rest } = data;
    return this.prisma.product.create({
      data: {
        ...rest,
        branchId,
        category: { connect: { id: categoryId } },
        productModifierGroups: {
          create: modifierGroupIds?.map((id: string, index: number) => ({
            modifierGroup: { connect: { id } },
            sortOrder: index,
          })),
        },
        productSides: {
          create: sideIds?.map((id: string, index: number) => ({
            side: { connect: { id } },
            sortOrder: index,
          })),
        },
      },
    });
  }

  updateProduct(id: string, branchId: string, data: any) {
    const { categoryId, modifierGroupIds, sideIds, ...rest } = data;
    return this.prisma.product.update({
      where: { id, branchId },
      data: {
        ...rest,
        category: categoryId ? { connect: { id: categoryId } } : undefined,
        productModifierGroups: modifierGroupIds
          ? {
              deleteMany: {},
              create: modifierGroupIds.map((id: string, index: number) => ({
                modifierGroup: { connect: { id } },
                sortOrder: index,
              })),
            }
          : undefined,
        productSides: sideIds
          ? {
              deleteMany: {},
              create: sideIds.map((id: string, index: number) => ({
                side: { connect: { id } },
                sortOrder: index,
              })),
            }
          : undefined,
      },
    });
  }

  deleteProduct(id: string, branchId: string) {
    return this.prisma.product.update({
      where: { id, branchId },
      data: { deletedAt: new Date() },
    });
  }

  // --- MODIFIER GROUPS ---
  getModifierGroups(branchId: string) {
    return this.prisma.modifierGroup.findMany({
      where: { branchId, deletedAt: null },
      include: {
        modifiers: {
          where: { deletedAt: null },
          orderBy: { sortOrder: 'asc' },
        },
      },
      orderBy: [{ sortOrder: 'asc' }, { name: 'asc' }],
    });
  }

  createModifierGroup(branchId: string, data: any) {
    return this.prisma.modifierGroup.create({
      data: {
        branchId,
        name: String(data.name || '').trim(),
        minSelect: Number(data.minSelect || 0),
        maxSelect: data.maxSelect == null || data.maxSelect === '' ? null : Number(data.maxSelect),
        isRequired: Boolean(data.isRequired),
        sortOrder: Number(data.sortOrder || 0),
      },
    });
  }

  updateModifierGroup(id: string, _branchId: string, data: any) {
    return this.prisma.modifierGroup.update({
      where: { id },
      data: {
        name: data.name,
        minSelect: data.minSelect == null ? undefined : Number(data.minSelect),
        maxSelect: data.maxSelect == null || data.maxSelect === '' ? null : Number(data.maxSelect),
        isRequired: typeof data.isRequired === 'boolean' ? data.isRequired : undefined,
        sortOrder: data.sortOrder == null ? undefined : Number(data.sortOrder),
      },
    });
  }

  deleteModifierGroup(id: string, _branchId: string) {
    return this.prisma.modifierGroup.update({
      where: { id },
      data: { deletedAt: new Date() },
    });
  }

  createModifier(modifierGroupId: string, _branchId: string, data: any) {
    return this.prisma.modifier.create({
      data: {
        modifierGroup: { connect: { id: modifierGroupId } },
        name: String(data.name || '').trim(),
        priceDelta: Number(data.priceDelta || 0),
        productionArea: data.productionArea || 'KITCHEN',
        isAvailable: data.isAvailable == null ? true : Boolean(data.isAvailable),
        sortOrder: Number(data.sortOrder || 0),
      },
    });
  }

  updateModifier(id: string, modifierGroupId: string, _branchId: string, data: any) {
    return this.prisma.modifier.update({
      where: { id },
      data: {
        name: data.name,
        priceDelta: data.priceDelta == null ? undefined : Number(data.priceDelta),
        productionArea: data.productionArea,
        isAvailable: typeof data.isAvailable === 'boolean' ? data.isAvailable : undefined,
        sortOrder: data.sortOrder == null ? undefined : Number(data.sortOrder),
      },
    });
  }

  deleteModifier(id: string, modifierGroupId: string, _branchId: string) {
    return this.prisma.modifier.update({
      where: { id },
      data: { deletedAt: new Date() },
    });
  }

  // --- SIDES LIBRARY ---
  getSides(branchId: string) {
    return this.prisma.side.findMany({
      where: { branchId, deletedAt: null },
      orderBy: [{ sortOrder: 'asc' }, { name: 'asc' }],
    });
  }

  createSide(branchId: string, data: any) {
    return this.prisma.side.create({
      data: {
        branchId,
        name: String(data.name || '').trim(),
        priceDelta: Number(data.priceDelta || 0),
        productionArea: data.productionArea || 'KITCHEN',
        isAvailable: data.isAvailable == null ? true : Boolean(data.isAvailable),
        sortOrder: Number(data.sortOrder || 0),
      },
    });
  }

  updateSide(id: string, _branchId: string, data: any) {
    return this.prisma.side.update({
      where: { id },
      data: {
        name: data.name,
        priceDelta: data.priceDelta == null ? undefined : Number(data.priceDelta),
        productionArea: data.productionArea,
        isAvailable: typeof data.isAvailable === 'boolean' ? data.isAvailable : undefined,
        sortOrder: data.sortOrder == null ? undefined : Number(data.sortOrder),
      },
    });
  }

  deleteSide(id: string, _branchId: string) {
    return this.prisma.side.update({
      where: { id },
      data: { deletedAt: new Date() },
    });
  }
}

================
File: qristal_api/src/menu/modifier-groups.controller.ts
================
import { Body, Controller, Delete, Get, Param, Patch, Post, Request, UseGuards } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { MenuService } from './menu.service';

@Controller('modifier-groups')
@UseGuards(AuthGuard('jwt'))
export class ModifierGroupsController {
  constructor(private readonly menuService: MenuService) {}

  @Get()
  findAll(@Request() req) {
    return this.menuService.getModifierGroups(req.user.branchId);
  }

  @Post()
  create(@Request() req, @Body() data: any) {
    return this.menuService.createModifierGroup(req.user.branchId, data);
  }

  @Patch(':id')
  update(@Request() req, @Param('id') id: string, @Body() data: any) {
    return this.menuService.updateModifierGroup(id, req.user.branchId, data);
  }

  @Delete(':id')
  remove(@Request() req, @Param('id') id: string) {
    return this.menuService.deleteModifierGroup(id, req.user.branchId);
  }

  @Post(':id/modifiers')
  createModifier(@Request() req, @Param('id') modifierGroupId: string, @Body() data: any) {
    return this.menuService.createModifier(modifierGroupId, req.user.branchId, data);
  }

  @Patch(':groupId/modifiers/:modifierId')
  updateModifier(
    @Request() req,
    @Param('groupId') modifierGroupId: string,
    @Param('modifierId') modifierId: string,
    @Body() data: any,
  ) {
    return this.menuService.updateModifier(modifierId, modifierGroupId, req.user.branchId, data);
  }

  @Delete(':groupId/modifiers/:modifierId')
  removeModifier(
    @Request() req,
    @Param('groupId') modifierGroupId: string,
    @Param('modifierId') modifierId: string,
  ) {
    return this.menuService.deleteModifier(modifierId, modifierGroupId, req.user.branchId);
  }
}

================
File: qristal_api/src/menu/product.dto.spec.ts
================
import { BadRequestException } from '@nestjs/common';
import {
  sanitizeCreateProductInput,
  sanitizeUpdateProductInput,
} from './product.dto';

describe('product dto sanitizers', () => {
  it('sanitizes create payload including modifier metadata', () => {
    const data = sanitizeCreateProductInput({
      name: 'Latte',
      price: '12000',
      categoryId: 'cat-1',
      productionArea: 'BARISTA',
      modifierGroups: ['Shots', 'Strength', 'Shots'],
      sides: ['Cookie'],
    });

    expect(data.name).toBe('Latte');
    expect(data.price).toBe(12000);
    expect(data.productionArea).toBe('BARISTA');
    expect(data.modifierGroups).toEqual(['Shots', 'Strength']);
    expect(data.sides).toEqual(['Cookie']);
  });

  it('rejects invalid production area on update payload', () => {
    expect(() =>
      sanitizeUpdateProductInput({ productionArea: 'INVALID' }),
    ).toThrow(BadRequestException);
  });
});

================
File: qristal_api/src/menu/product.dto.ts
================
import { BadRequestException } from '@nestjs/common';
import { Prisma } from '@prisma/client';

export type ProductProductionArea = 'KITCHEN' | 'BARISTA' | 'BAR' | 'RETAIL' | 'OTHER';

const PRODUCTION_AREAS: ProductProductionArea[] = [
  'KITCHEN',
  'BARISTA',
  'BAR',
  'RETAIL',
  'OTHER',
];

const toStringArray = (value: unknown, field: string): string[] => {
  if (value == null) return [];
  if (!Array.isArray(value)) {
    throw new BadRequestException(`${field} must be an array of strings.`);
  }

  return Array.from(
    new Set(
      value
        .map((entry) => (typeof entry === 'string' ? entry.trim() : ''))
        .filter(Boolean),
    ),
  );
};

const toIdArray = (value: unknown, field: string): string[] => {
  const items = toStringArray(value, field);
  for (const id of items) {
    if (id.length < 8) {
      throw new BadRequestException(`${field} must contain valid ids.`);
    }
  }
  return items;
};

const toProductionArea = (value: unknown): ProductProductionArea => {
  if (typeof value !== 'string' || !PRODUCTION_AREAS.includes(value as ProductProductionArea)) {
    throw new BadRequestException(
      `productionArea must be one of: ${PRODUCTION_AREAS.join(', ')}`,
    );
  }

  return value as ProductProductionArea;
};

export const sanitizeCreateProductInput = (payload: unknown): Prisma.ProductCreateInput => {
  if (!payload || typeof payload !== 'object') {
    throw new BadRequestException('Invalid payload.');
  }

  const data = payload as Record<string, unknown>;
  if (typeof data.name !== 'string' || !data.name.trim()) {
    throw new BadRequestException('name is required.');
  }

  const parsedPrice = Number(data.price);
  if (!Number.isFinite(parsedPrice) || parsedPrice <= 0) {
    throw new BadRequestException('price must be a positive number.');
  }

  if (typeof data.categoryId !== 'string' || !data.categoryId.trim()) {
    throw new BadRequestException('categoryId is required.');
  }

  const modifierGroupIds = toIdArray(data.modifierGroupIds, 'modifierGroupIds');
  const sideIds = toIdArray(data.sideIds, 'sideIds');

  return {
    name: data.name.trim(),
    price: parsedPrice,
    category: { connect: { id: data.categoryId } },
    isAvailable: typeof data.isAvailable === 'boolean' ? data.isAvailable : true,
    productionArea: data.productionArea
      ? (toProductionArea(data.productionArea) as never)
      : ('KITCHEN' as never),
    productModifierGroups:
      modifierGroupIds.length > 0
        ? {
            create: modifierGroupIds.map((modifierGroupId) => ({
              modifierGroup: { connect: { id: modifierGroupId } },
            })),
          }
        : undefined,
    productSides:
      sideIds.length > 0
        ? {
            create: sideIds.map((sideId) => ({
              side: { connect: { id: sideId } },
            })),
          }
        : undefined,
  };
};

export const sanitizeUpdateProductInput = (payload: unknown): Prisma.ProductUpdateInput => {
  if (!payload || typeof payload !== 'object') {
    throw new BadRequestException('Invalid payload.');
  }

  const data = payload as Record<string, unknown>;
  const update: Prisma.ProductUpdateInput = {};

  if ('name' in data) {
    if (typeof data.name !== 'string' || !data.name.trim()) {
      throw new BadRequestException('name must be a non-empty string.');
    }
    update.name = data.name.trim();
  }

  if ('price' in data) {
    const parsedPrice = Number(data.price);
    if (!Number.isFinite(parsedPrice) || parsedPrice <= 0) {
      throw new BadRequestException('price must be a positive number.');
    }
    update.price = parsedPrice;
  }

  if ('categoryId' in data) {
    if (typeof data.categoryId !== 'string' || !data.categoryId.trim()) {
      throw new BadRequestException('categoryId must be a valid string.');
    }
    update.category = { connect: { id: data.categoryId } };
  }

  if ('isAvailable' in data) {
    if (typeof data.isAvailable !== 'boolean') {
      throw new BadRequestException('isAvailable must be a boolean.');
    }
    update.isAvailable = data.isAvailable;
  }

  if ('productionArea' in data) {
    update.productionArea = toProductionArea(data.productionArea) as never;
  }

  if ('modifierGroupIds' in data) {
    const modifierGroupIds = toIdArray(data.modifierGroupIds, 'modifierGroupIds');
    update.productModifierGroups = {
      deleteMany: {},
      create: modifierGroupIds.map((modifierGroupId) => ({
        modifierGroup: { connect: { id: modifierGroupId } },
      })),
    };
  }

  if ('sideIds' in data) {
    const sideIds = toIdArray(data.sideIds, 'sideIds');
    update.productSides = {
      deleteMany: {},
      create: sideIds.map((sideId) => ({
        side: { connect: { id: sideId } },
      })),
    };
  }

  return update;
};

================
File: qristal_api/src/menu/products.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { ProductsController } from './products.controller';
import { MenuService } from './menu.service';

describe('ProductsController', () => {
  let controller: ProductsController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [ProductsController],
      providers: [
        {
          provide: MenuService,
          useValue: {
            getProducts: jest.fn(),
            createProduct: jest.fn(),
            updateProduct: jest.fn(),
            deleteProduct: jest.fn(),
          },
        },
      ],
    }).compile();

    controller = module.get<ProductsController>(ProductsController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: qristal_api/src/menu/products.controller.ts
================
import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  Patch,
  Put,
  Post,
  Request,
  UseGuards,
} from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { MenuService } from './menu.service';
import {
  sanitizeCreateProductInput,
  sanitizeUpdateProductInput,
} from './product.dto';

@Controller('products')
@UseGuards(AuthGuard('jwt'))
export class ProductsController {
  constructor(private readonly menuService: MenuService) {}

  @Get()
  findAll(@Request() req) {
    return this.menuService.getProducts(req.user.branchId);
  }

  @Post()
  create(@Request() req, @Body() payload: unknown) {
    const data = sanitizeCreateProductInput(payload);
    return this.menuService.createProduct(req.user.branchId, data);
  }

  @Patch(':id')
  update(@Request() req, @Param('id') id: string, @Body() payload: unknown) {
    const data = sanitizeUpdateProductInput(payload);
    return this.menuService.updateProduct(id, req.user.branchId, data);
  }


  @Put(':id')
  replace(@Request() req, @Param('id') id: string, @Body() payload: unknown) {
    const data = sanitizeUpdateProductInput(payload);
    return this.menuService.updateProduct(id, req.user.branchId, data);
  }

  @Delete(':id')
  remove(@Request() req, @Param('id') id: string) {
    return this.menuService.deleteProduct(id, req.user.branchId);
  }
}

================
File: qristal_api/src/menu/sides.controller.ts
================
import { Body, Controller, Delete, Get, Param, Patch, Post, Request, UseGuards } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { MenuService } from './menu.service';

@Controller('sides')
@UseGuards(AuthGuard('jwt'))
export class SidesController {
  constructor(private readonly menuService: MenuService) {}

  @Get()
  findAll(@Request() req) {
    return this.menuService.getSides(req.user.branchId);
  }

  @Post()
  create(@Request() req, @Body() data: any) {
    return this.menuService.createSide(req.user.branchId, data);
  }

  @Patch(':id')
  update(@Request() req, @Param('id') id: string, @Body() data: any) {
    return this.menuService.updateSide(id, req.user.branchId, data);
  }

  @Delete(':id')
  remove(@Request() req, @Param('id') id: string) {
    return this.menuService.deleteSide(id, req.user.branchId);
  }
}

================
File: qristal_api/src/prisma/prisma.module.ts
================
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global() // Makes PrismaService available everywhere without importing the module
@Module({
    providers: [PrismaService],
    exports: [PrismaService],
})
export class PrismaModule {}

================
File: qristal_api/src/prisma/prisma.service.ts
================
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient, Prisma } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
    
    // Add Middleware to enforce Soft Delete logic globally
    this.$use(async (params, next) => {
      if (params.model == 'User' || params.model == 'Product' || params.model == 'Category') {
        if (params.action == 'delete') {
          // Change delete to update
          params.action = 'update';
          params.args['data'] = { deletedAt: new Date() };
        }
        if (params.action == 'deleteMany') {
          // Change deleteMany to updateMany
          params.action = 'updateMany';
          if (params.args.data != undefined) {
            params.args.data['deletedAt'] = new Date();
          } else {
            params.args['data'] = { deletedAt: new Date() };
          }
        }
        
        // Filter out deleted items on find
        if (params.action === 'findUnique' || params.action === 'findFirst') {
          // Change to findFirst - you cannot filter by deletedAt on findUnique
          params.action = 'findFirst';
          params.args.where['deletedAt'] = null;
        }
        if (params.action === 'findMany') {
          if (params.args.where) {
            if (params.args.where.deletedAt == undefined) {
              params.args.where['deletedAt'] = null;
            }
          } else {
            params.args['where'] = { deletedAt: null };
          }
        }
      }
      return next(params);
    });
  }
}

================
File: qristal_api/src/reports/reports.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { ReportsController } from './reports.controller';

describe('ReportsController', () => {
  let controller: ReportsController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [ReportsController],
    }).compile();

    controller = module.get<ReportsController>(ReportsController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: qristal_api/src/reports/reports.controller.ts
================
import { Controller, Get, Query, Request, UseGuards } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { ReportsService } from './reports.service';

@Controller('reports')
@UseGuards(AuthGuard('jwt'))
export class ReportsController {
  constructor(private readonly reportsService: ReportsService) {}

  @Get('sales')
  async getSales(@Request() req, @Query('start') start: string, @Query('end') end: string) {
    const startDate = start ? new Date(start) : new Date(new Date().setDate(new Date().getDate() - 30)); // Default 30 days
    const endDate = end ? new Date(end) : new Date();
    
    return this.reportsService.getSalesHistory(req.user.branchId, startDate, endDate);
  }

  @Get('top-items')
  async getTopItems(@Request() req) {
    return this.reportsService.getTopSellingItems(req.user.branchId);
  }
  
  @Get('payments')
  async getPayments(@Request() req) {
    return this.reportsService.getPaymentSummary(req.user.branchId);
  }
}

================
File: qristal_api/src/reports/reports.module.ts
================
import { Module } from '@nestjs/common';
import { ReportsService } from './reports.service';
import { ReportsController } from './reports.controller';

@Module({
  providers: [ReportsService],
  controllers: [ReportsController]
})
export class ReportsModule {}

================
File: qristal_api/src/reports/reports.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { ReportsService } from './reports.service';

describe('ReportsService', () => {
  let service: ReportsService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [ReportsService],
    }).compile();

    service = module.get<ReportsService>(ReportsService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: qristal_api/src/reports/reports.service.ts
================
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class ReportsService {
  constructor(private prisma: PrismaService) {}

  // 1. Sales Over Time (for charts)
  async getSalesHistory(branchId: string, startDate: Date, endDate: Date) {
    // Group by day using raw SQL for performance and date truncation
    // Note: This SQL syntax is specific to PostgreSQL
    const sales = await this.prisma.$queryRaw`
      SELECT 
        DATE_TRUNC('day', created_at) as date,
        SUM(total_amount) as total
      FROM orders
      WHERE branch_id = ${branchId}
        AND status = 'CLOSED'
        AND created_at BETWEEN ${startDate} AND ${endDate}
      GROUP BY DATE_TRUNC('day', created_at)
      ORDER BY date ASC;
    `;
    
    // Serialize bigints if any, though decimal usually comes as string/number
    return JSON.parse(JSON.stringify(sales, (key, value) =>
        typeof value === 'bigint' ? value.toString() : value
    ));
  }

  // 2. Top Selling Items
  async getTopSellingItems(branchId: string) {
    // Basic aggregation
    const result = await this.prisma.orderItem.groupBy({
      by: ['productId'],
      _sum: { quantity: true },
      where: {
        order: {
          branchId: branchId,
          status: 'CLOSED'
        }
      },
      orderBy: {
        _sum: { quantity: 'desc' }
      },
      take: 5
    });

    // Fetch product names for the IDs
    const enriched = await Promise.all(result.map(async (item) => {
        const product = await this.prisma.product.findUnique({ where: { id: item.productId }});
        return {
            name: product?.name || 'Unknown',
            quantity: item._sum.quantity
        };
    }));

    return enriched;
  }

  // 3. Payment Methods Breakdown
  async getPaymentSummary(branchId: string) {
    return this.prisma.payment.groupBy({
        by: ['method'],
        _sum: { amount: true },
        where: {
            order: { branchId: branchId }
        }
    });
  }
}

================
File: qristal_api/src/seating/seating.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { SeatingController } from './seating.controller';

describe('SeatingController', () => {
  let controller: SeatingController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [SeatingController],
    }).compile();

    controller = module.get<SeatingController>(SeatingController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: qristal_api/src/seating/seating.controller.ts
================
import { Controller, Get, Post, Body, Put, Param, Delete, UseGuards, Request } from '@nestjs/common';
import { SeatingService } from './seating.service';
import { AuthGuard } from '@nestjs/passport';

@Controller('tables') // Endpoints will be /tables
@UseGuards(AuthGuard('jwt'))
export class SeatingController {
  constructor(private readonly seatingService: SeatingService) {}

  @Get()
  findAll(@Request() req) { return this.seatingService.findAll(req.user.branchId); }

  @Post()
  create(@Request() req, @Body() data: any) { return this.seatingService.create(req.user.branchId, data); }

  @Put(':id')
  update(@Request() req, @Param('id') id: string, @Body() data: any) { return this.seatingService.update(id, req.user.branchId, data); }

  @Delete(':id')
  remove(@Request() req, @Param('id') id: string) { return this.seatingService.remove(id, req.user.branchId); }
}

================
File: qristal_api/src/seating/seating.module.ts
================
import { Module } from '@nestjs/common';
import { SeatingController } from './seating.controller';
import { SeatingService } from './seating.service';

@Module({
  controllers: [SeatingController],
  providers: [SeatingService]
})
export class SeatingModule {}

================
File: qristal_api/src/seating/seating.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { SeatingService } from './seating.service';

describe('SeatingService', () => {
  let service: SeatingService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [SeatingService],
    }).compile();

    service = module.get<SeatingService>(SeatingService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: qristal_api/src/seating/seating.service.ts
================
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class SeatingService {
  constructor(private prisma: PrismaService) {}

  findAll(branchId: string) {
    return this.prisma.seatingTable.findMany({ where: { branchId }, orderBy: { name: 'asc' } });
  }

  create(branchId: string, data: any) {
    return this.prisma.seatingTable.create({ data: { ...data, branchId, isSynced: true } });
  }

  update(id: string, branchId: string, data: any) {
    return this.prisma.seatingTable.update({ where: { id, branchId }, data: { ...data, isSynced: true } });
  }

  remove(id: string, branchId: string) {
    return this.prisma.seatingTable.delete({ where: { id, branchId } });
  }
}

================
File: qristal_api/src/sync/sync.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { SyncController } from './sync.controller';
import { SyncService } from './sync.service';

describe('SyncController', () => {
  let controller: SyncController;

  const syncServiceMock = {
    pullChanges: jest.fn(),
    pushChanges: jest.fn(),
    getSyncLogsOverview: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [SyncController],
      providers: [{ provide: SyncService, useValue: syncServiceMock }],
    }).compile();

    controller = module.get<SyncController>(SyncController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  it('delegates logs overview request to service with branch context', async () => {
    syncServiceMock.getSyncLogsOverview.mockResolvedValueOnce({ summary: {} });

    await controller.getLogs('25', { user: { branchId: 'BRANCH-01' } });

    expect(syncServiceMock.getSyncLogsOverview).toHaveBeenCalledWith(
      'BRANCH-01',
      '25',
    );
  });
});

================
File: qristal_api/src/sync/sync.controller.ts
================
// src/sync/sync.controller.ts
import {
  Controller,
  Get,
  Post,
  Body,
  Query,
  UseGuards,
  Request,
} from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { SyncService } from './sync.service';

@Controller('sync')
@UseGuards(AuthGuard('jwt'))
export class SyncController {
  constructor(private readonly syncService: SyncService) {}

  @Get('pull')
  async pull(
    @Query('lastSyncTimestamp') lastSyncTimestamp: string,
    @Request() req,
  ) {
    return this.syncService.pullChanges(lastSyncTimestamp, req.user.branchId);
  }

  @Post('push')
  async push(@Body() payload: any, @Request() req) {
    return this.syncService.pushChanges(payload, req.user.branchId);
  }

  @Get('logs')
  async getLogs(@Query('limit') limit: string, @Request() req) {
    return this.syncService.getSyncLogsOverview(req.user.branchId, limit);
  }
}

================
File: qristal_api/src/sync/sync.module.ts
================
import { Module } from '@nestjs/common';
import { SyncService } from './sync.service';
import { SyncController } from './sync.controller';
import { EventsModule } from '../events/events.module'; // Import the module
import { InventoryModule } from '../inventory/inventory.module'; // Also need this for deductStockForOrder

@Module({
  imports: [
    EventsModule,    // <-- Import EventsModule here
    InventoryModule  // <-- Import InventoryModule here
  ],
  controllers: [SyncController],
  providers: [SyncService],
})
export class SyncModule {}

================
File: qristal_api/src/sync/sync.service.spec.ts
================
import { BadRequestException } from '@nestjs/common';
import { Test, TestingModule } from '@nestjs/testing';
import { SyncDirection, SyncStatus } from '@prisma/client';
import { EventsGateway } from '../events/events.gateway';
import { InventoryService } from '../inventory/inventory.service';
import { PrismaService } from '../prisma/prisma.service';
import { SyncService } from './sync.service';

describe('SyncService', () => {
  let service: SyncService;
  let prisma: {
    $transaction: jest.Mock;
    syncLog: { create: jest.Mock; findMany: jest.Mock };
    category: { findMany: jest.Mock };
    product: { findMany: jest.Mock };
    user: { findMany: jest.Mock };
    seatingTable: { findMany: jest.Mock };
    order: { findMany: jest.Mock };
    orderItem: { findMany: jest.Mock };
    orderItemModifier: { findMany: jest.Mock };
    orderItemSide: { findMany: jest.Mock };
    shift: { findMany: jest.Mock };
  };

  beforeEach(async () => {
    prisma = {
      $transaction: jest.fn(),
      syncLog: { create: jest.fn(), findMany: jest.fn() },
      category: { findMany: jest.fn() },
      product: { findMany: jest.fn() },
      user: { findMany: jest.fn() },
      seatingTable: { findMany: jest.fn() },
      order: { findMany: jest.fn() },
      orderItem: { findMany: jest.fn() },
      orderItemModifier: { findMany: jest.fn() },
      orderItemSide: { findMany: jest.fn() },
      shift: { findMany: jest.fn() },
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        SyncService,
        { provide: PrismaService, useValue: prisma },
        {
          provide: InventoryService,
          useValue: {
            deductStockForOrder: jest.fn().mockResolvedValue(undefined),
            getInventoryStatus: jest.fn().mockResolvedValue([]),
          },
        },
        {
          provide: EventsGateway,
          useValue: {
            emitNewOrder: jest.fn(),
            emitInventoryUpdate: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get<SyncService>(SyncService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('returns sync logs overview with success rates', async () => {
    prisma.syncLog.findMany.mockResolvedValueOnce([
      { direction: SyncDirection.PUSH, status: SyncStatus.SUCCESS },
      { direction: SyncDirection.PUSH, status: SyncStatus.FAILED },
      { direction: SyncDirection.PULL, status: SyncStatus.SUCCESS },
    ]);

    const result = await service.getSyncLogsOverview('BRANCH-01', '1000');

    expect(prisma.syncLog.findMany).toHaveBeenCalledWith({
      where: { branchId: 'BRANCH-01' },
      orderBy: { startedAt: 'desc' },
      take: 200,
    });
    expect(result.summary.push).toEqual({
      total: 2,
      success: 1,
      failed: 1,
      successRate: 50,
    });
    expect(result.summary.pull).toEqual({
      total: 1,
      success: 1,
      failed: 0,
      successRate: 100,
    });
  });

  it('throws on invalid timestamp', async () => {
    await expect(service.pullChanges('not-a-date', 'BRANCH-01')).rejects.toThrow(
      BadRequestException,
    );
  });

  it('logs successful pull syncs', async () => {
    prisma.category.findMany.mockResolvedValueOnce([{ id: 'c1' }]);
    prisma.product.findMany.mockResolvedValueOnce([{ id: 'p1' }]);
    prisma.user.findMany.mockResolvedValueOnce([{ id: 'u1' }]);
    prisma.seatingTable.findMany.mockResolvedValueOnce([{ id: 't1' }]);
    prisma.order.findMany.mockResolvedValueOnce([{ id: 'o1' }]);
    prisma.orderItem.findMany.mockResolvedValueOnce([{ id: 'oi1' }]);
    prisma.orderItemModifier.findMany.mockResolvedValueOnce([{ id: 'm1' }]);
    prisma.orderItemSide.findMany.mockResolvedValueOnce([{ id: 's1' }]);
    prisma.shift.findMany.mockResolvedValueOnce([{ id: 'sh1' }]);

    await service.pullChanges('', 'BRANCH-01');

    expect(prisma.syncLog.create).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          direction: SyncDirection.PULL,
          status: SyncStatus.SUCCESS,
          branchId: 'BRANCH-01',
          recordsPulled: 9,
        }),
      }),
    );
  });

  it('returns unsuccessful push response when item processing has errors', async () => {
    prisma.$transaction.mockImplementationOnce(async (handler: any) => {
      const tx = {
        shift: { upsert: jest.fn() },
        order: {
          findUnique: jest.fn().mockResolvedValue(null),
          upsert: jest.fn().mockResolvedValue({ id: 'order-1' }),
        },
        orderItem: {
          upsert: jest.fn().mockRejectedValue(new Error('item failed')),
        },
        orderItemModifier: { upsert: jest.fn() },
        orderItemSide: { upsert: jest.fn() },
        payment: { create: jest.fn() },
        auditLog: { create: jest.fn() },
      };

      await handler(tx);
    });

    const result = await service.pushChanges(
      {
        orders: [
          {
            id: 'order-1',
            receiptNumber: 'ORD-1',
            userId: 'user-1',
            tableId: null,
            shiftId: null,
            totalAmount: 40,
            status: 'OPEN',
            createdAt: new Date().toISOString(),
          },
        ],
        orderItems: [
          {
            id: 'item-1',
            orderId: 'order-1',
            productId: 'product-1',
            quantity: 1,
            priceAtTimeOfOrder: 40,
          },
        ],
      },
      'BRANCH-01',
    );

    expect(result.success).toBe(false);
    expect(result.processedOrders).toBe(1);
    expect(result.errors).toBeDefined();
    expect(prisma.syncLog.create).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          direction: SyncDirection.PUSH,
          status: SyncStatus.FAILED,
          branchId: 'BRANCH-01',
          recordsPushed: 1,
        }),
      }),
    );
  });

  it('ignores duplicate payment and audit log records without failing push', async () => {
    prisma.$transaction.mockImplementationOnce(async (handler: any) => {
      const tx = {
        shift: { upsert: jest.fn() },
        order: {
          findUnique: jest.fn().mockResolvedValue({ id: 'order-1' }),
          upsert: jest.fn().mockResolvedValue({ id: 'order-1' }),
        },
        orderItem: { upsert: jest.fn() },
        orderItemModifier: { upsert: jest.fn() },
        orderItemSide: { upsert: jest.fn() },
        payment: { create: jest.fn().mockRejectedValue({ code: 'P2002' }) },
        auditLog: { create: jest.fn().mockRejectedValue({ code: 'P2002' }) },
      };

      await handler(tx);
    });

    const result = await service.pushChanges(
      {
        orders: [
          {
            id: 'order-1',
            receiptNumber: 'ORD-1',
            userId: 'user-1',
            tableId: null,
            shiftId: null,
            totalAmount: 40,
            status: 'OPEN',
            createdAt: new Date().toISOString(),
          },
        ],
        payments: [
          {
            id: 'payment-1',
            orderId: 'order-1',
            method: 'CASH',
            amount: 40,
            shiftId: 'shift-1',
            createdAt: new Date().toISOString(),
          },
        ],
        auditLogs: [
          {
            id: 'audit-1',
            userId: 'user-1',
            action: 'VOID',
          },
        ],
      },
      'BRANCH-01',
    );

    expect(result.success).toBe(true);
    expect(result.errors).toBeUndefined();
    expect(prisma.syncLog.create).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          direction: SyncDirection.PUSH,
          status: SyncStatus.SUCCESS,
          branchId: 'BRANCH-01',
          recordsPushed: 1,
        }),
      }),
    );
  });

  it('does not fail pull when sync log persistence fails', async () => {
    prisma.category.findMany.mockResolvedValueOnce([]);
    prisma.product.findMany.mockResolvedValueOnce([]);
    prisma.user.findMany.mockResolvedValueOnce([]);
    prisma.seatingTable.findMany.mockResolvedValueOnce([]);
    prisma.order.findMany.mockResolvedValueOnce([]);
    prisma.orderItem.findMany.mockResolvedValueOnce([]);
    prisma.orderItemModifier.findMany.mockResolvedValueOnce([]);
    prisma.orderItemSide.findMany.mockResolvedValueOnce([]);
    prisma.shift.findMany.mockResolvedValueOnce([]);
    prisma.syncLog.create.mockRejectedValueOnce(new Error('sync log table unavailable'));

    const result = await service.pullChanges('', 'BRANCH-01');

    expect(result.changes).toBeDefined();
  });

  it('does not fail push when sync log persistence fails', async () => {
    prisma.$transaction.mockImplementationOnce(async (handler: any) => {
      const tx = {
        shift: { upsert: jest.fn() },
        order: {
          findUnique: jest.fn().mockResolvedValue({ id: 'order-1' }),
          upsert: jest.fn().mockResolvedValue({ id: 'order-1' }),
        },
        orderItem: { upsert: jest.fn() },
        orderItemModifier: { upsert: jest.fn() },
        orderItemSide: { upsert: jest.fn() },
        payment: { create: jest.fn() },
        auditLog: { create: jest.fn() },
      };

      await handler(tx);
    });
    prisma.syncLog.create.mockRejectedValueOnce(new Error('sync log table unavailable'));

    const result = await service.pushChanges(
      {
        orders: [
          {
            id: 'order-1',
            receiptNumber: 'ORD-1',
            userId: 'user-1',
            tableId: null,
            shiftId: null,
            totalAmount: 40,
            status: 'OPEN',
            createdAt: new Date().toISOString(),
          },
        ],
      },
      'BRANCH-01',
    );

    expect(result.success).toBe(true);
  });

  it('maps payment.shiftId from related order when payment payload omits it', async () => {
    const paymentCreate = jest.fn();
    prisma.$transaction.mockImplementationOnce(async (handler: any) => {
      const tx = {
        shift: { upsert: jest.fn() },
        order: {
          findUnique: jest.fn().mockResolvedValue(null),
          upsert: jest.fn().mockResolvedValue({ id: 'order-1' }),
        },
        orderItem: { upsert: jest.fn() },
        payment: { create: paymentCreate },
        auditLog: { create: jest.fn() },
      };

      await handler(tx);
    });

    await service.pushChanges(
      {
        orders: [
          {
            id: 'order-1',
            receiptNumber: 'ORD-1',
            userId: 'user-1',
            tableId: null,
            shiftId: 'shift-1',
            totalAmount: 40,
            status: 'OPEN',
            createdAt: new Date().toISOString(),
          },
        ],
        payments: [
          {
            id: 'payment-1',
            orderId: 'order-1',
            method: 'CASH',
            amount: 40,
            createdAt: new Date().toISOString(),
          },
        ],
      },
      'BRANCH-01',
    );

    expect(paymentCreate).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          shiftId: 'shift-1',
        }),
      }),
    );
  });


  it('persists routeTo, modifiers, and sides for order items', async () => {
    const orderItemUpsert = jest.fn();
    const modifierUpsert = jest.fn();
    const sideUpsert = jest.fn();

    prisma.$transaction.mockImplementationOnce(async (handler: any) => {
      const tx = {
        shift: { upsert: jest.fn() },
        order: {
          findUnique: jest.fn().mockResolvedValue({ id: 'order-1' }),
          upsert: jest.fn().mockResolvedValue({ id: 'order-1' }),
        },
        orderItem: { upsert: orderItemUpsert },
        orderItemModifier: { upsert: modifierUpsert },
        orderItemSide: { upsert: sideUpsert },
        payment: { create: jest.fn() },
        auditLog: { create: jest.fn() },
      };

      await handler(tx);
    });

    const result = await service.pushChanges(
      {
        orders: [
          {
            id: 'order-1',
            receiptNumber: 'ORD-1',
            userId: 'user-1',
            tableId: null,
            shiftId: 'shift-1',
            totalAmount: 45,
            status: 'OPEN',
            createdAt: new Date().toISOString(),
          },
        ],
        orderItems: [
          {
            id: 'item-1',
            orderId: 'order-1',
            productId: 'product-1',
            quantity: 1,
            priceAtTimeOfOrder: 40,
            routeTo: 'GRILL',
            notes: 'No onions',
          },
        ],
        orderItemModifiers: [
          {
            id: 'mod-1',
            orderItemId: 'item-1',
            name: 'Extra Cheese',
            priceDelta: 3,
            routeTo: 'GRILL',
          },
        ],
        orderItemSides: [
          {
            id: 'side-1',
            orderItemId: 'item-1',
            name: 'Fries',
            quantity: 1,
            priceDelta: 2,
            routeTo: 'FRYER',
          },
        ],
      },
      'BRANCH-01',
    );

    expect(result.success).toBe(true);
    expect(orderItemUpsert).toHaveBeenCalledWith(
      expect.objectContaining({
        update: expect.objectContaining({ routeTo: 'GRILL' }),
        create: expect.objectContaining({ routeTo: 'GRILL' }),
      }),
    );
    expect(modifierUpsert).toHaveBeenCalled();
    expect(sideUpsert).toHaveBeenCalled();
  });

  it('fails payment processing when shiftId cannot be resolved', async () => {
    const paymentCreate = jest.fn();
    prisma.$transaction.mockImplementationOnce(async (handler: any) => {
      const tx = {
        shift: { upsert: jest.fn() },
        order: {
          findUnique: jest
            .fn()
            .mockResolvedValueOnce({ id: 'order-1' })
            .mockResolvedValueOnce({ shiftId: null }),
          upsert: jest.fn().mockResolvedValue({ id: 'order-1' }),
        },
        orderItem: { upsert: jest.fn() },
        payment: { create: paymentCreate },
        auditLog: { create: jest.fn() },
      };

      await handler(tx);
    });

    const result = await service.pushChanges(
      {
        orders: [
          {
            id: 'order-1',
            receiptNumber: 'ORD-1',
            userId: 'user-1',
            tableId: null,
            shiftId: null,
            totalAmount: 40,
            status: 'OPEN',
            createdAt: new Date().toISOString(),
          },
        ],
        payments: [
          {
            id: 'payment-1',
            orderId: 'order-1',
            method: 'CASH',
            amount: 40,
            createdAt: new Date().toISOString(),
          },
        ],
      },
      'BRANCH-01',
    );

    expect(paymentCreate).not.toHaveBeenCalled();
    expect(result.success).toBe(false);
    expect(result.errors).toEqual(
      expect.arrayContaining([
        expect.objectContaining({
          id: 'payment-1',
          error: expect.stringContaining('shiftId is required'),
        }),
      ]),
    );
  });

});

================
File: qristal_api/src/sync/sync.service.ts
================
import { Injectable, BadRequestException, Logger } from '@nestjs/common';
import { Order, Prisma, SyncDirection, SyncStatus } from '@prisma/client';
import { PrismaService } from '../prisma/prisma.service';
import { EventsGateway } from '../events/events.gateway';
import { InventoryService } from '../inventory/inventory.service';

@Injectable()
export class SyncService {
  private readonly logger = new Logger(SyncService.name);

  constructor(
    private prisma: PrismaService,
    private inventoryService: InventoryService,
    private eventsGateway: EventsGateway,
  ) {}

  private getErrorMessage(error: unknown): string {
    if (error instanceof Error) {
      return error.message;
    }

    if (typeof error === 'string') {
      return error;
    }

    return 'Unknown error';
  }

  private isUniqueConstraintError(error: unknown): boolean {
    if (!error || typeof error !== 'object') {
      return false;
    }

    return 'code' in error && (error as { code?: string }).code === 'P2002';
  }

  private async writeSyncLogSafely(data: Prisma.SyncLogCreateInput): Promise<void> {
    try {
      await this.prisma.syncLog.create({ data });
    } catch (error) {
      this.logger.error(`Failed to persist sync log: ${this.getErrorMessage(error)}`);
    }
  }



  async getSyncLogsOverview(branchId: string, limit?: string) {
    const parsedLimit = Number(limit);
    const normalizedLimit = Number.isFinite(parsedLimit)
      ? Math.min(Math.max(Math.floor(parsedLimit), 1), 200)
      : 50;

    const logs = await this.prisma.syncLog.findMany({
      where: { branchId },
      orderBy: { startedAt: 'desc' },
      take: normalizedLimit,
    });

    const summary = logs.reduce(
      (acc, log) => {
        const key = log.direction === SyncDirection.PUSH ? 'push' : 'pull';
        acc[key].total += 1;

        if (log.status === SyncStatus.SUCCESS) {
          acc[key].success += 1;
        } else {
          acc[key].failed += 1;
        }

        return acc;
      },
      {
        push: { total: 0, success: 0, failed: 0 },
        pull: { total: 0, success: 0, failed: 0 },
      },
    );

    return {
      branchId,
      limit: normalizedLimit,
      summary: {
        push: {
          ...summary.push,
          successRate:
            summary.push.total > 0
              ? Number(((summary.push.success / summary.push.total) * 100).toFixed(2))
              : 0,
        },
        pull: {
          ...summary.pull,
          successRate:
            summary.pull.total > 0
              ? Number(((summary.pull.success / summary.pull.total) * 100).toFixed(2))
              : 0,
        },
      },
      logs,
    };
  }

  async pullChanges(lastSyncTimestamp: string, branchId: string) {
    let lastSyncDate: Date;

    if (!lastSyncTimestamp) {
      lastSyncDate = new Date(0);
    } else {
      lastSyncDate = new Date(lastSyncTimestamp);
      if (isNaN(lastSyncDate.getTime())) {
        throw new BadRequestException('Invalid lastSyncTimestamp format.');
      }
    }

    try {
      const [categories, products, users, seatingTables, orders, orderItems, orderItemModifiers, orderItemSides, shifts] = await Promise.all([
        this.prisma.category.findMany({
          where: {
            updatedAt: { gt: lastSyncDate },
            branchId,
          },
        }),
        this.prisma.product.findMany({
          where: {
            updatedAt: { gt: lastSyncDate },
            branchId,
          },
        }),
        this.prisma.user.findMany({
          where: {
            updatedAt: { gt: lastSyncDate },
            branchId,
          },
          select: {
            id: true,
            fullName: true,
            role: true,
            branchId: true,
            isActive: true,
          },
        }),
        this.prisma.seatingTable.findMany({
          where: {
            updatedAt: { gt: lastSyncDate },
            branchId,
          },
        }),
        this.prisma.order.findMany({
          where: {
            updatedAt: { gt: lastSyncDate },
            branchId,
          },
        }),
        this.prisma.orderItem.findMany({
          where: {
            order: { branchId },
          },
        }),
        this.prisma.orderItemModifier.findMany({
          where: {
            orderItem: {
              order: { branchId },
            },
          },
        }),
        this.prisma.orderItemSide.findMany({
          where: {
            orderItem: {
              order: { branchId },
            },
          },
        }),
        this.prisma.shift.findMany({
          where: {
            updatedAt: { gt: lastSyncDate },
            branchId,
          }
        })
      ]);

      const recordsPulled =
        categories.length +
        products.length +
        users.length +
        seatingTables.length +
        orders.length +
        orderItems.length +
        orderItemModifiers.length +
        orderItemSides.length +
        shifts.length;

      await this.writeSyncLogSafely({
        branchId,
        direction: SyncDirection.PULL,
        status: SyncStatus.SUCCESS,
        recordsPulled,
        finishedAt: new Date(),
      });

      return {
        timestamp: new Date().toISOString(),
        changes: {
          categories,
          products,
          users,
          seatingTables,
          orders,
          orderItems,
          orderItemModifiers,
          orderItemSides,
          shifts,
        },
      };
    } catch (error) {
      await this.writeSyncLogSafely({
        branchId,
        direction: SyncDirection.PULL,
        status: SyncStatus.FAILED,
        errorMessage: this.getErrorMessage(error),
        finishedAt: new Date(),
      });
      throw error;
    }
  }

  async pushChanges(payload: any, userBranchId: string) {
    this.logger.log('Received pushChanges payload');
    const { orders, orderItems, orderItemModifiers, orderItemSides, payments, shifts, auditLogs } = payload;
    const errors: { id: any; error: string }[] = [];
    const orderShiftMap = new Map<string, string | null>();

    let processedOrders = 0;
    let processedShifts = 0;
    let processedAuditLogs = 0;

    const newOrderIdsToDeduct: string[] = [];
    const newlyCreatedOrdersForKDS: Order[] = [];

    try {
      await this.prisma.$transaction(async (tx) => {
        if (shifts && Array.isArray(shifts)) {
          for (const shift of shifts) {
            try {
              await tx.shift.upsert({
                where: { id: shift.id },
                update: {
                  closingTime: shift.closingTime ? new Date(shift.closingTime) : null,
                  expectedCash: shift.expectedCash,
                  actualCash: shift.actualCash,
                  notes: shift.notes,
                },
                create: {
                  id: shift.id,
                  userId: shift.userId,
                  openingTime: new Date(shift.openingTime),
                  closingTime: shift.closingTime ? new Date(shift.closingTime) : null,
                  startingCash: shift.startingCash,
                  expectedCash: shift.expectedCash,
                  actualCash: shift.actualCash,
                  notes: shift.notes,
                  branchId: userBranchId,
                },
              });
              processedShifts++;
            } catch (err) {
              errors.push({ id: shift.id, error: `Shift error: ${this.getErrorMessage(err)}` });
            }
          }
        }

        if (orders && Array.isArray(orders)) {
          for (const order of orders) {
            let resolvedShiftId = order.shiftId;
            if (!resolvedShiftId) {
              const activeShift = await tx.shift.findFirst({
                where: {
                  userId: order.userId,
                  branchId: userBranchId,
                  closingTime: null,
                },
                orderBy: { openingTime: 'desc' },
              });
              if (activeShift) {
                resolvedShiftId = activeShift.id;
              }
            }

            orderShiftMap.set(order.id, resolvedShiftId ?? null);

            try {
              const existing = await tx.order.findUnique({ where: { id: order.id } });
              const savedOrder = await tx.order.upsert({
                where: { id: order.id },
                update: {
                  status: order.status,
                  totalAmount: order.totalAmount,
                  updatedAt: new Date(),
                  shiftId: resolvedShiftId,
                },
                create: {
                  id: order.id,
                  receiptNumber: order.receiptNumber,
                  userId: order.userId,
                  tableId: order.tableId,
                  shiftId: resolvedShiftId,
                  totalAmount: order.totalAmount,
                  status: order.status,
                  createdAt: new Date(order.createdAt),
                  branchId: userBranchId,
                },
              });
              processedOrders++;
              if (!existing) {
                newOrderIdsToDeduct.push(order.id);
                newlyCreatedOrdersForKDS.push(savedOrder);
              }
            } catch (err) {
              errors.push({ id: order.id, error: `Order error: ${this.getErrorMessage(err)}` });
            }
          }
        }

        if (orderItems && Array.isArray(orderItems)) {
          for (const item of orderItems) {
            try {
              await tx.orderItem.upsert({
                where: { id: item.id },
                update: {
                  quantity: item.quantity,
                  routeTo: item.routeTo,
                  notes: item.notes,
                },
                create: {
                  id: item.id,
                  orderId: item.orderId,
                  productId: item.productId,
                  quantity: item.quantity,
                  priceAtTimeOfOrder: item.priceAtTimeOfOrder,
                  routeTo: item.routeTo,
                  notes: item.notes,
                },
              });
            } catch (err) {
              errors.push({ id: item.id, error: `Item error: ${this.getErrorMessage(err)}` });
            }
          }
        }

        if (orderItemModifiers && Array.isArray(orderItemModifiers)) {
          for (const modifier of orderItemModifiers) {
            try {
              await tx.orderItemModifier.upsert({
                where: { id: modifier.id },
                update: {
                  name: modifier.name,
                  priceDelta: modifier.priceDelta,
                  routeTo: modifier.routeTo,
                },
                create: {
                  id: modifier.id,
                  orderItemId: modifier.orderItemId,
                  name: modifier.name,
                  priceDelta: modifier.priceDelta,
                  routeTo: modifier.routeTo,
                },
              });
            } catch (err) {
              errors.push({
                id: modifier.id,
                error: `Modifier error: ${this.getErrorMessage(err)}`,
              });
            }
          }
        }

        if (orderItemSides && Array.isArray(orderItemSides)) {
          for (const side of orderItemSides) {
            try {
              await tx.orderItemSide.upsert({
                where: { id: side.id },
                update: {
                  name: side.name,
                  quantity: side.quantity,
                  priceDelta: side.priceDelta,
                  routeTo: side.routeTo,
                },
                create: {
                  id: side.id,
                  orderItemId: side.orderItemId,
                  name: side.name,
                  quantity: side.quantity,
                  priceDelta: side.priceDelta,
                  routeTo: side.routeTo,
                },
              });
            } catch (err) {
              errors.push({ id: side.id, error: `Side error: ${this.getErrorMessage(err)}` });
            }
          }
        }


        if (payments && Array.isArray(payments)) {
          for (const pay of payments) {
            try {
              let resolvedShiftId = pay.shiftId ?? orderShiftMap.get(pay.orderId) ?? null;

              if (!resolvedShiftId) {
                const existingOrder = await tx.order.findUnique({
                  where: { id: pay.orderId },
                  select: { shiftId: true, userId: true },
                });

                if (existingOrder) {
                  resolvedShiftId = existingOrder.shiftId;
                  if (!resolvedShiftId) {
                    const activeShift = await tx.shift.findFirst({
                      where: {
                        userId: existingOrder.userId,
                        branchId: userBranchId,
                        closingTime: null,
                      },
                      orderBy: { openingTime: 'desc' },
                    });

                    if (activeShift) {
                      resolvedShiftId = activeShift.id;
                      // Update the order with the found shiftId for future consistency
                      await tx.order.update({
                        where: { id: pay.orderId },
                        data: { shiftId: resolvedShiftId },
                      });
                    }
                  }
                }
              }

              if (!resolvedShiftId) {
                errors.push({
                  id: pay.id,
                  error:
                    'Payment error: shiftId is required. Provide payment.shiftId or sync order with a shiftId first.',
                });
                continue;
              }

              await tx.payment.create({
                data: {
                  id: pay.id,
                  orderId: pay.orderId,
                  method: pay.method,
                  amount: pay.amount,
                  reference: pay.reference,
                  shiftId: resolvedShiftId,
                  createdAt: new Date(pay.createdAt),
                },
              });
            } catch (err) {
              if (!this.isUniqueConstraintError(err)) {
                const errorMessage = this.getErrorMessage(err);
                errors.push({ id: pay.id, error: `Payment error: ${errorMessage}` });
              }
            }
          }
        }

        if (auditLogs && Array.isArray(auditLogs)) {
          for (const log of auditLogs) {
            try {
              await tx.auditLog.create({
                data: {
                  id: log.id,
                  branchId: userBranchId,
                  userId: log.userId,
                  action: log.action,
                  orderId: log.orderId,
                  metadata: (log.metadata ?? undefined) as Prisma.InputJsonValue,
                  createdAt: log.createdAt ? new Date(log.createdAt) : new Date(),
                },
              });
              processedAuditLogs++;
            } catch (err) {
              if (!this.isUniqueConstraintError(err)) {
                const errorMessage = this.getErrorMessage(err);
                errors.push({ id: log.id, error: `Audit log error: ${errorMessage}` });
              }
            }
          }
        }
      });

      for (const orderId of newOrderIdsToDeduct) {
        this.inventoryService.deductStockForOrder(orderId).catch((e: unknown) =>
          this.logger.error(`Inventory deduction failed async: ${this.getErrorMessage(e)}`),
        );
      }

      if (newlyCreatedOrdersForKDS.length > 0) {
        this.eventsGateway.emitNewOrder({ message: 'New orders arrived!' });
      }

      if (newOrderIdsToDeduct.length > 0) {
        setTimeout(async () => {
          try {
            const latestInventory = await this.inventoryService.getInventoryStatus(
              userBranchId,
            );
            this.eventsGateway.emitInventoryUpdate(latestInventory);
          } catch (e) {
            this.logger.error(
              `Failed to emit inventory update: ${this.getErrorMessage(e)}`,
            );
          }
        }, 1000);
      }

      const recordsPushed = processedOrders + processedShifts + processedAuditLogs;
      const wasSuccessful = errors.length === 0;

      await this.writeSyncLogSafely({
        branchId: userBranchId,
        direction: SyncDirection.PUSH,
        status: wasSuccessful ? SyncStatus.SUCCESS : SyncStatus.FAILED,
        recordsPushed,
        errorMessage: wasSuccessful ? null : JSON.stringify(errors),
        finishedAt: new Date(),
      });

      return {
        success: wasSuccessful,
        processedOrders,
        processedShifts,
        processedAuditLogs,
        errors: errors.length > 0 ? errors : undefined,
      };
    } catch (error) {
      await this.writeSyncLogSafely({
        branchId: userBranchId,
        direction: SyncDirection.PUSH,
        status: SyncStatus.FAILED,
        errorMessage: this.getErrorMessage(error),
        finishedAt: new Date(),
      });

      throw new BadRequestException(`Push sync failed: ${this.getErrorMessage(error)}`);
    }
  }
}

================
File: qristal_api/src/users/users.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { UsersController } from './users.controller';

describe('UsersController', () => {
  let controller: UsersController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [UsersController],
    }).compile();

    controller = module.get<UsersController>(UsersController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: qristal_api/src/users/users.controller.ts
================
import { Controller, Get, Post, Body, Put, Param, Delete, UseGuards, Request } from '@nestjs/common';
import { UsersService } from './users.service';
import { AuthGuard } from '@nestjs/passport';

@Controller('users')
@UseGuards(AuthGuard('jwt'))
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get()
  findAll(@Request() req) {
    return this.usersService.findAll(req.user.branchId);
  }

  @Post()
  create(@Request() req, @Body() data: any) {
    return this.usersService.create(req.user.branchId, data);
  }

  @Put(':id')
  update(@Request() req, @Param('id') id: string, @Body() data: any) {
    return this.usersService.update(id, req.user.branchId, data);
  }

  @Delete(':id')
  remove(@Request() req, @Param('id') id: string) {
    return this.usersService.remove(id, req.user.branchId);
  }
}

================
File: qristal_api/src/users/users.module.ts
================
import { Module } from '@nestjs/common';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

@Module({
  controllers: [UsersController],
  providers: [UsersService]
})
export class UsersModule {}

================
File: qristal_api/src/users/users.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { UsersService } from './users.service';

describe('UsersService', () => {
  let service: UsersService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [UsersService],
    }).compile();

    service = module.get<UsersService>(UsersService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: qristal_api/src/users/users.service.ts
================
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import * as bcrypt from 'bcrypt';
import { Role } from '@prisma/client';

@Injectable()
export class UsersService {
  constructor(private prisma: PrismaService) {}

  async findAll(branchId: string) {
    return this.prisma.user.findMany({
      where: { branchId },
      select: { id: true, fullName: true, role: true, isActive: true, createdAt: true }, // Exclude PIN
    });
  }

  async create(branchId: string, data: { fullName: string; pin: string; role: Role }) {
    const hashedPin = await bcrypt.hash(data.pin, 10);
    return this.prisma.user.create({
      data: {
        ...data,
        pin: hashedPin,
        branchId,
      },
      select: { id: true, fullName: true, role: true }, // Return safe info
    });
  }

  async update(
    id: string,
    branchId: string,
    data: { fullName?: string; pin?: string; role?: Role; isActive?: boolean },
  ) {
    const { pin, ...rest } = data;
    const updateData: any = rest;

    if (pin) {
      updateData.pin = await bcrypt.hash(pin, 10);
    }

    return this.prisma.user.update({
      where: { id, branchId },
      data: updateData,
      select: { id: true, fullName: true, role: true, isActive: true },
    });
  }

  async remove(id: string, branchId: string) {
    return this.prisma.user.delete({ where: { id, branchId } });
  }
}

================
File: qristal_api/src/app.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});

================
File: qristal_api/src/app.controller.ts
================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

================
File: qristal_api/src/app.module.ts
================
import { Module } from '@nestjs/common';
import { PrismaModule } from './prisma/prisma.module';
import { AuthModule } from './auth/auth.module';
import { SyncModule } from './sync/sync.module';
import { InventoryModule } from './inventory/inventory.module';
import { EventsModule } from './events/events.module';
import { ReportsModule } from './reports/reports.module';
import { UsersModule } from './users/users.module';    
import { MenuModule } from './menu/menu.module';       
import { SeatingModule } from './seating/seating.module'; 

@Module({
  imports: [
    PrismaModule, 
    SyncModule, 
    AuthModule, 
    InventoryModule, 
    EventsModule, 
    ReportsModule,
    UsersModule, 
    MenuModule, 
    SeatingModule
  ],
})
export class AppModule { }

================
File: qristal_api/src/app.service.ts
================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

================
File: qristal_api/src/main.ts
================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Enable CORS so your Flutter Web/Mobile can talk to it
  app.enableCors(); 
  
  // Listen on 0.0.0.0 to accept external connections in Docker/Railway
  await app.listen(process.env.PORT || 3000, '0.0.0.0');
  
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();

================
File: qristal_api/test/app.e2e-spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import request from 'supertest';
import { App } from 'supertest/types';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication<App>;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});

================
File: qristal_api/test/jest-e2e.json
================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}

================
File: qristal_api/.git
================
gitdir: ../.git/modules/qristal_api

================
File: qristal_api/.gitignore
================
# compiled output
/dist
/node_modules
/build

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

/generated/prisma

================
File: qristal_api/.prettierrc
================
{
  "singleQuote": true,
  "trailingComma": "all"
}

================
File: qristal_api/.repomixignore
================
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

================
File: qristal_api/docker-compose.yaml
================
version: '3.8'
services:
  postgres:
    image: postgres:15-alpine
    restart: always
    environment:
      POSTGRES_USER: qristal_user
      POSTGRES_PASSWORD: qristal_password
      POSTGRES_DB: qristal_db
    ports:
      - '5432:5432'
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:

================
File: qristal_api/eslint.config.mjs
================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      sourceType: 'commonjs',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'warn',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      "prettier/prettier": ["error", { endOfLine: "auto" }],
    },
  },
);

================
File: qristal_api/nest-cli.json
================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}

================
File: qristal_api/package.json
================
{
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  },
  "name": "qristal-api",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build && node scripts/create-main-entry.cjs",
    "postinstall": "npx prisma generate",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "dependencies": {
    "@nestjs/cli": "^11.0.0",
    "@nestjs/common": "^11.0.1",
    "@nestjs/core": "^11.0.1",
    "@nestjs/jwt": "^11.0.2",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^11.0.1",
    "@nestjs/platform-socket.io": "^11.1.14",
    "@nestjs/swagger": "^11.2.6",
    "@nestjs/websockets": "^11.1.14",
    "@prisma/client": "^5.22.0",
    "bcrypt": "^6.0.0",
    "passport-jwt": "^4.0.1",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "socket.io": "^4.8.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@prisma/config": "^7.4.1",
    "@types/bcrypt": "^6.0.0",
    "@types/express": "^5.0.0",
    "@types/jest": "^30.0.0",
    "@types/node": "^22.10.7",
    "@types/supertest": "^6.0.2",
    "dotenv": "^17.3.1",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^30.0.0",
    "prettier": "^3.4.2",
    "prisma": "^5.22.0",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

================
File: qristal_api/prisma.config.ts
================
import "dotenv/config";
import { defineConfig, env } from "@prisma/config";

export default defineConfig({
  schema: "prisma/schema.prisma",
  datasource: {
    url: env("DATABASE_URL"),
  },
});

================
File: qristal_api/README.md
================
# Qristal API

The backend REST API and WebSocket gateway for the Qristal POS system. Built with [NestJS](https://nestjs.com), [Prisma](https://www.prisma.io), and PostgreSQL.

Developed and maintained by **[Truthy Systems](https://truthysystems.com)**.

---

## Tech Stack

- **Framework:** NestJS (TypeScript)
- **Database:** PostgreSQL via Prisma ORM
- **Auth:** JWT + PIN-based authentication
- **Real-time:** WebSocket gateway (Socket.io)
- **Containerisation:** Docker Compose

---

## Features

- JWT authentication with PIN-based staff login
- Role-based access control (Owner, Manager, Cashier, Waiter, Kitchen)
- Menu & product management (categories, products, modifiers, sides, production area routing)
- Order lifecycle management (Open  Kitchen  Served  Closed / Voided)
- Payment recording (Cash, Card, Mobile Money)
- Seating & floor plan management
- Shift management with cash reconciliation
- Inventory tracking with recipe-based ingredient deduction
- Offline sync  pull changes and push unsynced data from mobile terminals
- Audit logging (voids, discounts, cash in/out)
- Multi-branch data isolation

---

## Prerequisites

- Node.js 20+
- PostgreSQL database (local or hosted  e.g. Supabase, Railway, Render)
- npm

---

## Setup

### 1. Install dependencies

```bash
npm install
```

### 2. Configure environment

Create a `.env` file in the project root:

```env
DATABASE_URL="postgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=public"
DIRECT_URL="postgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=public"
JWT_SECRET="your-secret-key"
```

### 3. Run database migrations

```bash
npx prisma migrate deploy
```

### 4. (Optional) Seed the database

```bash
npx ts-node prisma/seed.ts
```

---

## Running the Server

```bash
# Development
npm run start:dev

# Production
npm run start:prod
```

The API will be available at `http://localhost:3000` by default.

---

## Running with Docker

```bash
docker-compose up
```

---

## Running Tests

```bash
# Unit tests
npm run test

# End-to-end tests
npm run test:e2e

# Coverage
npm run test:cov
```

---

## API Modules

| Module | Description |
|--------|-------------|
| `auth` | PIN login, JWT issuance |
| `users` | Staff management |
| `menu` | Categories & products |
| `inventory` | Stock items & recipe ingredients |
| `seating` | Tables & floor plans |
| `reports` | Sales and shift reporting |
| `sync` | Push/pull sync for offline mobile terminals |
| `events` | WebSocket real-time gateway |

---

## Database Schema

Managed via Prisma. Key models:

- **User**  staff with role, PIN, and branch assignment
- **Category / Product**  menu items with modifiers, sides, and production area
- **Order / OrderItem**  with modifier and side line items, kitchen routing
- **Payment**  linked to orders and shifts
- **SeatingTable**  floor plan with status
- **Shift**  cash drawer open/close with reconciliation
- **InventoryItem / RecipeIngredient**  stock tracking
- **AuditLog / SyncLog**  traceability and sync history

---

## Developer

Built by **[Truthy Systems](https://truthysystems.com)**.

================
File: qristal_api/repomix.config.json
================
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output.txt",
    "style": "plain",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "includeFullDirectoryStructure": false,
    "tokenCountTree": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false,
      "includeLogs": false,
      "includeLogsCount": 50
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDotIgnore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}

================
File: qristal_api/tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

================
File: qristal_api/tsconfig.json
================
{
  "compilerOptions": {
    "module": "nodenext",
    "moduleResolution": "nodenext",
    "resolvePackageJsonExports": true,
    "esModuleInterop": true,
    "isolatedModules": true,
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false
  }
}

================
File: qristal_dashboard/src/app/admin/analytics/page.tsx
================
"use client";

import { useAuth } from "@/context/AuthContext";
import { useEffect, useMemo, useState } from "react";
import {
  Area,
  AreaChart,
  Bar,
  BarChart,
  CartesianGrid,
  Cell,
  Legend,
  Pie,
  PieChart,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
} from "recharts";

const SERVER_URL = "https://qristal-pos-api.onrender.com";
const REFRESH_MS = 12000;
const COLORS = ["#2563eb", "#10b981", "#f59e0b", "#ef4444", "#8b5cf6"];

type SalesDataPoint = { date: string; total: number };
type TopItem = { name: string; quantity: number };
type PaymentPoint = { method: string; _sum: { amount: number } };
type InventoryItem = { id: string; currentStock: number; minimumStock: number };

export default function AnalyticsPage() {
  const { token } = useAuth();
  const [salesData, setSalesData] = useState<SalesDataPoint[]>([]);
  const [topItems, setTopItems] = useState<TopItem[]>([]);
  const [paymentData, setPaymentData] = useState<PaymentPoint[]>([]);
  const [inventory, setInventory] = useState<InventoryItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);

  useEffect(() => {
    if (!token) return;

    const headers = { Authorization: `Bearer ${token}` };

    const fetchData = async () => {
      try {
        const [salesRes, topItemsRes, paymentsRes, inventoryRes] = await Promise.all([
          fetch(`${SERVER_URL}/reports/sales`, { headers }),
          fetch(`${SERVER_URL}/reports/top-items`, { headers }),
          fetch(`${SERVER_URL}/reports/payments`, { headers }),
          fetch(`${SERVER_URL}/inventory`, { headers }),
        ]);

        const salesRaw = await salesRes.json();
        setSalesData(
          (salesRaw ?? []).map((item: SalesDataPoint) => ({
            ...item,
            date: new Date(item.date).toLocaleDateString(),
            total: Number(item.total || 0),
          })),
        );

        setTopItems(await topItemsRes.json());
        setPaymentData(await paymentsRes.json());
        setInventory(await inventoryRes.json());
        setLastUpdated(new Date());
      } catch (error) {
        console.error("Failed to fetch analytics", error);
      } finally {
        setLoading(false);
      }
    };

    void fetchData();
    const interval = setInterval(() => void fetchData(), REFRESH_MS);
    return () => clearInterval(interval);
  }, [token]);

  const summary = useMemo(() => {
    const revenue = salesData.reduce((sum, item) => sum + item.total, 0);
    const days = salesData.length;
    const avgPerDay = days ? revenue / days : 0;
    const lowStockCount = inventory.filter(
      (item) => Number(item.currentStock) <= Number(item.minimumStock),
    ).length;

    const paymentTotal = paymentData.reduce(
      (sum, item) => sum + Number(item?._sum?.amount ?? 0),
      0,
    );

    const highestPaymentMethod = paymentData
      .map((item) => ({ method: item.method, amount: Number(item?._sum?.amount ?? 0) }))
      .sort((a, b) => b.amount - a.amount)[0];

    return { revenue, avgPerDay, lowStockCount, paymentTotal, highestPaymentMethod };
  }, [salesData, paymentData, inventory]);

  if (loading) {
    return <div className="text-gray-600">Loading analytics...</div>;
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold text-gray-900">Business Analytics</h1>
          <p className="text-sm text-gray-500 mt-1">
            Real-time performance pulse for sales, product demand, and payment mix.
          </p>
        </div>
        <p className="text-xs text-gray-500">
          Live refresh every {REFRESH_MS / 1000}s{lastUpdated ? `  Last update ${lastUpdated.toLocaleTimeString()}` : ""}
        </p>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-4">
        <SummaryCard label="Revenue (loaded period)" value={`UGX ${summary.revenue.toFixed(0)}`} />
        <SummaryCard label="Average Daily Revenue" value={`UGX ${summary.avgPerDay.toFixed(0)}`} />
        <SummaryCard label="Low Stock Risk Items" value={summary.lowStockCount} />
        <SummaryCard
          label="Strongest Payment Channel"
          value={summary.highestPaymentMethod ? `${summary.highestPaymentMethod.method} (${summary.highestPaymentMethod.amount.toFixed(0)})` : "N/A"}
        />
      </div>

      <div className="grid grid-cols-1 xl:grid-cols-2 gap-6">
        <section className="bg-white p-5 rounded-xl border border-gray-100">
          <h2 className="text-lg font-semibold mb-4">Revenue Trend</h2>
          <div className="h-72">
            <ResponsiveContainer width="100%" height="100%">
              <AreaChart data={salesData}>
                <CartesianGrid strokeDasharray="3 3" vertical={false} />
                <XAxis dataKey="date" tick={{ fontSize: 12 }} />
                <YAxis tick={{ fontSize: 12 }} />
                <Tooltip />
                <Area type="monotone" dataKey="total" stroke="#2563eb" fill="#bfdbfe" strokeWidth={2} />
              </AreaChart>
            </ResponsiveContainer>
          </div>
        </section>

        <section className="bg-white p-5 rounded-xl border border-gray-100">
          <h2 className="text-lg font-semibold mb-4">Top Product Demand</h2>
          <div className="h-72">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart data={topItems} layout="vertical" margin={{ left: 20 }}>
                <CartesianGrid strokeDasharray="3 3" horizontal={false} />
                <XAxis type="number" />
                <YAxis dataKey="name" type="category" width={120} tick={{ fontSize: 12 }} />
                <Tooltip />
                <Bar dataKey="quantity" fill="#10b981" radius={[0, 6, 6, 0]} />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </section>
      </div>

      <div className="grid grid-cols-1 xl:grid-cols-2 gap-6">
        <section className="bg-white p-5 rounded-xl border border-gray-100">
          <h2 className="text-lg font-semibold mb-4">Payment Mix</h2>
          <div className="h-72">
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <Pie data={paymentData} dataKey="_sum.amount" nameKey="method" innerRadius={60} outerRadius={90} paddingAngle={3}>
                  {paymentData.map((_, idx) => (
                    <Cell key={idx} fill={COLORS[idx % COLORS.length]} />
                  ))}
                </Pie>
                <Tooltip />
                <Legend />
              </PieChart>
            </ResponsiveContainer>
          </div>
        </section>

        <section className="bg-white p-5 rounded-xl border border-gray-100">
          <h2 className="text-lg font-semibold mb-4">Payment Throughput</h2>
          <div className="h-72">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart
                data={paymentData.map((item) => ({
                  method: item.method,
                  amount: Number(item?._sum?.amount ?? 0),
                }))}
              >
                <CartesianGrid strokeDasharray="3 3" vertical={false} />
                <XAxis dataKey="method" />
                <YAxis />
                <Tooltip />
                <Bar dataKey="amount" fill="#f59e0b" radius={[6, 6, 0, 0]} />
              </BarChart>
            </ResponsiveContainer>
          </div>
          <p className="text-xs text-gray-500 mt-2">Total across payment methods: UGX {summary.paymentTotal.toFixed(0)}</p>
        </section>
      </div>
    </div>
  );
}

function SummaryCard({ label, value }: { label: string; value: string | number }) {
  return (
    <div className="bg-white p-4 rounded-xl border border-gray-100">
      <p className="text-xs uppercase tracking-wide text-gray-500 font-semibold">{label}</p>
      <p className="text-2xl font-bold text-gray-900 mt-2">{value}</p>
    </div>
  );
}

================
File: qristal_dashboard/src/app/admin/inventory/page.tsx
================
"use client";

import { useState, useEffect, useMemo, useCallback } from "react";
import { useAuth } from "@/context/AuthContext";

const SERVER_URL = "https://qristal-pos-api.onrender.com";
const RECIPE_STORAGE_KEY = "qristal.recipeMappings.v1";

interface InventoryItem {
  id: string;
  name: string;
  unitOfMeasure: string;
  currentStock: number;
  minimumStock: number;
  costPerUnit: number;
}

interface Product {
  id: string;
  name: string;
}

interface RecipeIngredient {
  inventoryId: string;
  inventoryName: string;
  unitOfMeasure: string;
  quantity: number;
  costPerUnit: number;
}

interface RecipeMap {
  productId: string;
  productName: string;
  ingredients: RecipeIngredient[];
  updatedAt: string;
}

export default function InventoryAdminPage() {
  const { token } = useAuth();
  const [inventory, setInventory] = useState<InventoryItem[]>([]);
  const [products, setProducts] = useState<Product[]>([]);
  const [recipeMaps, setRecipeMaps] = useState<RecipeMap[]>(() => {
    if (typeof window === "undefined") return [];
    const raw = window.localStorage.getItem(RECIPE_STORAGE_KEY);
    if (!raw) return [];
    try {
      return JSON.parse(raw);
    } catch {
      return [];
    }
  });

  const [isItemModalOpen, setItemModalOpen] = useState(false);
  const [isRestockModalOpen, setRestockModalOpen] = useState(false);
  const [selectedItem, setSelectedItem] = useState<InventoryItem | null>(null);

  const [itemForm, setItemForm] = useState({ name: "", unitOfMeasure: "kg", minimumStock: "", costPerUnit: "" });
  const [restockAmount, setRestockAmount] = useState("");

  const [selectedProductId, setSelectedProductId] = useState("");
  const [selectedInventoryId, setSelectedInventoryId] = useState("");
  const [ingredientQty, setIngredientQty] = useState("");

  const fetchData = useCallback(async () => {
    if (!token) return;
    const headers = { Authorization: `Bearer ${token}` };

    const [inventoryRes, productsRes] = await Promise.all([
      fetch(`${SERVER_URL}/inventory`, { headers }),
      fetch(`${SERVER_URL}/products`, { headers }),
    ]);

    setInventory(await inventoryRes.json());
    setProducts(await productsRes.json());
  }, [token]);

  useEffect(() => {
    if (!token) return;
    const timer = setTimeout(() => {
      void fetchData();
    }, 0);
    return () => clearTimeout(timer);
  }, [token, fetchData]);

  useEffect(() => {
    localStorage.setItem(RECIPE_STORAGE_KEY, JSON.stringify(recipeMaps));
  }, [recipeMaps]);

  const currentProduct = useMemo(
    () => products.find((item) => item.id === selectedProductId),
    [products, selectedProductId],
  );

  const editingRecipe = useMemo(() => {
    if (!currentProduct) return null;
    return recipeMaps.find((recipe) => recipe.productId === currentProduct.id) ?? null;
  }, [recipeMaps, currentProduct]);

  const recipeCost = useMemo(() => {
    const ingredients = editingRecipe?.ingredients ?? [];
    return ingredients.reduce((sum, item) => sum + item.quantity * item.costPerUnit, 0);
  }, [editingRecipe]);

  const handleItemSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    await fetch(`${SERVER_URL}/inventory`, {
      method: "POST",
      headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
      body: JSON.stringify(itemForm),
    });
    setItemModalOpen(false);
    setItemForm({ name: "", unitOfMeasure: "kg", minimumStock: "", costPerUnit: "" });
    void fetchData();
  };

  const handleRestock = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedItem || !restockAmount) return;

    await fetch(`${SERVER_URL}/inventory/${selectedItem.id}/restock`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
      body: JSON.stringify({ amount: parseFloat(restockAmount) }),
    });

    setRestockModalOpen(false);
    setRestockAmount("");
    setSelectedItem(null);
    void fetchData();
  };

  const handleDelete = async (id: string) => {
    if (!confirm("Remove this item from inventory?")) return;
    await fetch(`${SERVER_URL}/inventory/${id}`, {
      method: "DELETE",
      headers: { Authorization: `Bearer ${token}` },
    });
    void fetchData();
  };

  const handleAddIngredient = () => {
    if (!selectedProductId || !selectedInventoryId || !ingredientQty) return;

    const qty = Number(ingredientQty);
    if (!qty || qty <= 0) return;

    const product = products.find((item) => item.id === selectedProductId);
    const inventoryItem = inventory.find((item) => item.id === selectedInventoryId);
    if (!product || !inventoryItem) return;

    setRecipeMaps((prev) => {
      const existing = prev.find((item) => item.productId === product.id);
      const ingredient: RecipeIngredient = {
        inventoryId: inventoryItem.id,
        inventoryName: inventoryItem.name,
        unitOfMeasure: inventoryItem.unitOfMeasure,
        quantity: qty,
        costPerUnit: Number(inventoryItem.costPerUnit),
      };

      if (!existing) {
        return [
          ...prev,
          {
            productId: product.id,
            productName: product.name,
            ingredients: [ingredient],
            updatedAt: new Date().toISOString(),
          },
        ];
      }

      const withoutIngredient = existing.ingredients.filter(
        (item) => item.inventoryId !== ingredient.inventoryId,
      );
      const updated: RecipeMap = {
        ...existing,
        ingredients: [...withoutIngredient, ingredient],
        updatedAt: new Date().toISOString(),
      };

      return prev.map((item) => (item.productId === existing.productId ? updated : item));
    });

    setIngredientQty("");
  };

  const handleRemoveIngredient = (productId: string, inventoryId: string) => {
    setRecipeMaps((prev) =>
      prev
        .map((recipe) =>
          recipe.productId === productId
            ? {
                ...recipe,
                ingredients: recipe.ingredients.filter(
                  (ingredient) => ingredient.inventoryId !== inventoryId,
                ),
                updatedAt: new Date().toISOString(),
              }
            : recipe,
        )
        .filter((recipe) => recipe.ingredients.length > 0),
    );
  };

  const handleDeleteRecipe = (productId: string) => {
    setRecipeMaps((prev) => prev.filter((recipe) => recipe.productId !== productId));
  };

  return (
    <div className="max-w-7xl mx-auto space-y-8">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold text-gray-800">Inventory + Recipe Builder</h1>
          <p className="text-gray-500 text-sm">
            Maintain stock and map products to ingredient usage for better costing.
          </p>
        </div>
        <button
          onClick={() => setItemModalOpen(true)}
          className="bg-blue-600 text-white px-4 py-2 rounded-lg shadow"
        >
          + Add Material
        </button>
      </div>

      <div className="grid grid-cols-1 xl:grid-cols-5 gap-6">
        <div className="xl:col-span-3 bg-white shadow rounded-lg overflow-hidden">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Material Name</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Current Stock</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Min Level</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Unit Cost</th>
                <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase">Actions</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200">
              {inventory.map((item) => (
                <tr key={item.id}>
                  <td className="px-6 py-4">
                    <div className="font-medium text-gray-900">{item.name}</div>
                    <div className="text-xs text-gray-500">Unit: {item.unitOfMeasure}</div>
                  </td>
                  <td className="px-6 py-4">
                    <span
                      className={`font-bold ${
                        item.currentStock <= item.minimumStock
                          ? "text-red-600"
                          : "text-green-600"
                      }`}
                    >
                      {Number(item.currentStock).toFixed(2)} {item.unitOfMeasure}
                    </span>
                  </td>
                  <td className="px-6 py-4 text-gray-500">{item.minimumStock}</td>
                  <td className="px-6 py-4 text-gray-500">UGX {item.costPerUnit}</td>
                  <td className="px-6 py-4 text-right space-x-4">
                    <button
                      onClick={() => {
                        setSelectedItem(item);
                        setRestockModalOpen(true);
                      }}
                      className="text-emerald-600 font-semibold hover:underline"
                    >
                      + Restock
                    </button>
                    <button
                      onClick={() => handleDelete(item.id)}
                      className="text-red-500 hover:underline"
                    >
                      Delete
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>

        <div className="xl:col-span-2 bg-white border border-gray-100 rounded-lg p-5 space-y-4">
          <div>
            <h2 className="text-lg font-bold text-gray-800">Product Recipe Mapping</h2>
            <p className="text-xs text-gray-500 mt-1">
              Build product recipes from inventory ingredients.
            </p>
          </div>

          <div className="space-y-3">
            <div>
              <label className="text-xs font-semibold text-gray-600 uppercase">Product</label>
              <select
                className="mt-1 w-full border border-gray-300 rounded-md px-3 py-2"
                value={selectedProductId}
                onChange={(e) => setSelectedProductId(e.target.value)}
              >
                <option value="">Select product</option>
                {products.map((product) => (
                  <option key={product.id} value={product.id}>
                    {product.name}
                  </option>
                ))}
              </select>
            </div>

            <div>
              <label className="text-xs font-semibold text-gray-600 uppercase">Inventory Ingredient</label>
              <select
                className="mt-1 w-full border border-gray-300 rounded-md px-3 py-2"
                value={selectedInventoryId}
                onChange={(e) => setSelectedInventoryId(e.target.value)}
              >
                <option value="">Select ingredient</option>
                {inventory.map((item) => (
                  <option key={item.id} value={item.id}>
                    {item.name} ({item.unitOfMeasure})
                  </option>
                ))}
              </select>
            </div>

            <div>
              <label className="text-xs font-semibold text-gray-600 uppercase">Quantity Used Per Product</label>
              <input
                type="number"
                step="0.01"
                min="0"
                className="mt-1 w-full border border-gray-300 rounded-md px-3 py-2"
                placeholder="0.00"
                value={ingredientQty}
                onChange={(e) => setIngredientQty(e.target.value)}
              />
            </div>

            <button
              onClick={handleAddIngredient}
              className="w-full bg-indigo-600 text-white px-3 py-2 rounded-md hover:bg-indigo-700"
            >
              Add / Update Ingredient in Recipe
            </button>
          </div>

          {currentProduct && (
            <div className="bg-gray-50 border border-gray-200 rounded-md p-3">
              <p className="text-sm font-semibold text-gray-700">Current Recipe: {currentProduct.name}</p>
              <p className="text-xs text-gray-500 mt-1">Estimated ingredient cost: UGX {recipeCost.toFixed(0)}</p>
              <div className="mt-2 space-y-2">
                {(editingRecipe?.ingredients ?? []).map((ingredient) => (
                  <div key={ingredient.inventoryId} className="flex items-center justify-between text-sm">
                    <div>
                      <p className="font-medium text-gray-800">{ingredient.inventoryName}</p>
                      <p className="text-xs text-gray-500">
                        {ingredient.quantity} {ingredient.unitOfMeasure}  UGX {(ingredient.quantity * ingredient.costPerUnit).toFixed(0)}
                      </p>
                    </div>
                    <button
                      onClick={() =>
                        handleRemoveIngredient(currentProduct.id, ingredient.inventoryId)
                      }
                      className="text-red-500 text-xs"
                    >
                      Remove
                    </button>
                  </div>
                ))}
                {!editingRecipe && (
                  <p className="text-xs text-gray-500">No ingredients mapped yet.</p>
                )}
              </div>
            </div>
          )}
        </div>
      </div>

      <div className="bg-white rounded-lg border border-gray-100 p-5">
        <h2 className="text-lg font-bold text-gray-800 mb-3">Saved Product Recipes</h2>
        {recipeMaps.length === 0 ? (
          <p className="text-sm text-gray-500">No recipe mappings saved yet.</p>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
            {recipeMaps.map((recipe) => {
              const totalCost = recipe.ingredients.reduce(
                (sum, ingredient) => sum + ingredient.quantity * ingredient.costPerUnit,
                0,
              );
              return (
                <div key={recipe.productId} className="border border-gray-200 rounded-md p-3">
                  <div className="flex justify-between gap-3">
                    <div>
                      <p className="font-semibold text-gray-800">{recipe.productName}</p>
                      <p className="text-xs text-gray-500">Updated {new Date(recipe.updatedAt).toLocaleString()}</p>
                    </div>
                    <button
                      onClick={() => handleDeleteRecipe(recipe.productId)}
                      className="text-red-500 text-xs"
                    >
                      Delete
                    </button>
                  </div>
                  <ul className="mt-2 space-y-1 text-sm text-gray-700">
                    {recipe.ingredients.map((ingredient) => (
                      <li key={`${recipe.productId}-${ingredient.inventoryId}`}>
                         {ingredient.inventoryName}: {ingredient.quantity} {ingredient.unitOfMeasure}
                      </li>
                    ))}
                  </ul>
                  <p className="text-xs font-semibold text-indigo-600 mt-2">
                    Estimated recipe cost: UGX {totalCost.toFixed(0)}
                  </p>
                </div>
              );
            })}
          </div>
        )}
      </div>

      {isItemModalOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
          <div className="bg-white rounded-lg p-6 w-96">
            <h3 className="text-lg font-bold mb-4">New Material</h3>
            <form onSubmit={handleItemSubmit} className="space-y-3">
              <input
                placeholder="Name (e.g. Tomato, Ground Beef)"
                className="w-full border p-2 rounded"
                value={itemForm.name}
                onChange={(e) => setItemForm({ ...itemForm, name: e.target.value })}
                required
              />

              <input
                placeholder="Unit of Measure (e.g. kg, liters, pcs)"
                className="w-full border p-2 rounded"
                value={itemForm.unitOfMeasure}
                onChange={(e) =>
                  setItemForm({ ...itemForm, unitOfMeasure: e.target.value })
                }
                required
              />

              <input
                placeholder="Minimum Stock Alert Level"
                type="number"
                step="0.01"
                className="w-full border p-2 rounded"
                value={itemForm.minimumStock}
                onChange={(e) =>
                  setItemForm({ ...itemForm, minimumStock: e.target.value })
                }
                required
              />

              <input
                placeholder="Cost Per Unit (UGX)"
                type="number"
                className="w-full border p-2 rounded"
                value={itemForm.costPerUnit}
                onChange={(e) =>
                  setItemForm({ ...itemForm, costPerUnit: e.target.value })
                }
                required
              />

              <div className="flex justify-end gap-2 mt-4">
                <button
                  type="button"
                  onClick={() => setItemModalOpen(false)}
                  className="px-3 py-1.5 text-gray-600"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  className="px-3 py-1.5 bg-blue-600 text-white rounded"
                >
                  Create Item
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {isRestockModalOpen && selectedItem && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
          <div className="bg-white rounded-lg p-6 w-96">
            <h3 className="text-lg font-bold mb-1">Restock</h3>
            <p className="text-gray-600 mb-4">
              {selectedItem.name} (Current: {Number(selectedItem.currentStock).toFixed(2)} {selectedItem.unitOfMeasure})
            </p>
            <form onSubmit={handleRestock}>
              <label className="text-sm font-medium">
                Add quantity ({selectedItem.unitOfMeasure})
              </label>
              <input
                type="number"
                step="0.01"
                min="0"
                autoFocus
                placeholder="0.00"
                className="w-full border p-2 rounded mb-4 mt-1 text-lg"
                value={restockAmount}
                onChange={(e) => setRestockAmount(e.target.value)}
                required
              />
              <div className="flex justify-end gap-2">
                <button
                  type="button"
                  onClick={() => {
                    setRestockModalOpen(false);
                    setRestockAmount("");
                  }}
                  className="px-3 py-1.5 text-gray-600"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  className="px-3 py-1.5 bg-emerald-600 text-white rounded"
                >
                  + Add Stock
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  );
}

================
File: qristal_dashboard/src/app/admin/menu/page.tsx
================
"use client";

import { useEffect, useMemo, useState } from "react";
import { useAuth } from "@/context/AuthContext";

const SERVER_URL = "https://qristal-pos-api.onrender.com";

type ProductionArea = "KITCHEN" | "BARISTA" | "BAR" | "RETAIL" | "OTHER";
const PRODUCTION_AREAS: ProductionArea[] = ["KITCHEN", "BARISTA", "BAR", "RETAIL", "OTHER"];

type Category = { id: string; name: string; colorHex: string };
type Modifier = { id: string; name: string; priceDelta: number; productionArea: ProductionArea };
type ModifierGroup = {
  id: string;
  name: string;
  minSelect: number;
  maxSelect: number | null;
  isRequired: boolean;
  modifiers: Modifier[];
};
type Side = { id: string; name: string; priceDelta: number; productionArea: ProductionArea };
type Product = {
  id: string;
  name: string;
  price: number;
  categoryId: string;
  productionArea: ProductionArea;
  productModifierGroups?: Array<{ modifierGroupId: string }>;
  productSides?: Array<{ sideId: string }>;
};

export default function MenuPage() {
  const { token } = useAuth();
  const headers = useMemo(() => ({ "Content-Type": "application/json", Authorization: `Bearer ${token}` }), [token]);

  const [categories, setCategories] = useState<Category[]>([]);
  const [products, setProducts] = useState<Product[]>([]);
  const [modifierGroups, setModifierGroups] = useState<ModifierGroup[]>([]);
  const [sides, setSides] = useState<Side[]>([]);

  const [categoryForm, setCategoryForm] = useState({ name: "", colorHex: "#2563eb" });
  const [groupForm, setGroupForm] = useState({ name: "", minSelect: "0", maxSelect: "", isRequired: false });
  const [modifierForms, setModifierForms] = useState<Record<string, { name: string; priceDelta: string; productionArea: ProductionArea }>>({});
  const [sideForm, setSideForm] = useState({ name: "", priceDelta: "0", productionArea: "KITCHEN" as ProductionArea });
  const [productForm, setProductForm] = useState({
    id: "",
    name: "",
    price: "",
    categoryId: "",
    productionArea: "KITCHEN" as ProductionArea,
    modifierGroupIds: [] as string[],
    sideIds: [] as string[],
  });

  const loadData = async () => {
    if (!token) return;
    const simpleHeaders = { Authorization: `Bearer ${token}` };
    const [catRes, prodRes, groupRes, sideRes] = await Promise.all([
      fetch(`${SERVER_URL}/categories`, { headers: simpleHeaders }),
      fetch(`${SERVER_URL}/products`, { headers: simpleHeaders }),
      fetch(`${SERVER_URL}/modifier-groups`, { headers: simpleHeaders }),
      fetch(`${SERVER_URL}/sides`, { headers: simpleHeaders }),
    ]);

    setCategories(await catRes.json());
    setProducts(await prodRes.json());
    setModifierGroups(await groupRes.json());
    setSides(await sideRes.json());
  };

  useEffect(() => {
    void loadData();
  }, [token]);

  const submitCategory = async (e: React.FormEvent) => {
    e.preventDefault();
    await fetch(`${SERVER_URL}/categories`, { method: "POST", headers, body: JSON.stringify(categoryForm) });
    setCategoryForm({ name: "", colorHex: "#2563eb" });
    await loadData();
  };

  const submitGroup = async (e: React.FormEvent) => {
    e.preventDefault();
    await fetch(`${SERVER_URL}/modifier-groups`, {
      method: "POST",
      headers,
      body: JSON.stringify({ ...groupForm, minSelect: Number(groupForm.minSelect), maxSelect: groupForm.maxSelect === "" ? null : Number(groupForm.maxSelect) }),
    });
    setGroupForm({ name: "", minSelect: "0", maxSelect: "", isRequired: false });
    await loadData();
  };

  const submitModifier = async (e: React.FormEvent, groupId: string) => {
    e.preventDefault();
    const form = modifierForms[groupId];
    if (!form?.name) return;
    await fetch(`${SERVER_URL}/modifier-groups/${groupId}/modifiers`, {
      method: "POST",
      headers,
      body: JSON.stringify({ ...form, priceDelta: Number(form.priceDelta || 0) }),
    });
    setModifierForms((current) => ({ ...current, [groupId]: { name: "", priceDelta: "0", productionArea: "KITCHEN" } }));
    await loadData();
  };

  const submitSide = async (e: React.FormEvent) => {
    e.preventDefault();
    await fetch(`${SERVER_URL}/sides`, {
      method: "POST",
      headers,
      body: JSON.stringify({ ...sideForm, priceDelta: Number(sideForm.priceDelta || 0) }),
    });
    setSideForm({ name: "", priceDelta: "0", productionArea: "KITCHEN" });
    await loadData();
  };

  const submitProduct = async (e: React.FormEvent) => {
    e.preventDefault();
    const payload = {
      name: productForm.name,
      price: Number(productForm.price),
      categoryId: productForm.categoryId,
      productionArea: productForm.productionArea,
      modifierGroupIds: productForm.modifierGroupIds,
      sideIds: productForm.sideIds,
      modifierGroups: [],
      sides: [],
    };

    if (productForm.id) {
      await fetch(`${SERVER_URL}/products/${productForm.id}`, { method: "PATCH", headers, body: JSON.stringify(payload) });
    } else {
      await fetch(`${SERVER_URL}/products`, { method: "POST", headers, body: JSON.stringify(payload) });
    }

    setProductForm({ id: "", name: "", price: "", categoryId: "", productionArea: "KITCHEN", modifierGroupIds: [], sideIds: [] });
    await loadData();
  };

  return (
    <div className="space-y-8 max-w-7xl mx-auto">
      <h1 className="text-2xl font-bold">Professional Menu Management</h1>

      <div className="grid lg:grid-cols-2 gap-6">
        <form onSubmit={submitCategory} className="bg-white rounded-lg border p-4 space-y-3">
          <h2 className="font-semibold">Categories</h2>
          <input className="w-full border rounded p-2" placeholder="Category name" value={categoryForm.name} onChange={(e) => setCategoryForm({ ...categoryForm, name: e.target.value })} required />
          <input type="color" className="w-full border rounded p-1 h-10" value={categoryForm.colorHex} onChange={(e) => setCategoryForm({ ...categoryForm, colorHex: e.target.value })} />
          <button className="px-3 py-2 bg-blue-600 text-white rounded">Add Category</button>
          <ul className="text-sm text-gray-700 space-y-1">{categories.map((c) => <li key={c.id}> {c.name}</li>)}</ul>
        </form>

        <form onSubmit={submitGroup} className="bg-white rounded-lg border p-4 space-y-3">
          <h2 className="font-semibold">Modifier Groups</h2>
          <input className="w-full border rounded p-2" placeholder="Group name" value={groupForm.name} onChange={(e) => setGroupForm({ ...groupForm, name: e.target.value })} required />
          <div className="grid grid-cols-2 gap-2">
            <input className="border rounded p-2" type="number" placeholder="Min select" value={groupForm.minSelect} onChange={(e) => setGroupForm({ ...groupForm, minSelect: e.target.value })} />
            <input className="border rounded p-2" type="number" placeholder="Max select (optional)" value={groupForm.maxSelect} onChange={(e) => setGroupForm({ ...groupForm, maxSelect: e.target.value })} />
          </div>
          <label className="text-sm flex items-center gap-2"><input type="checkbox" checked={groupForm.isRequired} onChange={(e) => setGroupForm({ ...groupForm, isRequired: e.target.checked })} /> Required</label>
          <button className="px-3 py-2 bg-blue-600 text-white rounded">Add Group</button>
        </form>
      </div>

      <div className="bg-white rounded-lg border p-4">
        <h2 className="font-semibold mb-3">Modifiers by Group</h2>
        <div className="space-y-4">
          {modifierGroups.map((group) => (
            <div key={group.id} className="border rounded p-3">
              <div className="font-medium">{group.name} ({group.modifiers.length})</div>
              <ul className="text-sm text-gray-600 mb-3">{group.modifiers.map((m) => <li key={m.id}> {m.name} (+{m.priceDelta})</li>)}</ul>
              <form onSubmit={(e) => submitModifier(e, group.id)} className="grid md:grid-cols-4 gap-2">
                <input className="border rounded p-2" placeholder="Modifier name" value={modifierForms[group.id]?.name || ""} onChange={(e) => setModifierForms((c) => ({ ...c, [group.id]: { ...(c[group.id] || { name: "", priceDelta: "0", productionArea: "KITCHEN" }), name: e.target.value } }))} />
                <input className="border rounded p-2" type="number" placeholder="Price delta" value={modifierForms[group.id]?.priceDelta || "0"} onChange={(e) => setModifierForms((c) => ({ ...c, [group.id]: { ...(c[group.id] || { name: "", priceDelta: "0", productionArea: "KITCHEN" }), priceDelta: e.target.value } }))} />
                <select className="border rounded p-2" value={modifierForms[group.id]?.productionArea || "KITCHEN"} onChange={(e) => setModifierForms((c) => ({ ...c, [group.id]: { ...(c[group.id] || { name: "", priceDelta: "0", productionArea: "KITCHEN" }), productionArea: e.target.value as ProductionArea } }))}>{PRODUCTION_AREAS.map((a) => <option key={a} value={a}>{a}</option>)}</select>
                <button className="bg-indigo-600 text-white rounded px-2">Add Modifier</button>
              </form>
            </div>
          ))}
        </div>
      </div>

      <div className="grid lg:grid-cols-2 gap-6">
        <form onSubmit={submitSide} className="bg-white rounded-lg border p-4 space-y-3">
          <h2 className="font-semibold">Sides Library</h2>
          <input className="w-full border rounded p-2" placeholder="Side name" value={sideForm.name} onChange={(e) => setSideForm({ ...sideForm, name: e.target.value })} required />
          <input className="w-full border rounded p-2" type="number" placeholder="Price delta" value={sideForm.priceDelta} onChange={(e) => setSideForm({ ...sideForm, priceDelta: e.target.value })} />
          <select className="w-full border rounded p-2" value={sideForm.productionArea} onChange={(e) => setSideForm({ ...sideForm, productionArea: e.target.value as ProductionArea })}>{PRODUCTION_AREAS.map((a) => <option key={a} value={a}>{a}</option>)}</select>
          <button className="px-3 py-2 bg-blue-600 text-white rounded">Add Side</button>
          <ul className="text-sm text-gray-700 space-y-1">{sides.map((s) => <li key={s.id}> {s.name}</li>)}</ul>
        </form>

        <form onSubmit={submitProduct} className="bg-white rounded-lg border p-4 space-y-3">
          <h2 className="font-semibold">Products</h2>
          <input className="w-full border rounded p-2" placeholder="Product name" value={productForm.name} onChange={(e) => setProductForm({ ...productForm, name: e.target.value })} required />
          <input className="w-full border rounded p-2" type="number" placeholder="Price" value={productForm.price} onChange={(e) => setProductForm({ ...productForm, price: e.target.value })} required />
          <select className="w-full border rounded p-2" value={productForm.categoryId} onChange={(e) => setProductForm({ ...productForm, categoryId: e.target.value })} required>
            <option value="">Select category</option>{categories.map((c) => <option key={c.id} value={c.id}>{c.name}</option>)}
          </select>
          <select className="w-full border rounded p-2" value={productForm.productionArea} onChange={(e) => setProductForm({ ...productForm, productionArea: e.target.value as ProductionArea })}>{PRODUCTION_AREAS.map((a) => <option key={a} value={a}>{a}</option>)}</select>
          <label className="text-sm font-medium">Attach Modifier Groups</label>
          <select multiple className="w-full border rounded p-2 h-24" value={productForm.modifierGroupIds} onChange={(e) => setProductForm({ ...productForm, modifierGroupIds: Array.from(e.target.selectedOptions).map((o) => o.value) })}>{modifierGroups.map((g) => <option key={g.id} value={g.id}>{g.name}</option>)}</select>
          <label className="text-sm font-medium">Attach Sides</label>
          <select multiple className="w-full border rounded p-2 h-24" value={productForm.sideIds} onChange={(e) => setProductForm({ ...productForm, sideIds: Array.from(e.target.selectedOptions).map((o) => o.value) })}>{sides.map((s) => <option key={s.id} value={s.id}>{s.name}</option>)}</select>
          <button className="px-3 py-2 bg-blue-600 text-white rounded">Save Product</button>
        </form>
      </div>

      <div className="bg-white rounded-lg border p-4">
        <h2 className="font-semibold mb-3">All Products</h2>
        <div className="overflow-auto">
          <table className="w-full text-sm">
            <thead><tr className="text-left border-b"><th>Name</th><th>Price</th><th>Area</th><th>Groups</th><th>Sides</th><th></th></tr></thead>
            <tbody>
              {products.map((p) => (
                <tr key={p.id} className="border-b">
                  <td>{p.name}</td><td>{p.price}</td><td>{p.productionArea}</td><td>{p.productModifierGroups?.length || 0}</td><td>{p.productSides?.length || 0}</td>
                  <td><button className="text-blue-600" onClick={() => setProductForm({ id: p.id, name: p.name, price: String(p.price), categoryId: p.categoryId, productionArea: p.productionArea, modifierGroupIds: (p.productModifierGroups || []).map((g) => g.modifierGroupId), sideIds: (p.productSides || []).map((s) => s.sideId) })}>Edit</button></td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
}

================
File: qristal_dashboard/src/app/admin/tables/page.tsx
================
"use client";

import { useState, useEffect } from "react";
import { useAuth } from "@/context/AuthContext";

const SERVER_URL = "https://qristal-pos-api.onrender.com";

export default function TablesPage() {
  const { token } = useAuth();
  const [tables, setTables] = useState<any[]>([]);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [form, setForm] = useState({ name: "", floor: "Main" });

  const fetchTables = async () => {
    if (!token) return;
    const res = await fetch(`${SERVER_URL}/tables`, {
      headers: { Authorization: `Bearer ${token}` }
    });
    setTables(await res.json());
  };

  useEffect(() => { fetchTables(); }, [token]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    await fetch(`${SERVER_URL}/tables`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
      body: JSON.stringify(form)
    });
    setIsModalOpen(false);
    setForm({ name: "", floor: "Main" });
    fetchTables();
  };

  const handleDelete = async (id: string) => {
    if(!confirm("Delete table?")) return;
    await fetch(`${SERVER_URL}/tables/${id}`, {
      method: 'DELETE',
      headers: { Authorization: `Bearer ${token}` }
    });
    fetchTables();
  };

  return (
    <div className="max-w-4xl mx-auto">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold text-gray-800">Floor Plan</h1>
        <button onClick={() => setIsModalOpen(true)} className="bg-blue-600 text-white px-4 py-2 rounded-lg shadow">+ Add Table</button>
      </div>

      <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-5 gap-4">
        {tables.map(t => (
          <div key={t.id} className="bg-white p-4 rounded-xl border border-gray-200 shadow-sm flex flex-col items-center relative">
            <button onClick={() => handleDelete(t.id)} className="absolute top-2 right-2 text-red-400 hover:text-red-600"></button>
            <div className="w-16 h-16 bg-blue-100 rounded-full flex items-center justify-center mb-3 text-blue-600">
                <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 10h18M3 14h18m-9-4v8m-7-4h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v2a2 2 0 002 2z" /></svg>
            </div>
            <h3 className="font-bold text-gray-900">{t.name}</h3>
            <span className="text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded mt-1">{t.floor}</span>
          </div>
        ))}
      </div>

      {isModalOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
          <div className="bg-white rounded-lg p-6 w-80">
            <h3 className="text-lg font-bold mb-4">Add Table</h3>
            <form onSubmit={handleSubmit}>
              <input placeholder="Table Name (e.g. T-1)" className="w-full border p-2 rounded mb-3"
                value={form.name} onChange={e => setForm({...form, name: e.target.value})} required />
              <input placeholder="Floor (e.g. Terrace)" className="w-full border p-2 rounded mb-4"
                value={form.floor} onChange={e => setForm({...form, floor: e.target.value})} />
              <div className="flex justify-end gap-2">
                <button type="button" onClick={() => setIsModalOpen(false)} className="px-3 py-1.5 text-gray-600">Cancel</button>
                <button type="submit" className="px-3 py-1.5 bg-blue-600 text-white rounded">Save</button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  );
}

================
File: qristal_dashboard/src/app/admin/users/page.tsx
================
"use client";

import { useState, useEffect } from "react";
import { useAuth } from "@/context/AuthContext";

const SERVER_URL = "https://qristal-pos-api.onrender.com";

interface UserItem {
  id: string;
  fullName: string;
  role: string;
  isActive: boolean;
}

export default function UsersPage() {
  const { token } = useAuth();
  const [users, setUsers] = useState<UserItem[]>([]);
  const [loading, setLoading] = useState(true);
  
  // Form State
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editId, setEditId] = useState<string | null>(null);
  const [formData, setFormData] = useState({ fullName: "", role: "WAITER", pin: "1234" });

  const fetchUsers = async () => {
    try {
      const res = await fetch(`${SERVER_URL}/users`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      if (res.ok) setUsers(await res.json());
    } catch (error) {
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (token) fetchUsers();
  }, [token]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    const method = editId ? "PUT" : "POST";
    const url = editId ? `${SERVER_URL}/users/${editId}` : `${SERVER_URL}/users`;

    await fetch(url, {
      method,
      headers: { 
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}` 
      },
      body: JSON.stringify(formData),
    });

    setIsModalOpen(false);
    setEditId(null);
    setFormData({ fullName: "", role: "WAITER", pin: "" });
    fetchUsers();
  };

  const handleDelete = async (id: string) => {
    if(!confirm("Are you sure? This effectively disables access.")) return;
    await fetch(`${SERVER_URL}/users/${id}`, {
      method: "DELETE",
      headers: { Authorization: `Bearer ${token}` },
    });
    fetchUsers();
  }

  const openEdit = (user: UserItem) => {
    setEditId(user.id);
    setFormData({ fullName: user.fullName, role: user.role, pin: "" }); // Blank PIN on edit
    setIsModalOpen(true);
  };

  return (
    <div className="max-w-5xl mx-auto">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold text-gray-800">Staff Management</h1>
        <button
          onClick={() => { setEditId(null); setFormData({ fullName: "", role: "WAITER", pin: "" }); setIsModalOpen(true); }}
          className="bg-blue-600 text-white px-4 py-2 rounded-lg shadow hover:bg-blue-700"
        >
          + Add Staff
        </button>
      </div>

      <div className="bg-white shadow rounded-lg overflow-hidden">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Name</th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Role</th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Status</th>
              <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase">Actions</th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {users.map((u) => (
              <tr key={u.id}>
                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{u.fullName}</td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{u.role}</td>
                <td className="px-6 py-4 whitespace-nowrap text-sm">
                  <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${u.isActive ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
                    {u.isActive ? 'Active' : 'Disabled'}
                  </span>
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                  <button onClick={() => openEdit(u)} className="text-blue-600 hover:text-blue-900 mr-4">Edit</button>
                  <button onClick={() => handleDelete(u.id)} className="text-red-600 hover:text-red-900">Delete</button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* MODAL */}
      {isModalOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
          <div className="bg-white rounded-xl shadow-lg p-6 w-full max-w-md">
            <h2 className="text-xl font-bold mb-4">{editId ? 'Edit Staff' : 'New Staff'}</h2>
            <form onSubmit={handleSubmit} className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700">Full Name</label>
                <input required type="text" className="mt-1 block w-full border border-gray-300 rounded-md p-2"
                  value={formData.fullName} onChange={e => setFormData({ ...formData, fullName: e.target.value })} />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700">Role</label>
                <select className="mt-1 block w-full border border-gray-300 rounded-md p-2"
                  value={formData.role} onChange={e => setFormData({ ...formData, role: e.target.value })}>
                  <option value="WAITER">Waiter</option>
                  <option value="CASHIER">Cashier</option>
                  <option value="KITCHEN">Kitchen</option>
                  <option value="MANAGER">Manager</option>
                </select>
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700">PIN (4 Digits)</label>
                <input type="text" className="mt-1 block w-full border border-gray-300 rounded-md p-2"
                  placeholder={editId ? "Leave blank to keep current" : "e.g. 1234"}
                  value={formData.pin} onChange={e => setFormData({ ...formData, pin: e.target.value })} 
                  required={!editId}
                />
              </div>
              <div className="flex justify-end gap-3 mt-6">
                <button type="button" onClick={() => setIsModalOpen(false)} className="px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-md">Cancel</button>
                <button type="submit" className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Save</button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  );
}

================
File: qristal_dashboard/src/app/admin/layout.tsx
================
"use client";

import { useAuth } from "@/context/AuthContext";
import withAuth from "@/components/withAuth";
import Link from "next/link";
import { usePathname } from "next/navigation";

function AdminLayout({ children }: { children: React.ReactNode }) {
  const { logout, user } = useAuth();
  const pathname = usePathname();

  const navItems = [
    { name: "Dashboard", href: "/admin" },
    { name: "Business Analytics", href: "/admin/analytics" },
    { name: "Staff & Users", href: "/admin/users" },
    { name: "Menu Management", href: "/admin/menu" },
    { name: "Inventory & Recipes", href: "/admin/inventory" },
    { name: "Floor Plan", href: "/admin/tables" },
  ];

  return (
    <div className="flex h-screen bg-gray-100">
      <aside className="w-64 bg-white shadow-md flex flex-col">
        <div className="p-6 border-b border-gray-200">
          <h1 className="text-2xl font-bold text-blue-600">Qristal Admin</h1>
          <p className="text-sm text-gray-500 mt-1">{user?.fullName}</p>
        </div>
        <nav className="flex-1 p-4 space-y-1">
          {navItems.map((item) => {
            const isActive =
              pathname === item.href ||
              (item.href !== "/admin" && pathname.startsWith(item.href));
            return (
              <Link
                key={item.href}
                href={item.href}
                className={`block px-4 py-3 rounded-lg text-sm font-medium transition-colors ${
                  isActive
                    ? "bg-blue-50 text-blue-700"
                    : "text-gray-700 hover:bg-gray-50"
                }`}
              >
                {item.name}
              </Link>
            );
          })}
        </nav>
        <div className="p-4 border-t border-gray-200">
          <button
            onClick={logout}
            className="w-full flex items-center justify-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700"
          >
            Logout
          </button>
        </div>
      </aside>

      <main className="flex-1 overflow-y-auto p-8">{children}</main>
    </div>
  );
}

export default withAuth(AdminLayout);

================
File: qristal_dashboard/src/app/admin/page.tsx
================
"use client";

import { useAuth } from "@/context/AuthContext";
import Link from "next/link";
import { useEffect, useMemo, useState } from "react";

const SERVER_URL = "https://qristal-pos-api.onrender.com";
const REFRESH_MS = 10000;

type InventoryItem = {
  id: string;
  name: string;
  currentStock: number;
  minimumStock: number;
};

type KitchenOrder = {
  id: string;
  status: string;
};

type SalesPoint = {
  date: string;
  total: number;
};

export default function AdminHomePage() {
  const { token } = useAuth();
  const [inventory, setInventory] = useState<InventoryItem[]>([]);
  const [kitchenOrders, setKitchenOrders] = useState<KitchenOrder[]>([]);
  const [sales, setSales] = useState<SalesPoint[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!token) return;

    const headers = { Authorization: `Bearer ${token}` };

    const fetchAll = async () => {
      try {
        const [inventoryRes, ordersRes, salesRes] = await Promise.all([
          fetch(`${SERVER_URL}/inventory`, { headers }),
          fetch(`${SERVER_URL}/orders/kitchen`, { headers }),
          fetch(`${SERVER_URL}/reports/sales`, { headers }),
        ]);

        setInventory((await inventoryRes.json()) ?? []);

        const ordersData = await ordersRes.json();
        const normalizedOrders = Array.isArray(ordersData)
          ? ordersData
          : Array.isArray(ordersData?.orders)
            ? ordersData.orders
            : [];
        setKitchenOrders(normalizedOrders);

        setSales((await salesRes.json()) ?? []);
      } catch (error) {
        console.error("Unable to load admin dashboard data", error);
      } finally {
        setLoading(false);
      }
    };

    void fetchAll();
    const interval = setInterval(() => void fetchAll(), REFRESH_MS);

    return () => clearInterval(interval);
  }, [token]);

  const kpis = useMemo(() => {
    const lowStock = inventory.filter(
      (item) => Number(item.currentStock) <= Number(item.minimumStock),
    ).length;

    const pendingKitchen = kitchenOrders.filter((order) =>
      ["KITCHEN", "PREPARING"].includes(order.status),
    ).length;

    const totalSales = sales.reduce((sum, item) => sum + Number(item.total || 0), 0);
    const avgDaily = sales.length ? totalSales / sales.length : 0;

    return { lowStock, pendingKitchen, totalSales, avgDaily };
  }, [inventory, kitchenOrders, sales]);

  if (loading) {
    return <div className="text-gray-600">Loading admin dashboard...</div>;
  }

  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-3xl font-bold text-gray-900">Admin Dashboard</h1>
        <p className="text-sm text-gray-500 mt-1">
          Real-time overview of stock, kitchen pressure, and sales performance.
        </p>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-4">
        <StatCard label="Low Stock Items" value={kpis.lowStock} tone="red" />
        <StatCard label="Kitchen Queue" value={kpis.pendingKitchen} tone="amber" />
        <StatCard label="Sales (period loaded)" value={`UGX ${kpis.totalSales.toFixed(0)}`} tone="emerald" />
        <StatCard label="Average Daily Sales" value={`UGX ${kpis.avgDaily.toFixed(0)}`} tone="blue" />
      </div>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <QuickLink title="Business Analytics" description="View live revenue and payment trends." href="/admin/analytics" />
        <QuickLink title="Inventory & Recipes" description="Manage stock and map products to ingredient recipes." href="/admin/inventory" />
        <QuickLink title="Menu Management" description="Create categories and products sold at POS." href="/admin/menu" />
      </div>
    </div>
  );
}

function StatCard({ label, value, tone }: { label: string; value: string | number; tone: "red" | "amber" | "emerald" | "blue" }) {
  const toneClasses = {
    red: "border-red-100 bg-red-50 text-red-700",
    amber: "border-amber-100 bg-amber-50 text-amber-700",
    emerald: "border-emerald-100 bg-emerald-50 text-emerald-700",
    blue: "border-blue-100 bg-blue-50 text-blue-700",
  };

  return (
    <div className={`rounded-xl border p-4 ${toneClasses[tone]}`}>
      <p className="text-xs uppercase tracking-wide font-semibold">{label}</p>
      <p className="text-2xl font-bold mt-2">{value}</p>
    </div>
  );
}

function QuickLink({ title, description, href }: { title: string; description: string; href: string }) {
  return (
    <Link href={href} className="rounded-xl border border-gray-200 bg-white p-5 hover:shadow-sm transition-shadow">
      <p className="font-semibold text-gray-800">{title}</p>
      <p className="text-sm text-gray-500 mt-1">{description}</p>
    </Link>
  );
}

================
File: qristal_dashboard/src/app/login/page.tsx
================
"use client";

import { useState } from "react";
import { useAuth } from "@/context/AuthContext";

export default function LoginPage() {
  const { login } = useAuth();
  const [userId, setUserId] = useState("");
  const [pin, setPin] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError("");

    try {
      await login(userId, pin);
      // Navigation happens in AuthContext
    } catch (err) {
      setError("Invalid ID or PIN");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-100">
      <div className="w-full max-w-md bg-white p-8 rounded-2xl shadow-lg">
        <div className="text-center mb-8">
          <h1 className="text-3xl font-bold text-gray-900">Qristal Admin</h1>
          <p className="text-gray-500">Sign in to manage your branch</p>
        </div>

        <form onSubmit={handleSubmit} className="space-y-6">
          <div>
            <label className="block text-sm font-medium text-gray-700">
              User ID
            </label>
            <input
              type="text"
              required
              value={userId}
              onChange={(e) => setUserId(e.target.value)}
              className="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
              placeholder="Enter User UUID"
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700">
              PIN
            </label>
            <input
              type="password"
              required
              value={pin}
              onChange={(e) => setPin(e.target.value)}
              className="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
              placeholder="Enter 4-digit PIN"
            />
          </div>

          {error && <div className="text-red-500 text-sm text-center">{error}</div>}

          <button
            type="submit"
            disabled={loading}
            className="w-full flex justify-center py-3 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
          >
            {loading ? "Signing in..." : "Sign In"}
          </button>
        </form>
      </div>
    </div>
  );
}

================
File: qristal_dashboard/src/app/reports/page.tsx
================
"use client";

import { useEffect, useState } from 'react';
import {
    LineChart, Line, BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, PieChart, Pie, Cell
} from 'recharts';
import { useAuth } from "@/context/AuthContext";
import withAuth from "@/components/withAuth";

const SERVER_URL = "https://qristal-pos-api.onrender.com";

function ReportsPage() {
    const { token, logout } = useAuth();
    const [salesData, setSalesData] = useState([]);
    const [topItems, setTopItems] = useState([]);
    const [paymentData, setPaymentData] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        if (!token) return;

        const fetchData = async () => {
            try {
                const headers = { 'Authorization': `Bearer ${token}` };

                // 1. Sales
                const salesRes = await fetch(`${SERVER_URL}/reports/sales`, { headers });
                if (salesRes.status === 401) { logout(); return; }
                const salesJson = await salesRes.json();
                setSalesData(salesJson.map((d: any) => ({ ...d, date: new Date(d.date).toLocaleDateString() })));

                // 2. Top Items
                const itemsRes = await fetch(`${SERVER_URL}/reports/top-items`, { headers });
                setTopItems(await itemsRes.json());

                // 3. Payments
                const payRes = await fetch(`${SERVER_URL}/reports/payments`, { headers });
                setPaymentData(await payRes.json());
            } catch (error) {
                console.error("Error fetching report data", error);
            } finally {
                setLoading(false);
            }
        };

        fetchData();
    }, [token, logout]);

    const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#AF19FF'];

    if (loading) return <div className="min-h-screen flex items-center justify-center">Loading Analytics...</div>;

    return (
        <div className="min-h-screen bg-gray-50 p-8">
            <h1 className="text-3xl font-bold mb-8 text-gray-800">Business Analytics</h1>

            {/* Grid Layout */}
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">

                {/* 1. Sales Trends (Line Chart) */}
                <div className="bg-white p-6 rounded-xl shadow-sm border border-gray-100 col-span-2">
                    <h2 className="text-lg font-semibold mb-4">Sales Performance (Last 30 Days)</h2>
                    <div className="h-80">
                        <ResponsiveContainer width="100%" height="100%">
                            <LineChart data={salesData}>
                                <CartesianGrid strokeDasharray="3 3" vertical={false} />
                                <XAxis dataKey="date" />
                                <YAxis />
                                <Tooltip />
                                <Line type="monotone" dataKey="total" stroke="#0EA5E9" strokeWidth={3} dot={{ r: 4 }} />
                            </LineChart>
                        </ResponsiveContainer>
                    </div>
                </div>

                {/* 2. Top Selling Items (Bar Chart) */}
                <div className="bg-white p-6 rounded-xl shadow-sm border border-gray-100">
                    <h2 className="text-lg font-semibold mb-4">Top 5 Products</h2>
                    <div className="h-64">
                        <ResponsiveContainer width="100%" height="100%">
                            <BarChart data={topItems} layout="vertical" margin={{ left: 20 }}>
                                <CartesianGrid strokeDasharray="3 3" horizontal={false} />
                                <XAxis type="number" />
                                <YAxis dataKey="name" type="category" width={100} tick={{ fontSize: 12 }} />
                                <Tooltip />
                                <Bar dataKey="quantity" fill="#10B981" radius={[0, 4, 4, 0]} barSize={20} />
                            </BarChart>
                        </ResponsiveContainer>
                    </div>
                </div>

                {/* 3. Payment Methods (Pie Chart) */}
                <div className="bg-white p-6 rounded-xl shadow-sm border border-gray-100">
                    <h2 className="text-lg font-semibold mb-4">Revenue by Payment Type</h2>
                    <div className="h-64">
                        <ResponsiveContainer width="100%" height="100%">
                            <PieChart>
                                <Pie
                                    data={paymentData}
                                    cx="50%"
                                    cy="50%"
                                    innerRadius={60}
                                    outerRadius={80}
                                    paddingAngle={5}
                                    dataKey="_sum.amount"
                                    nameKey="method"
                                >
                                    {paymentData.map((entry, index) => (
                                        <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                                    ))}
                                </Pie>
                                <Tooltip />
                                <Legend />
                            </PieChart>
                        </ResponsiveContainer>
                    </div>
                </div>

            </div>
        </div>
    );
}

export default withAuth(ReportsPage);

================
File: qristal_dashboard/src/app/globals.css
================
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

================
File: qristal_dashboard/src/app/layout.tsx
================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { AuthProvider } from "@/context/AuthContext"; // Import it

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Qristal Admin",
  description: "Enterprise POS Dashboard",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <AuthProvider>
          {children}
        </AuthProvider>
      </body>
    </html>
  );
}

================
File: qristal_dashboard/src/app/page.tsx
================
"use client";

import withAuth from "@/components/withAuth";
import { useAuth } from "@/context/AuthContext";
import { useCallback, useEffect, useMemo, useState } from "react";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  ReferenceLine,
} from "recharts";
import { io, Socket } from "socket.io-client";
import Link from "next/link";

const SERVER_URL = "https://qristal-pos-api.onrender.com";
const REFRESH_INTERVAL_MS = 10000;
const ORDER_ENDPOINTS = ["/orders", "/orders/kitchen", "/sync/pull?lastSyncTimestamp=1970-01-01T00:00:00.000Z"];

type InventoryItem = {
  id: string;
  name: string;
  sku?: string;
  unitOfMeasure: string;
  currentStock: number;
  minimumStock: number;
  costPerUnit: number;
};

type KdsLane = "KITCHEN" | "BARISTA" | "BAR" | "RETAIL" | "OTHER";

const KDS_LANES: KdsLane[] = ["KITCHEN", "BARISTA", "BAR", "RETAIL", "OTHER"];

type KitchenOrderItem = {
  id: string;
  name: string;
  quantity: number;
  lane: KdsLane;
  modifiers: string[];
  sides: string[];
  notes: string;
};

type KitchenOrder = {
  id: string;
  receiptNumber: string;
  status: string;
  tableId?: string | null;
  createdAt: string;
  totalAmount: number;
  items: KitchenOrderItem[];
};

type DashboardTab = "inventory" | "kds" | "reports";

function asLane(value: unknown): KdsLane {
  if (typeof value !== "string") return "KITCHEN";
  return KDS_LANES.includes(value as KdsLane) ? (value as KdsLane) : "OTHER";
}

function asStringList(value: unknown): string[] {
  if (Array.isArray(value)) return value.map((entry) => String(entry)).filter(Boolean);
  if (typeof value === "string") {
    return value
      .split(",")
      .map((item) => item.trim())
      .filter(Boolean);
  }
  return [];
}

function parseOrderItems(value: unknown): KitchenOrderItem[] {
  if (!Array.isArray(value)) return [];

  return value.map((raw, index) => {
    const item = raw as Record<string, unknown>;
    const product = (item.product as Record<string, unknown> | undefined) || {};

    const lane = asLane(item.productionArea ?? item.production_area ?? product.productionArea ?? product.production_area);

    return {
      id: String(item.id ?? `item-${index}`),
      name: String(item.name ?? item.productName ?? item.product_name ?? product.name ?? "Unnamed item"),
      quantity: Number(item.quantity ?? 1),
      lane,
      modifiers: asStringList(item.modifiers ?? item.modifierGroups ?? item.modifier_groups),
      sides: asStringList(item.sides),
      notes: String(item.notes ?? ""),
    } as KitchenOrderItem;
  });
}

function normalizeKitchenOrders(payload: unknown): KitchenOrder[] {
  const body = payload as Record<string, unknown>;
  const list = Array.isArray(payload)
    ? payload
    : Array.isArray(body?.orders)
      ? body.orders
      : Array.isArray((body?.changes as Record<string, unknown> | undefined)?.orders)
        ? ((body?.changes as Record<string, unknown>).orders as unknown[])
        : [];

  return list
    .map((raw) => {
      const item = raw as Record<string, unknown>;
      return {
        id: String(item.id ?? ""),
        receiptNumber: String(item.receiptNumber ?? item.receipt_number ?? ""),
        status: String(item.status ?? ""),
        tableId: item.tableId ? String(item.tableId) : item.table_id ? String(item.table_id) : null,
        createdAt: String(item.createdAt ?? item.created_at ?? new Date().toISOString()),
        totalAmount: Number(item.totalAmount ?? item.total_amount ?? 0),
        items: parseOrderItems(item.items ?? item.orderItems ?? item.order_items),
      } as KitchenOrder;
    })
    .filter((order) => order.id && ["KITCHEN", "PREPARING"].includes(order.status))
    .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
}

function formatAge(createdAt: string): string {
  const diffMs = Date.now() - new Date(createdAt).getTime();
  const minutes = Math.max(0, Math.floor(diffMs / 60000));
  if (minutes < 1) return "Just now";
  if (minutes < 60) return `${minutes}m ago`;
  const hours = Math.floor(minutes / 60);
  const rem = minutes % 60;
  return `${hours}h ${rem}m ago`;
}

function Dashboard() {
  const { token, logout, user } = useAuth();
  const [inventory, setInventory] = useState<InventoryItem[]>([]);
  const [kitchenOrders, setKitchenOrders] = useState<KitchenOrder[]>([]);
  const [activeTab, setActiveTab] = useState<DashboardTab>("inventory");
  const [activeLane, setActiveLane] = useState<KdsLane | "ALL">("ALL");
  const [loading, setLoading] = useState(true);

  const fetchInventory = useCallback(async () => {
    if (!token) return;
    try {
      const response = await fetch(`${SERVER_URL}/inventory`, {
        cache: "no-store",
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });
      if (response.status === 401) {
        logout();
        return;
      }
      const data = await response.json();
      setInventory(data);
    } catch (error) {
      console.error("Error fetching inventory:", error);
    }
  }, [token, logout]);

  const fetchKitchenOrders = useCallback(async () => {
    if (!token) return;
    try {
      for (const endpoint of ORDER_ENDPOINTS) {
        const response = await fetch(`${SERVER_URL}${endpoint}`, {
          cache: "no-store",
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        if (response.status === 401) {
          logout();
          return;
        }
        if (!response.ok) continue;

        const data = await response.json();
        const normalized = normalizeKitchenOrders(data);
        if (normalized.length > 0 || endpoint === ORDER_ENDPOINTS[ORDER_ENDPOINTS.length - 1]) {
          setKitchenOrders(normalized);
          break;
        }
      }
    } catch (error) {
      console.error("Error fetching kitchen orders:", error);
      setKitchenOrders([]);
    } finally {
      setLoading(false);
    }
  }, [token, logout]);

  useEffect(() => {
    if (!token) return;
    void Promise.all([fetchInventory(), fetchKitchenOrders()]);

    const socket: Socket = io(SERVER_URL, {
      transports: ["websocket", "polling"],
      auth: { token: token },
      reconnection: true,
    });

    socket.on("connect", () => {
      console.log("Dashboard connected to live server!");
    });

    socket.on("connect_error", (error) => {
      console.error(
        "Socket connection error, relying on polling fallback:",
        error.message,
      );
    });

    const handleInventoryUpdate = (updatedInventoryData: InventoryItem[]) => {
      setInventory(updatedInventoryData);
    };

    const refreshTimer = setInterval(() => {
      void fetchInventory();
      void fetchKitchenOrders();
    }, REFRESH_INTERVAL_MS);

    socket.on("inventoryUpdate", handleInventoryUpdate);
    socket.on("inventoryUpdated", handleInventoryUpdate);
    socket.on("newOrder", () => {
      void fetchKitchenOrders();
    });
    socket.on("orderUpdated", () => {
      void fetchKitchenOrders();
    });

    return () => {
      clearInterval(refreshTimer);
      socket.disconnect();
    };
  }, [fetchInventory, fetchKitchenOrders, token]);

  const kdsCounts = useMemo(() => {
    const allItems = kitchenOrders.flatMap((order) => order.items || []);

    return {
      kitchen: kitchenOrders.filter((order) => order.status === "KITCHEN").length,
      preparing: kitchenOrders.filter((order) => order.status === "PREPARING").length,
      byLane: allItems.reduce<Record<KdsLane, number>>(
        (acc, item) => {
          acc[item.lane] += item.quantity;
          return acc;
        },
        { KITCHEN: 0, BARISTA: 0, BAR: 0, RETAIL: 0, OTHER: 0 },
      ),
      totalItems: allItems.reduce((sum, item) => sum + item.quantity, 0),
    };
  }, [kitchenOrders]);

  const visibleOrders = useMemo(() => {
    if (activeLane === "ALL") return kitchenOrders;
    return kitchenOrders.filter((order) => (order.items || []).some((item) => item.lane === activeLane));
  }, [activeLane, kitchenOrders]);

  const laneBoard = useMemo(() => {
    const seed: Record<KdsLane, Array<{ order: KitchenOrder; item: KitchenOrderItem }>> = {
      KITCHEN: [],
      BARISTA: [],
      BAR: [],
      RETAIL: [],
      OTHER: [],
    };

    for (const order of kitchenOrders) {
      for (const item of order.items || []) {
        seed[item.lane].push({ order, item });
      }
    }

    return seed;
  }, [kitchenOrders]);

 

  if (loading) return <div className="p-8">Loading live data...</div>;

  return (
    <main className="min-h-screen bg-gray-50 p-8">
      <div className="max-w-6xl mx-auto">
        <header className="flex justify-between items-center mb-8">
          <div>
            <h1 className="text-3xl font-bold text-gray-900">Qristal Dashboard</h1>
            <p className="text-gray-500">Owner portal with inventory and kitchen operations</p>
          </div>
          <div className="bg-blue-600 text-white px-4 py-2 rounded-lg shadow-sm flex items-center gap-4">
            <span className="font-semibold">{user?.fullName || "User"}</span>
            <button onClick={logout} className="bg-white/20 hover:bg-white/30 px-3 py-1 rounded text-sm transition-colors">Logout</button>
          </div>
        </header>

        <div className="mb-8 border-b border-gray-200">
          <nav className="-mb-px flex space-x-8">
            <button
              className={`pb-3 text-sm font-semibold border-b-2 ${activeTab === "inventory"
                ? "border-blue-500 text-blue-600"
                : "border-transparent text-gray-500 hover:text-gray-700"
                }`}
              onClick={() => setActiveTab("inventory")}
            >
              Inventory
            </button>
            <button
              className={`pb-3 text-sm font-semibold border-b-2 ${activeTab === "kds"
                ? "border-blue-500 text-blue-600"
                : "border-transparent text-gray-500 hover:text-gray-700"
                }`}
              onClick={() => setActiveTab("kds")}
            >
              Web KDS
            </button>
            <Link href="/reports" className="pb-3 text-sm font-semibold border-b-2 border-transparent text-gray-500 hover:text-gray-700">Reports</Link>
          </nav>
        </div>

        {activeTab === "inventory" ? (
          <>
            <div className="bg-white p-6 rounded-xl shadow-sm border border-gray-100 mb-6">
              <h2 className="text-xl font-bold text-gray-800 mb-4">Live Stock Overview</h2>
              <div className="h-72">
                <ResponsiveContainer width="100%" height="100%">
                  <BarChart data={inventory} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
                    <CartesianGrid strokeDasharray="3 3" vertical={false} />
                    <XAxis dataKey="name" axisLine={false} tickLine={false} />
                    <YAxis axisLine={false} tickLine={false} />
                    <Tooltip cursor={{ fill: "#f3f4f6" }} />
                    <Legend />
                    <ReferenceLine y={20} label="Low Stock Warning" stroke="red" strokeDasharray="3 3" />
                    <Bar dataKey="currentStock" name="Current Stock" fill="#0EA5E9" radius={[4, 4, 0, 0]} />
                  </BarChart>
                </ResponsiveContainer>
              </div>
            </div>

            <div className="bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Item Name</th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">SKU</th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Unit</th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Current Stock</th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Unit Cost</th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {inventory.map((item) => (
                    <tr key={item.id} className="hover:bg-gray-50 transition-colors">
                      <td className="px-6 py-4 whitespace-nowrap font-medium text-gray-900">{item.name}</td>
                      <td className="px-6 py-4 whitespace-nowrap text-gray-500">{item.sku || "N/A"}</td>
                      <td className="px-6 py-4 whitespace-nowrap text-gray-500">{item.unitOfMeasure}</td>
                      <td className="px-6 py-4 whitespace-nowrap text-gray-900">{item.currentStock}</td>
                      <td className="px-6 py-4 whitespace-nowrap text-gray-500">UGX {item.costPerUnit}</td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        {item.currentStock > item.minimumStock ? (
                          <span className="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-100 text-green-800">In Stock</span>
                        ) : (
                          <span className="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-red-100 text-red-800">Low Stock</span>
                        )}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </>
        ) : activeTab === "kds" ? (
          <section className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div className="bg-white border border-gray-100 rounded-xl p-4 shadow-sm">
                <p className="text-sm text-gray-500">Queued</p>
                <p className="text-3xl font-bold text-gray-900">{kdsCounts.kitchen}</p>
              </div>
              <div className="bg-white border border-gray-100 rounded-xl p-4 shadow-sm">
                <p className="text-sm text-gray-500">Preparing</p>
                <p className="text-3xl font-bold text-amber-600">{kdsCounts.preparing}</p>
              </div>
              <div className="bg-white border border-gray-100 rounded-xl p-4 shadow-sm">
                <p className="text-sm text-gray-500">Total Active Items</p>
                <p className="text-3xl font-bold text-blue-600">{kdsCounts.totalItems}</p>
              </div>
            </div>

            <div className="bg-white rounded-xl shadow-sm border border-gray-100 p-4">
              <p className="text-sm text-gray-500 mb-3">Production lane routing (items)</p>
              <div className="flex flex-wrap gap-2">
                <button
                  onClick={() => setActiveLane("ALL")}
                  className={`px-3 py-1.5 rounded-full text-xs font-semibold border ${
                    activeLane === "ALL" ? "bg-blue-600 text-white border-blue-600" : "bg-white text-gray-600 border-gray-200"
                  }`}
                >
                  ALL ({kdsCounts.totalItems})
                </button>
                {KDS_LANES.map((lane) => (
                  <button
                    key={lane}
                    onClick={() => setActiveLane(lane)}
                    className={`px-3 py-1.5 rounded-full text-xs font-semibold border ${
                      activeLane === lane ? "bg-blue-600 text-white border-blue-600" : "bg-white text-gray-600 border-gray-200"
                    }`}
                  >
                    {lane} ({kdsCounts.byLane[lane]})
                  </button>
                ))}
              </div>
            </div>

            <div className="bg-white rounded-xl shadow-sm border border-gray-100 p-4">
              <h3 className="text-sm font-semibold text-gray-700 mb-3">Lane board (item tickets)</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-5 gap-3">
                {KDS_LANES.map((lane) => {
                  const entries = laneBoard[lane];
                  return (
                    <div key={lane} className="border border-gray-100 rounded-lg p-3 bg-gray-50 min-h-[12rem]">
                      <div className="flex items-center justify-between mb-2">
                        <p className="font-semibold text-sm text-gray-800">{lane}</p>
                        <span className="text-xs px-2 py-0.5 rounded bg-white border border-gray-200 text-gray-600">{entries.length}</span>
                      </div>
                      <div className="space-y-2">
                        {entries.slice(0, 5).map(({ order, item }) => (
                          <div key={`${order.id}-${item.id}`} className="rounded border border-gray-200 bg-white p-2 text-xs">
                            <p className="font-semibold text-gray-800">#{order.receiptNumber}</p>
                            <p className="text-gray-700 mt-1">{item.quantity}x {item.name}</p>
                            <p className="text-gray-500 mt-1">{formatAge(order.createdAt)}</p>
                          </div>
                        ))}
                        {entries.length > 5 && (
                          <p className="text-xs text-gray-500">+{entries.length - 5} more</p>
                        )}
                        {entries.length === 0 && <p className="text-xs text-gray-400">No items</p>}
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>

            <div className="bg-white rounded-xl shadow-sm border border-gray-100 p-4">
              <p className="text-sm text-gray-500 mb-3">Production lane routing (items)</p>
              <div className="flex flex-wrap gap-2">
                <button
                  onClick={() => setActiveLane("ALL")}
                  className={`px-3 py-1.5 rounded-full text-xs font-semibold border ${
                    activeLane === "ALL" ? "bg-blue-600 text-white border-blue-600" : "bg-white text-gray-600 border-gray-200"
                  }`}
                >
                  ALL ({kitchenOrders.reduce((sum, order) => sum + (order.items?.length || 0), 0)})
                </button>
                {KDS_LANES.map((lane) => (
                  <button
                    key={lane}
                    onClick={() => setActiveLane(lane)}
                    className={`px-3 py-1.5 rounded-full text-xs font-semibold border ${
                      activeLane === lane ? "bg-blue-600 text-white border-blue-600" : "bg-white text-gray-600 border-gray-200"
                    }`}
                  >
                    {lane} ({kdsCounts.byLane[lane]})
                  </button>
                ))}
              </div>
            </div>

            <div className="bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden">
              <div className="px-6 py-4 border-b border-gray-100">
                <h2 className="text-xl font-bold text-gray-800">Kitchen Display Queue</h2>
                <p className="text-sm text-gray-500 mt-1">Live view with station routing, modifiers, and sides when present in payload.</p>
              </div>
              {visibleOrders.length === 0 ? (
                <div className="p-8 text-center text-gray-500">No active orders for the selected lane.</div>
              ) : (
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Order #</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Table</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Routing Details</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Amount</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Created</th>
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {visibleOrders.map((order) => {
                      const displayItems = activeLane === "ALL" ? order.items : order.items.filter((item) => item.lane === activeLane);

                      return (
                        <tr key={order.id} className="hover:bg-gray-50 transition-colors align-top">
                          <td className="px-6 py-4 whitespace-nowrap font-semibold text-gray-900">{order.receiptNumber}</td>
                          <td className="px-6 py-4 whitespace-nowrap text-gray-500">{order.tableId || "Takeaway/Retail"}</td>
                          <td className="px-6 py-4 whitespace-nowrap">
                            <span
                              className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${order.status === "PREPARING"
                                ? "bg-amber-100 text-amber-800"
                                : "bg-blue-100 text-blue-800"
                                }`}
                            >
                              {order.status}
                            </span>
                          </td>
                          <td className="px-6 py-4 text-sm text-gray-600">
                            {displayItems.length === 0 ? (
                              <span className="text-gray-400">No item metadata</span>
                            ) : (
                              <ul className="space-y-2">
                                {displayItems.map((item) => (
                                  <li key={item.id} className="border border-gray-100 rounded-lg p-2 bg-gray-50">
                                    <div className="font-medium text-gray-800">
                                      {item.quantity}x {item.name}
                                      <span className="ml-2 text-xs px-2 py-0.5 rounded bg-indigo-100 text-indigo-700">{item.lane}</span>
                                    </div>
                                    {item.modifiers.length > 0 && (
                                      <div className="text-xs mt-1">Modifiers: {item.modifiers.join(", ")}</div>
                                    )}
                                    {item.sides.length > 0 && <div className="text-xs mt-1">Sides: {item.sides.join(", ")}</div>}
                                    {item.notes && <div className="text-xs mt-1 text-gray-500">Notes: {item.notes}</div>}
                                  </li>
                                ))}
                              </ul>
                            )}
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-gray-700">UGX {order.totalAmount}</td>
                          <td className="px-6 py-4 whitespace-nowrap text-gray-500">{new Date(order.createdAt).toLocaleString()}</td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              )}
            </div>
          </section>
        ) : null}
      </div>
    </main>
  );
}

export default withAuth(Dashboard);

================
File: qristal_dashboard/src/components/withAuth.tsx
================
"use client";

import { useAuth } from "@/context/AuthContext";
import { useRouter } from "next/navigation";
import { useEffect } from "react";

export default function withAuth(Component: any) {
  return function ProtectedRoute(props: any) {
    const { user, isLoading } = useAuth();
    const router = useRouter();

    useEffect(() => {
      if (!isLoading && !user) {
        router.push("/login");
      }
    }, [user, isLoading, router]);

    if (isLoading) {
      return <div className="min-h-screen flex items-center justify-center">Loading...</div>;
    }

    if (!user) {
      return null; // Will redirect in useEffect
    }

    return <Component {...props} />;
  };
}

================
File: qristal_dashboard/src/context/AuthContext.tsx
================
"use client";

import { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { useRouter } from "next/navigation";

// Define the shape of our User and AuthContext
interface User {
    id: string;
    fullName: string;
    role: string;
    branchId: string;
}

interface AuthContextType {
    user: User | null;
    token: string | null;
    login: (id: string, pin: string) => Promise<void>;
    logout: () => void;
    isLoading: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

// Define server URL (ensure this matches your environment)
const SERVER_URL = "https://qristal-pos-api.onrender.com";

export function AuthProvider({ children }: { children: ReactNode }) {
    const [user, setUser] = useState<User | null>(null);
    const [token, setToken] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState(true);
    const router = useRouter();

    // On mount, check for existing session in localStorage
    useEffect(() => {
        const storedToken = localStorage.getItem("qristal_token");
        const storedUser = localStorage.getItem("qristal_user");

        if (storedToken && storedUser) {
            setToken(storedToken);
            setUser(JSON.parse(storedUser));
        }
        setIsLoading(false);
    }, []);

    const login = async (id: string, pin: string) => {
        try {
            const response = await fetch(`${SERVER_URL}/auth/login`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ id, pin }),
            });

            if (!response.ok) {
                throw new Error("Login failed");
            }

            const data = await response.json();

            // Save to state
            setToken(data.access_token);
            setUser(data.user);

            // Persist to local storage
            localStorage.setItem("qristal_token", data.access_token);
            localStorage.setItem("qristal_user", JSON.stringify(data.user));

            router.push("/"); // Redirect to dashboard home
        } catch (error) {
            console.error("Login Error:", error);
            throw error; // Propagate error to the UI component to handle
        }
    };

    const logout = () => {
        setUser(null);
        setToken(null);
        localStorage.removeItem("qristal_token");
        localStorage.removeItem("qristal_user");
        router.push("/login");
    };

    return (
        <AuthContext.Provider value={{ user, token, login, logout, isLoading }}>
            {children}
        </AuthContext.Provider>
    );
}

// Helper hook to use the context easily
export const useAuth = () => {
    const context = useContext(AuthContext);
    if (context === undefined) {
        throw new Error("useAuth must be used within an AuthProvider");
    }
    return context;
};

================
File: qristal_dashboard/.git
================
gitdir: ../.git/modules/qristal_dashboard

================
File: qristal_dashboard/.gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
.env*.local

================
File: qristal_dashboard/eslint.config.mjs
================
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;

================
File: qristal_dashboard/next.config.ts
================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

================
File: qristal_dashboard/package.json
================
{
  "name": "qristal-dashboard",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "next": "16.1.6",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "recharts": "^3.7.0",
    "socket.io-client": "^4.8.3"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "16.1.6",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}

================
File: qristal_dashboard/postcss.config.mjs
================
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;

================
File: qristal_dashboard/README.md
================
# Qristal Dashboard

The web-based admin portal for the Qristal POS system. Built with [Next.js](https://nextjs.org), React, and Tailwind CSS  it provides management tools for menu configuration, staff, inventory, tables, analytics, and reporting.

Developed and maintained by **[Truthy Systems](https://truthysystems.com)**.

---

## Tech Stack

- **Framework:** Next.js 15 (App Router, TypeScript)
- **Styling:** Tailwind CSS
- **Auth:** JWT-based session via context
- **API:** Connects to `qristal_api`

---

## Features

- Secure login with role-based access (Owner / Manager)
- Menu management  categories and products
- User / staff management
- Inventory overview
- Table & seating configuration
- Sales analytics
- Reporting (shift summaries, sales by period)

---

## Prerequisites

- Node.js 20+
- A running instance of `qristal_api`

---

## Setup

### 1. Install dependencies

```bash
npm install
```

### 2. Configure environment

Create a `.env.local` file:

```env
NEXT_PUBLIC_API_URL=http://localhost:3000
```

### 3. Start the development server

```bash
npm run dev
```

Open [http://localhost:3001](http://localhost:3001) in your browser (or the port shown in the terminal).

---

## Building for Production

```bash
npm run build
npm run start
```

---

## Project Structure

```
src/
  app/
    login/          # Login page
    admin/
      menu/         # Menu management
      users/        # Staff management
      inventory/    # Inventory management
      tables/       # Seating management
      analytics/    # Analytics overview
    reports/        # Reporting
  components/       # Shared UI components (withAuth HOC, etc.)
  context/          # AuthContext  JWT session management
```

---

## Deployment

The dashboard can be deployed to any platform that supports Next.js  [Vercel](https://vercel.com) is the easiest option:

```bash
npm install -g vercel
vercel
```

Set `NEXT_PUBLIC_API_URL` to your production API URL in your deployment environment.

---

## Developer

Built by **[Truthy Systems](https://truthysystems.com)**.

================
File: qristal_dashboard/tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}

================
File: qristal_mobile/.git
================
gitdir: ../.git/modules/qristal_mobile

================
File: gitmodules.txt
================
[submodule "qristal_mobile"]
    path = qristal_mobile
    url = https://github.com/linTruthy/Qristal-POS-Mobile

[submodule "qristal_dashboard"]
    path = qristal_dashboard
    url = https://github.com/linTruthy/qristal-dashboard
[submodule "qristal_api"]
	path = qristal_api
	url = https://github.com/linTruthy/qristal-api

================
File: repomix.config.json
================
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output.txt",
    "style": "plain",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "includeFullDirectoryStructure": false,
    "tokenCountTree": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false,
      "includeLogs": false,
      "includeLogsCount": 50
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDotIgnore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}

================
File: qristal_mobile/android/app/src/debug/AndroidManifest.xml
================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

================
File: qristal_mobile/android/app/src/main/res/drawable/launch_background.xml
================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

================
File: qristal_mobile/android/app/src/main/res/drawable-v21/launch_background.xml
================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

================
File: qristal_mobile/android/app/src/main/res/values/styles.xml
================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

================
File: qristal_mobile/android/app/src/main/res/values-night/styles.xml
================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

================
File: qristal_mobile/android/app/src/profile/AndroidManifest.xml
================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

================
File: qristal_mobile/lib/core/providers/database_provider.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../database/database.dart';

// The single instance of our local SQLite database
final databaseProvider = Provider<AppDatabase>((ref) {
  return AppDatabase();
});

================
File: qristal_mobile/lib/core/theme/app_theme.dart
================
import 'package:flutter/material.dart';

class AppTheme {
  static const Color background = Color(0xFF121212);
  static const Color surface = Color(0xFF1E1E1E);
  static const Color qristalBlue = Color(0xFF0EA5E9); // Light Blue
  static const Color emerald = Color(0xFF10B981); // Emerald Green
  static const Color error = Color(0xFFEF4444);

  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      scaffoldBackgroundColor: background,
      colorScheme: const ColorScheme.dark(
        primary: qristalBlue,
        secondary: emerald,
        surface: surface,
        error: error,
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: surface,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Colors.white10),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: qristalBlue),
        ),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: qristalBlue,
          foregroundColor: Colors.white,
          padding: const EdgeInsets.symmetric(vertical: 20),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          textStyle: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        ),
      ),
    );
  }
}

================
File: qristal_mobile/lib/features/pos/providers/menu_provider.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/providers/database_provider.dart';
import '../../../database/database.dart';


// Tracks which category is currently selected in the UI
final selectedCategoryProvider = StateProvider<String?>((ref) => null);

// Watches all categories from DB
final categoriesStreamProvider = StreamProvider<List<Category>>((ref) {
  final db = ref.watch(databaseProvider);
  return db.select(db.categories).watch();
});

// Watches products, filtered by the selected category
final productsStreamProvider = StreamProvider<List<Product>>((ref) {
  final db = ref.watch(databaseProvider);
  final selectedCatId = ref.watch(selectedCategoryProvider);

  if (selectedCatId == null) {
    // If no category selected, return all (or none, depending on preference)
    return db.select(db.products).watch();
  }
  
  return (db.select(db.products)
    ..where((tbl) => tbl.categoryId.equals(selectedCatId)))
    .watch();
});

================
File: qristal_mobile/lib/features/sync/providers/sync_provider.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/providers/database_provider.dart';
import '../../../services/sync_service.dart';


// Service Provider
final syncServiceProvider = Provider<SyncService>((ref) {
  final db = ref.watch(databaseProvider);
  return SyncService(db);
});

// State Controller
class SyncController extends StateNotifier<AsyncValue<void>> {
  final SyncService _service;

  SyncController(this._service) : super(const AsyncData(null));

  Future<void> performSync() async {
    state = const AsyncLoading();
    try {
      await _service.syncData();
      state = const AsyncData(null);
    } catch (e, st) {
      state = AsyncError(e, st);
    }
  }
}

// Global Provider
final syncControllerProvider = StateNotifierProvider<SyncController, AsyncValue<void>>((ref) {
  return SyncController(ref.watch(syncServiceProvider));
});

================
File: qristal_mobile/test/widget_test.dart
================
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';



void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
  

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}

================
File: qristal_mobile/windows/flutter/CMakeLists.txt
================
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)

================
File: qristal_mobile/windows/flutter/generated_plugin_registrant.h
================
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter/plugin_registry.h>

// Registers Flutter plugins.
void RegisterPlugins(flutter::PluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_

================
File: qristal_mobile/windows/runner/CMakeLists.txt
================
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)

================
File: qristal_mobile/windows/runner/flutter_window.cpp
================
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}

================
File: qristal_mobile/windows/runner/flutter_window.h
================
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_

================
File: qristal_mobile/windows/runner/main.cpp
================
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"Qristal POS", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}

================
File: qristal_mobile/windows/runner/resource.h
================
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

================
File: qristal_mobile/windows/runner/runner.exe.manifest
================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
      <!-- Windows 8.1 -->
      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
      <!-- Windows 8 -->
      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
      <!-- Windows 7 -->
      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
    </application>
  </compatibility>
</assembly>

================
File: qristal_mobile/windows/runner/Runner.rc
================
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#if defined(FLUTTER_VERSION_MAJOR) && defined(FLUTTER_VERSION_MINOR) && defined(FLUTTER_VERSION_PATCH) && defined(FLUTTER_VERSION_BUILD)
#define VERSION_AS_NUMBER FLUTTER_VERSION_MAJOR,FLUTTER_VERSION_MINOR,FLUTTER_VERSION_PATCH,FLUTTER_VERSION_BUILD
#else
#define VERSION_AS_NUMBER 1,0,0,0
#endif

#if defined(FLUTTER_VERSION)
#define VERSION_AS_STRING FLUTTER_VERSION
#else
#define VERSION_AS_STRING "1.0.0"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "Truthy Systems" "\0"
            VALUE "FileDescription", "Qristal POS" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "Qristal POS" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2026 Truthy Systems. All rights reserved." "\0"
            VALUE "OriginalFilename", "QristalPOS.exe" "\0"
            VALUE "ProductName", "Qristal POS" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

================
File: qristal_mobile/windows/runner/utils.cpp
================
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}

================
File: qristal_mobile/windows/runner/utils.h
================
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_

================
File: qristal_mobile/windows/runner/win32_window.cpp
================
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}

================
File: qristal_mobile/windows/runner/win32_window.h
================
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_

================
File: qristal_mobile/windows/.gitignore
================
flutter/ephemeral/

# Visual Studio user-specific files.
*.suo
*.user
*.userosscache
*.sln.docstates

# Visual Studio build-related files.
x64/
x86/

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!*.[Cc]ache/

================
File: qristal_mobile/windows/CMakeLists.txt
================
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(qristal_mobile LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "qristal_mobile")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/windows/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)

================
File: qristal_mobile/analysis_options.yaml
================
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options

================
File: README.md
================
# Qristal POS

A full-stack, offline-capable Point of Sale system for restaurants and hospitality businesses  built and maintained by [Truthy Systems](https://truthysystems.com).

Qristal POS is composed of three sub-repositories managed as Git submodules:

| Repo | Description | Stack |
|------|-------------|-------|
| [`qristal_api`](./qristal_api) | Backend REST API & WebSocket server | NestJS  PostgreSQL  Prisma |
| [`qristal_dashboard`](./qristal_dashboard) | Web-based admin & reporting dashboard | Next.js  React  Tailwind CSS |
| [`qristal_mobile`](./qristal_mobile) | Offline-first POS terminal app | Flutter  Drift (SQLite) |

---

## System Overview

```

                   qristal_api                        
  NestJS REST API + WebSocket Gateway (PostgreSQL)   

                         HTTP / WebSocket
        
                                     
          
qristal_dashboard            qristal_mobile     
 Next.js (Web)              Flutter (Android/  
 Admin Portal               iOS / Windows)     
          
```

The mobile app operates fully offline and syncs with the API when a connection is available. The dashboard provides management tools  menu editing, user management, inventory, analytics, and reporting.

---

## Cloning the Monorepo

```bash
git clone --recurse-submodules <repo-url>
```

Or if already cloned:

```bash
git submodule update --init --recursive
```

---

## Features

- **PIN-based staff authentication** with role-based access (Owner, Manager, Cashier, Waiter, Kitchen)
- **Offline-first POS**  orders, payments, and shifts work without internet
- **Real-time sync**  push/pull architecture with WebSocket live updates
- **Table & floor plan management**
- **Kitchen display routing**  items routed to Kitchen, Bar, Barista, etc.
- **Shift management**  open/close shifts with cash reconciliation
- **Inventory tracking** with recipe-based stock deduction
- **Multi-branch ready**  branch isolation built into the data model
- **Audit logs**  void, discount, and cash flow events are tracked
- **Receipt printing** via Bluetooth thermal printer (mobile)
- **Analytics & reports** via the web dashboard

---

## Getting Started

Each sub-project has its own setup guide. See the respective `README.md`:

- [API Setup ](./qristal_api/README.md)
- [Dashboard Setup ](./qristal_dashboard/README.md)
- [Mobile App Setup ](./qristal_mobile/README.md)

---

## Developer

Built by **[Truthy Systems](https://truthysystems.com)**  software solutions for modern businesses.

================
File: .idx/dev.nix
================
{ pkgs, ... }: {
  # Which nixpkgs channel to use.
  channel = "unstable"; 
  
  # Use https://search.nixos.org/packages to find packages
  packages = [
    pkgs.docker
    pkgs.docker-compose # Added for convenience
    pkgs.openssl
    pkgs.nodejs_20
    pkgs.flutter
    pkgs.openssh
  ];

  # Enable the Docker daemon service
  services.docker.enable = true;

  # Sets environment variables in the workspace
  env = {};
  
  idx = {
    extensions = [
      "google.gemini-cli-vscode-ide-companion"
    ];
    previews = {
      enable = true;
      previews = {
        # web = {
        #   command = ["npm" "run" "dev"];
        #   manager = "web";
        #   env = {
        #     PORT = "$PORT";
        #   };
        # };
      };
    };
    workspace = {
      onCreate = {
        default.openFiles = [ ".idx/dev.nix" "README.md" ];
      };
      onStart = {
      };
    };
  };
}

================
File: qristal_mobile/.vscode/settings.json
================
{
    "cmake.sourceDirectory": "C:/Users/Conrad/source/repos/Qristal-POS-Mobile-2/windows"
}

================
File: qristal_mobile/android/app/src/main/kotlin/com/truthysystems/qristal_mobile/MainActivity.kt
================
package com.truthysystems.qristal_mobile

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()

================
File: qristal_mobile/android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
  <background android:drawable="@mipmap/ic_launcher_background"/>
  <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
  <monochrome android:drawable="@mipmap/ic_launcher_monochrome"/>
</adaptive-icon>

================
File: qristal_mobile/android/app/build.gradle.kts
================
plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.truthysystems.qristal_mobile"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_11.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.truthysystems.qristal_mobile"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}

================
File: qristal_mobile/android/gradle/wrapper/gradle-wrapper.properties
================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.12-all.zip

================
File: qristal_mobile/android/.gitignore
================
gradle-wrapper.jar
/.gradle
/captures/
/gradlew
/gradlew.bat
/local.properties
GeneratedPluginRegistrant.java
.cxx/

# Remember to never publicly share your keystore.
# See https://flutter.dev/to/reference-keystore
key.properties
**/*.keystore
**/*.jks

================
File: qristal_mobile/android/build.gradle.kts
================
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory =
    rootProject.layout.buildDirectory
        .dir("../../build")
        .get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}

================
File: qristal_mobile/android/gradle.properties
================
org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true
android.enableJetifier=true

================
File: qristal_mobile/android/settings.gradle.kts
================
pluginManagement {
    val flutterSdkPath =
        run {
            val properties = java.util.Properties()
            file("local.properties").inputStream().use { properties.load(it) }
            val flutterSdkPath = properties.getProperty("flutter.sdk")
            require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
            flutterSdkPath
        }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.9.1" apply false
    id("org.jetbrains.kotlin.android") version "2.1.0" apply false
}

include(":app")

================
File: qristal_mobile/lib/core/constants/role_constants.dart
================
enum UserRole {
  OWNER,
  MANAGER,
  CASHIER,
  WAITER,
  KITCHEN
}

extension UserRoleExtension on String {
  UserRole toUserRole() {
    return UserRole.values.firstWhere(
      (e) => e.toString().split('.').last == this,
      orElse: () => UserRole.WAITER,
    );
  }
}

================
File: qristal_mobile/lib/features/pos/models/cart_item.dart
================
import '../../../database/database.dart';

class CartModifier {
  final String name;
  final double priceDelta;
  final String? routeTo;

  const CartModifier({
    required this.name,
    this.priceDelta = 0,
    this.routeTo,
  });
}

class CartSide {
  final String name;
  final int quantity;
  final double priceDelta;
  final String? routeTo;

  const CartSide({
    required this.name,
    this.quantity = 1,
    this.priceDelta = 0,
    this.routeTo,
  });
}

class CartItem {
  final Product product;
  final int quantity;
  final String notes;
  final String? routeTo;
  final List<CartModifier> modifiers;
  final List<CartSide> sides;

  CartItem({
    required this.product,
    this.quantity = 1,
    this.notes = '',
    this.routeTo,
    this.modifiers = const [],
    this.sides = const [],
  });

  double get perItemTotal {
    final modifiersTotal = modifiers.fold<double>(0, (sum, m) => sum + m.priceDelta);
    final sidesTotal = sides.fold<double>(
      0,
      (sum, s) => sum + (s.priceDelta * s.quantity),
    );
    return product.price + modifiersTotal + sidesTotal;
  }

  double get total => perItemTotal * quantity;

  CartItem copyWith({
    int? quantity,
    String? notes,
    String? routeTo,
    List<CartModifier>? modifiers,
    List<CartSide>? sides,
  }) {
    return CartItem(
      product: product,
      quantity: quantity ?? this.quantity,
      notes: notes ?? this.notes,
      routeTo: routeTo ?? this.routeTo,
      modifiers: modifiers ?? this.modifiers,
      sides: sides ?? this.sides,
    );
  }
}

================
File: qristal_mobile/lib/features/pos/widgets/payment_modal.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/theme/app_theme.dart';

class PaymentModal extends ConsumerStatefulWidget {
  final double totalAmount;
  final Function(String method, double amount, String? ref) onConfirmed;

  const PaymentModal({
    super.key,
    required this.totalAmount,
    required this.onConfirmed,
  });

  @override
  ConsumerState<PaymentModal> createState() => _PaymentModalState();
}

class _PaymentModalState extends ConsumerState<PaymentModal> {
  String _selectedMethod = 'CASH';
  final TextEditingController _amountController = TextEditingController();
  final TextEditingController _refController =
      TextEditingController(); // For Mobile Money

  @override
  void initState() {
    super.initState();
    _amountController.text =
        widget.totalAmount.toStringAsFixed(0); // Default to full amount
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        width: 500,
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Header
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text("Settle Order",
                    style:
                        TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),
                IconButton(
                    icon: const Icon(Icons.close),
                    onPressed: () => Navigator.pop(context)),
              ],
            ),
            const Divider(),
            const SizedBox(height: 16),

            // Total Display
            Center(
              child: Text(
                "Total Due: ugx ${widget.totalAmount.toStringAsFixed(0)}",
                style: const TextStyle(
                    fontSize: 32,
                    fontWeight: FontWeight.bold,
                    color: AppTheme.emerald),
              ),
            ),
            const SizedBox(height: 24),

            // Payment Methods Tabs
            Row(
              children: [
                _methodCard("CASH", Icons.money, Colors.green),
                const SizedBox(width: 10),
                _methodCard("MOBILE_MONEY", Icons.phone_android, Colors.amber),
                const SizedBox(width: 10),
                _methodCard("CARD", Icons.credit_card, Colors.blue),
              ],
            ),
            const SizedBox(height: 24),

            // Input Fields
            TextField(
              controller: _amountController,
              keyboardType: TextInputType.number,
              decoration: const InputDecoration(labelText: "Amount Tendered"),
              style: const TextStyle(fontSize: 24),
            ),

            if (_selectedMethod == 'MOBILE_MONEY') ...[
              const SizedBox(height: 10),
              TextField(
                controller: _refController,
                decoration: const InputDecoration(
                    labelText: "Transaction Reference (Optional)"),
              ),
            ],

            const SizedBox(height: 24),

            // Quick Cash Buttons
            if (_selectedMethod == 'CASH')
              Wrap(
                spacing: 10,
                children: [500, 1000, 2000, 5000, 10000, 20000, 50000]
                    .map((amount) => ActionChip(
                          label: Text(amount.toString()),
                          onPressed: () =>
                              _amountController.text = amount.toString(),
                        ))
                    .toList(),
              ),

            const SizedBox(height: 24),

            // Complete Button
            SizedBox(
              height: 60,
              child: ElevatedButton(
                style:
                    ElevatedButton.styleFrom(backgroundColor: AppTheme.emerald),
                onPressed: () {
                  final tendered = double.tryParse(_amountController.text) ?? 0;
                  if (tendered < widget.totalAmount) {
                    ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(content: Text("Insufficient Amount")));
                    return;
                  }

                  // Calculate Change
                  final change = tendered - widget.totalAmount;
                  if (change > 0) {
                    ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text("Change Due: $change")));
                  }

                  widget.onConfirmed(_selectedMethod, tendered,
                      _refController.text.isEmpty ? null : _refController.text);
                  Navigator.pop(context);
                },
                child: const Text("COMPLETE PAYMENT",
                    style: TextStyle(fontSize: 20)),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _methodCard(String id, IconData icon, Color color) {
    final isSelected = _selectedMethod == id;
    return Expanded(
      child: GestureDetector(
        onTap: () => setState(() => _selectedMethod = id),
        child: Container(
          height: 80,
          decoration: BoxDecoration(
            color: isSelected ? color.withOpacity(0.2) : AppTheme.surface,
            border: Border.all(
                color: isSelected ? color : Colors.transparent, width: 2),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(icon, color: isSelected ? color : Colors.grey, size: 30),
              const SizedBox(height: 4),
              Text(id.replaceAll('_', ' '),
                  style: TextStyle(
                      color: isSelected ? color : Colors.grey, fontSize: 12)),
            ],
          ),
        ),
      ),
    );
  }
}

================
File: qristal_mobile/lib/features/sync/providers/sync_queue_provider.dart
================
import 'dart:async';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/providers/database_provider.dart';
import 'sync_provider.dart';

enum ConnectionStatus { online, offline, syncing, error }

class SyncQueueState {
  final ConnectionStatus status;
  final int pendingOrders;

  SyncQueueState({
    this.status = ConnectionStatus.online,
    this.pendingOrders = 0,
  });

  SyncQueueState copyWith({ConnectionStatus? status, int? pendingOrders}) {
    return SyncQueueState(
      status: status ?? this.status,
      pendingOrders: pendingOrders ?? this.pendingOrders,
    );
  }
}

class SyncQueueManager extends StateNotifier<SyncQueueState> {
  final Ref ref;
  Timer? _timer;
  StreamSubscription? _connectivitySubscription;
  StreamSubscription? _dbSubscription;

  SyncQueueManager(this.ref) : super(SyncQueueState()) {
    _init();
  }

  void _init() {
    // 1. Listen to Network Connectivity changes
    _connectivitySubscription = Connectivity().onConnectivityChanged.listen((
      List<ConnectivityResult> results,
    ) {
      if (results.contains(ConnectivityResult.none)) {
        state = state.copyWith(status: ConnectionStatus.offline);
      } else {
        state = state.copyWith(status: ConnectionStatus.online);
        _triggerSync(); // Device came online -> attempt sync!
      }
    });

    // 2. Listen to Database for Unsynced Orders
    final db = ref.read(databaseProvider);
    _dbSubscription =
        (db.select(
          db.orders,
        )..where((t) => t.isSynced.equals(false))).watch().listen((orders) {
          state = state.copyWith(pendingOrders: orders.length);
          if (orders.isNotEmpty && state.status == ConnectionStatus.online) {
            _triggerSync(); // New order added -> attempt sync!
          }
        });

    // 3. Fallback Heartbeat Timer (Retry every 30 seconds if something is pending)
    _timer = Timer.periodic(const Duration(seconds: 30), (_) {
      if (state.pendingOrders > 0 && state.status != ConnectionStatus.offline) {
        _triggerSync();
      }
    });
  }

  Future<void> _triggerSync() async {
    // Prevent overlapping syncs
    if (state.status == ConnectionStatus.syncing || state.pendingOrders == 0) {
      return;
    }

    state = state.copyWith(status: ConnectionStatus.syncing);
    try {
      await ref.read(syncServiceProvider).syncData();
      state = state.copyWith(status: ConnectionStatus.online);
    } catch (e) {
      state = state.copyWith(status: ConnectionStatus.error);
    }
  }

  @override
  void dispose() {
    _timer?.cancel();
    _connectivitySubscription?.cancel();
    _dbSubscription?.cancel();
    super.dispose();
  }
}

// Global Provider
final syncQueueProvider =
    StateNotifierProvider<SyncQueueManager, SyncQueueState>((ref) {
      return SyncQueueManager(ref);
    });

================
File: qristal_mobile/lib/features/tables/screens/floor_plan_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/theme/app_theme.dart';
import '../../../core/providers/database_provider.dart';
import '../../../database/database.dart';
import '../../pos/screens/dashboard_screen.dart';

// Provider to hold the currently selected table ID
final activeTableIdProvider = StateProvider<String?>((ref) => null);

class FloorPlanScreen extends ConsumerWidget {
  const FloorPlanScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final db = ref.watch(databaseProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text("Select Table"),
        actions: [
          // Quick button for Takeaway (No table)
          TextButton.icon(
            icon: const Icon(Icons.shopping_bag),
            label: const Text("TAKEAWAY / RETAIL"),
            onPressed: () {
              ref.read(activeTableIdProvider.notifier).state = null;
              Navigator.push(
                context,
                MaterialPageRoute(builder: (_) => const DashboardScreen()),
              );
            },
          ),
        ],
      ),
      body: StreamBuilder<List<SeatingTable>>(
        stream: db.select(db.seatingTables).watch(),
        builder: (context, snapshot) {
          if (!snapshot.hasData) {
            return const Center(child: CircularProgressIndicator());
          }

          final tables = snapshot.data!;

          return GridView.builder(
            padding: const EdgeInsets.all(20),
            gridDelegate: const SliverGridDelegateWithMaxCrossAxisExtent(
              maxCrossAxisExtent: 200,
              crossAxisSpacing: 20,
              mainAxisSpacing: 20,
              childAspectRatio: 1.5,
            ),
            itemCount: tables.length,
            itemBuilder: (context, index) {
              final table = tables[index];
              final isOccupied = table.status == 'OCCUPIED';

              return GestureDetector(
                onTap: () {
                  // Set active table and go to POS
                  ref.read(activeTableIdProvider.notifier).state = table.id;
                  Navigator.push(
                    context,
                    MaterialPageRoute(builder: (_) => const DashboardScreen()),
                  );
                },
                child: Container(
                  decoration: BoxDecoration(
                    color: isOccupied
                        ? AppTheme.error.withOpacity(0.8)
                        : AppTheme.emerald.withOpacity(0.8),
                    borderRadius: BorderRadius.circular(16),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.2),
                        blurRadius: 4,
                        offset: const Offset(2, 2),
                      ),
                    ],
                  ),
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        isOccupied ? Icons.person : Icons.table_restaurant,
                        size: 40,
                        color: Colors.white,
                      ),
                      const SizedBox(height: 10),
                      Text(
                        table.name,
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 24,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Text(
                        table.status,
                        style: const TextStyle(
                          color: Colors.white70,
                          fontSize: 14,
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          );
        },
      ),
    );
  }
}

================
File: qristal_mobile/.gitignore
================
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.buildlog/
.history
.svn/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.pub-cache/
.pub/
/build/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release

sentry.properties

================
File: qristal_mobile/.metadata
================
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "05db9689081f091050f01aed79f04dce0c750154"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: 05db9689081f091050f01aed79f04dce0c750154
      base_revision: 05db9689081f091050f01aed79f04dce0c750154
    - platform: android
      create_revision: 05db9689081f091050f01aed79f04dce0c750154
      base_revision: 05db9689081f091050f01aed79f04dce0c750154
    - platform: ios
      create_revision: 05db9689081f091050f01aed79f04dce0c750154
      base_revision: 05db9689081f091050f01aed79f04dce0c750154
    - platform: linux
      create_revision: 05db9689081f091050f01aed79f04dce0c750154
      base_revision: 05db9689081f091050f01aed79f04dce0c750154
    - platform: macos
      create_revision: 05db9689081f091050f01aed79f04dce0c750154
      base_revision: 05db9689081f091050f01aed79f04dce0c750154
    - platform: web
      create_revision: 05db9689081f091050f01aed79f04dce0c750154
      base_revision: 05db9689081f091050f01aed79f04dce0c750154
    - platform: windows
      create_revision: 05db9689081f091050f01aed79f04dce0c750154
      base_revision: 05db9689081f091050f01aed79f04dce0c750154

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'

================
File: qristal_mobile/.repomixignore
================
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

================
File: qristal_mobile/README.md
================
# Qristal Mobile (POS Terminal)

The offline-first POS terminal application for the Qristal POS system. Built with Flutter, it runs on Android, iOS, and Windows and is designed for waitstaff and cashiers at the point of sale.

Developed and maintained by **[Truthy Systems](https://truthysystems.com)**.

---

## Tech Stack

- **Framework:** Flutter (Dart)
- **Local database:** Drift (SQLite)
- **State management:** Riverpod
- **Auth:** JWT stored via `flutter_secure_storage`
- **Printing:** Bluetooth thermal receipt printer
- **Error tracking:** Sentry
- **Real-time:** WebSocket (connected to `qristal_api`)

---

## Features

- PIN-based login with role-aware UI (Cashier, Waiter, Kitchen, Manager, Owner)
- Offline-first order taking  works without internet
- Background sync  push unsynced orders/payments/shifts, pull menu and table updates
- Cart management with product modifiers and sides
- Kitchen routing  items dispatched to Kitchen, Bar, Barista, etc.
- Table & floor plan selection
- Shift management  open/close shifts with starting and actual cash reconciliation
- Receipt printing via Bluetooth thermal printer
- Kitchen display screen (KDS) for kitchen staff
- Real-time order status updates via WebSocket

---

## Prerequisites

- Flutter SDK 3.x
- Android SDK / Xcode (for mobile targets) or Visual Studio (for Windows)
- A running instance of `qristal_api`

---

## Setup

### 1. Install Flutter dependencies

```bash
flutter pub get
```

### 2. Configure the API URL

Edit `lib/core/constants/api_constants.dart`:

```dart
static String get baseUrl {
  return 'https://your-api-url.com'; // Replace with your API endpoint
}
```

### 3. Generate Drift database code

```bash
dart run build_runner build --delete-conflicting-outputs
```

### 4. Run the app

```bash
# Android
flutter run

# Windows
flutter run -d windows
```

---

## Building for Release

```bash
# Android APK
flutter build apk --release

# Android App Bundle
flutter build appbundle --release

# Windows
flutter build windows --release
```

---

## Project Structure

```
lib/
  core/
    constants/        # API endpoints, role definitions
    providers/        # Database provider
    theme/            # App theme
  database/           # Drift database schema & generated code
  features/
    auth/             # Login screen, auth service, auth provider
    hardware/         # Bluetooth printer service & receipt generator
    kitchen/          # Kitchen display screen
    pos/              # Dashboard, cart, menu provider, order service, payment modal
    shifts/           # Open/close shift screens and provider
    sync/             # Sync provider and queue
    tables/           # Floor plan screen
  services/
    sync_service.dart     # Pull/push sync logic
    websocket_service.dart
  main.dart
```

---

## Sync Architecture

The mobile app uses a timestamp-based sync strategy:

- **Pull**  fetches menu, tables, and shifts updated since the last sync timestamp
- **Push**  sends unsynced orders, payments, shifts, and table status changes to the API
- Sync runs on app start and can be triggered manually

---

## Supported Platforms

| Platform | Status |
|----------|--------|
| Android |  Supported |
| Windows |  Supported |
| iOS |  Configured (not primary target) |

---

## Developer

Built by **[Truthy Systems](https://truthysystems.com)**.

================
File: qristal_mobile/repomix.config.json
================
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output.txt",
    "style": "plain",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "includeFullDirectoryStructure": false,
    "tokenCountTree": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false,
      "includeLogs": false,
      "includeLogsCount": 50
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDotIgnore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}

================
File: qristal_mobile/lib/core/constants/api_constants.dart
================
class ApiConstants {
  // Use 10.0.2.2 for Android Emulator, localhost for iOS/Web
static String get baseUrl {
    // Return your Railway URL (HTTPS is standard)
    //return 'https://api.truthysystems.com';
    return 'https://qristal-pos-api.onrender.com';
  }

  static const String loginEndpoint = '/auth/login';
  static const String syncPushEndpoint = '/sync/push';
}

================
File: qristal_mobile/lib/features/auth/services/auth_service.dart
================
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import '../../../core/constants/api_constants.dart';
import '../../../core/constants/role_constants.dart';

class AuthService {
  final _storage = const FlutterSecureStorage();

  Future<Map<String, dynamic>> login(String userId, String pin) async {
    try {
      final response = await http.post(
        Uri.parse('${ApiConstants.baseUrl}${ApiConstants.loginEndpoint}'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({'id': userId, 'pin': pin}),
      );
      print(pin);
      print(userId);
     
      if (response.statusCode == 201 || response.statusCode == 200) {
        final data = jsonDecode(response.body);
        print('Response body: ${response.body}');

        // Save Token Securely
        await _storage.write(key: 'jwt_token', value: data['access_token']);

        // Save User Data (optional, for offline reference)
        await _storage.write(key: 'user_data', value: jsonEncode(data['user']));

        return data;
      } else {
        throw Exception('Invalid PIN or User ID');
      }
    } catch (e) {
      throw Exception('Connection failed: $e');
    }
  }

  Future<void> logout() async {
    await _storage.deleteAll();
  }

  Future<String?> getToken() async {
    return await _storage.read(key: 'jwt_token');
  }

  Future<UserRole> getRole() async {
    final userDataString = await _storage.read(key: 'user_data');
    if (userDataString == null) {
      return UserRole.WAITER; // Default role
    }
    final userData = jsonDecode(userDataString);
    return (userData['role'] as String).toUserRole();
  }
}

================
File: qristal_mobile/lib/features/shifts/providers/shift_provider.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import 'package:drift/drift.dart';
import '../../../core/providers/database_provider.dart';
import '../../../database/database.dart';

// Holds the currently active Shift ID
final activeShiftIdProvider = StateProvider<String?>((ref) => null);

class ShiftService {
  final AppDatabase db;

  ShiftService(this.db);

  // Check if user has an open shift
  Future<String?> getActiveShift(String userId) async {
    final shift = await (db.select(db.shifts)
          ..where((t) => t.userId.equals(userId) & t.closingTime.isNull()))
        .getSingleOrNull();

    return shift?.id;
  }

  // Open a new shift
  Future<String> openShift(String userId, double startingCash) async {
    final shiftId = const Uuid().v4();
    await db.into(db.shifts).insert(ShiftsCompanion(
          id: Value(shiftId),
          userId: Value(userId),
          openingTime: Value(DateTime.now()),
          startingCash: Value(startingCash),
          isSynced: const Value(false),
        ));
    return shiftId;
  }

  // Close shift (calculate totals)
  Future<void> closeShift(String shiftId, double actualCash) async {
    // 1. Calculate expected cash (Starting Cash + Cash Payments)
    final shift = await (db.select(db.shifts)
          ..where((t) => t.id.equals(shiftId)))
        .getSingle();

    final payments = await (db.select(db.payments)
          ..join([
            innerJoin(db.orders, db.orders.id.equalsExp(db.payments.orderId))
          ])
          ..where((t) =>
              db.orders.shiftId.equals(shiftId) &
              db.payments.method.equals('CASH')))
        .get();

    double cashSales = payments.fold(0, (sum, p) => sum + p.amount);
    double expected = shift.startingCash + cashSales;

    // 2. Update the shift
    await (db.update(db.shifts)..where((t) => t.id.equals(shiftId)))
        .write(ShiftsCompanion(
      closingTime: Value(DateTime.now()),
      expectedCash: Value(expected),
      actualCash: Value(actualCash),
      isSynced: const Value(false),
    ));
  }

  Future<ShiftSummary> getShiftSummary(String shiftId) async {
    final shift = await (db.select(db.shifts)
          ..where((t) => t.id.equals(shiftId)))
        .getSingle();

    // Get all payments for this shift
    // We join Payments -> Orders to filter by shiftId
    final query = db.select(db.payments).join(
        [innerJoin(db.orders, db.orders.id.equalsExp(db.payments.orderId))])
      ..where(db.orders.shiftId.equals(shiftId));

    final result = await query.get();

    double cashSales = 0;
    double digitalSales = 0;

    for (final row in result) {
      final payment = row.readTable(db.payments);
      if (payment.method == 'CASH') {
        cashSales += payment.amount;
      } else {
        digitalSales += payment.amount;
      }
    }

    return ShiftSummary(
      shift: shift,
      totalSales: cashSales + digitalSales,
      cashSales: cashSales,
      digitalSales: digitalSales,
      expectedCash: shift.startingCash + cashSales,
    );
  }
}

class ShiftSummary {
  final Shift shift;
  final double totalSales;
  final double cashSales;
  final double digitalSales;
  final double expectedCash;

  ShiftSummary({
    required this.shift,
    required this.totalSales,
    required this.cashSales,
    required this.digitalSales,
    required this.expectedCash,
  });
}

final shiftServiceProvider =
    Provider((ref) => ShiftService(ref.watch(databaseProvider)));

================
File: qristal_mobile/lib/features/shifts/screens/open_shift_dialog.dart
================
// lib/features/shifts/screens/open_shift_dialog.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/shift_provider.dart';

class OpenShiftDialog extends ConsumerStatefulWidget {
  final String userId;
  const OpenShiftDialog({super.key, required this.userId});

  @override
  ConsumerState<OpenShiftDialog> createState() => _OpenShiftDialogState();
}

class _OpenShiftDialogState extends ConsumerState<OpenShiftDialog> {
  final _cashController = TextEditingController();
  bool _isSubmitting = false;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text("Open Register"),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Text(
              "Enter the starting cash amount in the drawer to begin your shift."),
          const SizedBox(height: 16),
          TextField(
            controller: _cashController,
            keyboardType: TextInputType.number,
            autofocus: true,
            decoration: const InputDecoration(
              labelText: "Starting Cash (UGX)",
              prefixIcon: Icon(Icons.money),
              border: OutlineInputBorder(),
            ),
          ),
        ],
      ),
      actions: [
        TextButton(
            // Prevent backing out without opening shift, force logout effectively in real app
            // For now just pop
            onPressed: () => Navigator.of(context).pop(),
            child: const Text("Cancel")),
        ElevatedButton(
          onPressed: _isSubmitting
              ? null
              : () async {
                  setState(() => _isSubmitting = true);
                  final startingCash =
                      double.tryParse(_cashController.text) ?? 0.0;

                  try {
                    final shiftId = await ref
                        .read(shiftServiceProvider)
                        .openShift(widget.userId, startingCash);

                    // Set active shift in state
                    ref.read(activeShiftIdProvider.notifier).state = shiftId;

                    if (context.mounted) {
                      Navigator.of(context).pop();
                    }
                  } catch (e) {
                    // handle error
                  } finally {
                    if (mounted) setState(() => _isSubmitting = false);
                  }
                },
          child: _isSubmitting
              ? const SizedBox(
                  width: 20, height: 20, child: CircularProgressIndicator())
              : const Text("Open Shift"),
        )
      ],
    );
  }
}

================
File: qristal_mobile/lib/services/websocket_service.dart
================
import 'package:flutter/foundation.dart';
import 'package:socket_io_client/socket_io_client.dart' as IO;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../core/constants/api_constants.dart';
import '../features/sync/providers/sync_provider.dart';

class WebSocketService {
  late IO.Socket socket;
  final Ref ref;

  WebSocketService(this.ref) {
    _init();
  }

  void _init() {
    // Replace this with your actual Render URL
    final String serverUrl = ApiConstants.baseUrl;

    socket = IO.io(serverUrl, <String, dynamic>{
      'transports': ['websocket'],
      'autoConnect': true,
    });

    socket.onConnect((_) {
      if (kDebugMode) {
        print(' Connected to WebSocket Server');
      }
    });

    // Listen for new orders (This is where the magic happens for the KDS)
    socket.on('newOrder', (data) {
      if (kDebugMode) {
        print(' New order received via WebSocket! Forcing sync...');
      }
      // When the server says a new order arrived, tell our local DB to pull it!
      ref.read(syncControllerProvider.notifier).performSync();
    });

    socket.onDisconnect((_) => print(' Disconnected from WebSocket'));
  }

  void dispose() {
    socket.dispose();
  }
}

// Provider
final webSocketProvider = Provider<WebSocketService>((ref) {
  return WebSocketService(ref);
});

================
File: qristal_mobile/android/app/src/main/AndroidManifest.xml
================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.BLUETOOTH" />
<uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
<uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
<uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <application
        android:label="qristal POS"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>

================
File: qristal_mobile/lib/features/hardware/screens/printer_settings_screen.dart
================
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:print_bluetooth_thermal/print_bluetooth_thermal.dart';
import 'package:printing/printing.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../../../core/theme/app_theme.dart';
import '../services/printer_service.dart';

class PrinterSettingsScreen extends ConsumerStatefulWidget {
  const PrinterSettingsScreen({super.key});

  @override
  ConsumerState<PrinterSettingsScreen> createState() => _PrinterSettingsScreenState();
}

class _PrinterSettingsScreenState extends ConsumerState<PrinterSettingsScreen> {
  // State for Android
  List<BluetoothInfo> _btDevices = [];
  String? _selectedBtAddress;
  
  // State for Windows
  List<Printer> _osPrinters = [];
  String? _selectedOsPrinterName;

  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _initPrinters();
  }

  Future<void> _initPrinters() async {
    setState(() => _isLoading = true);
    final prefs = await SharedPreferences.getInstance();

    if (Platform.isAndroid) {
      final printer = ref.read(printerServiceProvider);
      await printer.checkPermission();
      final devices = await printer.getPairedDevices();
      setState(() {
        _btDevices = devices;
        _selectedBtAddress = prefs.getString('printer_mac');
      });
    } else if (Platform.isWindows) {
      final printers = await Printing.listPrinters();
      setState(() {
        _osPrinters = printers.where((p) => p.isAvailable).toList();
        _selectedOsPrinterName = prefs.getString('os_printer_name');
      });
    }
    setState(() => _isLoading = false);
  }

  // Handle Android Connection
  Future<void> _connectAndroid(String macAddress) async {
    setState(() => _isLoading = true);
    final printer = ref.read(printerServiceProvider);
    final success = await printer.connect(macAddress);
    
    if (success) {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('printer_mac', macAddress);
      setState(() => _selectedBtAddress = macAddress);
      if(mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Bluetooth Printer Connected!"), backgroundColor: AppTheme.emerald));
    }
    setState(() => _isLoading = false);
  }

  // Handle Windows Selection
  Future<void> _saveWindowsPrinter(String name) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('os_printer_name', name);
    setState(() => _selectedOsPrinterName = name);
    if(mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("System Printer Set as Default!"), backgroundColor: AppTheme.emerald));
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Terminal Printer Settings")),
      body: Column(
        children: [
          if (_isLoading) const LinearProgressIndicator(),

          // ANDROID BLUETOOTH VIEW
          if (Platform.isAndroid) ...[
            Container(padding: const EdgeInsets.all(16), child: const Text("Paired Bluetooth Printers", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18))),
            Expanded(
              child: _btDevices.isEmpty ? const Center(child: Text("No paired devices found")) : ListView.builder(
                itemCount: _btDevices.length,
                itemBuilder: (context, index) {
                  final device = _btDevices[index];
                  final isConnected = _selectedBtAddress == device.macAdress;

                  return ListTile(
                    leading: const Icon(Icons.bluetooth),
                    title: Text(device.name),
                    subtitle: Text(device.macAdress),
                    trailing: isConnected 
                      ? const Icon(Icons.check_circle, color: AppTheme.emerald)
                      : ElevatedButton(onPressed: () => _connectAndroid(device.macAdress), child: const Text("Connect")),
                  );
                },
              ),
            ),
          ],

          // WINDOWS NATIVE SPOOLER VIEW
          if (Platform.isWindows) ...[
            Container(padding: const EdgeInsets.all(16), child: const Text("Available System Printers", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18))),
            Expanded(
              child: _osPrinters.isEmpty ? const Center(child: Text("No system printers installed.")) : ListView.builder(
                itemCount: _osPrinters.length,
                itemBuilder: (context, index) {
                  final printer = _osPrinters[index];
                  final isSelected = _selectedOsPrinterName == printer.name;

                  return ListTile(
                    leading: const Icon(Icons.print),
                    title: Text(printer.name),
                    subtitle: Text(printer.url),
                    trailing: isSelected 
                      ? const Icon(Icons.check_circle, color: AppTheme.emerald)
                      : ElevatedButton(onPressed: () => _saveWindowsPrinter(printer.name), child: const Text("Set as Default")),
                  );
                },
              ),
            ),
          ],
        ],
      ),
    );
  }
}

================
File: qristal_mobile/.idx/dev.nix
================
{pkgs}: {
  channel = "stable-24.05";
  packages = [
    pkgs.jdk17
    pkgs.unzip
    pkgs.openssh
  ];
  idx.extensions = [
    
  ];
  idx.previews = {
    previews = {
      # web = {
      #   command = [
      #     "flutter"
      #     "run"
      #     "--machine"
      #     "-d"
      #     "web-server"
      #     "--web-hostname"
      #     "0.0.0.0"
      #     "--web-port"
      #     "$PORT"
      #   ];
      #   manager = "flutter";
      # };
      # android = {
      #  command = [
      #    "flutter"
      #  "run"
      #     "--machine"
      #   "-d"
      #     "android"
      #     "-d"
      #     "localhost:5555"
      #    ];
      #   manager = "flutter";
      #  };
    };
  };
}

================
File: qristal_mobile/lib/features/auth/providers/auth_provider.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/constants/role_constants.dart';
import '../services/auth_service.dart';

final authServiceProvider = Provider((ref) => AuthService());

final userRoleProvider = FutureProvider<UserRole>((ref) async {
  return ref.watch(authServiceProvider).getRole();
});

class AuthState {
  final bool isAuthenticated;
  final String? userId;
  final String? role;
  final bool isLoading;
  final String? error;

  AuthState({
    required this.isAuthenticated,
    this.userId,
    this.role,
    this.isLoading = false,
    this.error,
  });

  AuthState copyWith({
    bool? isAuthenticated,
    String? userId,
    String? role,
    bool? isLoading,
    String? error,
  }) {
    return AuthState(
      isAuthenticated: isAuthenticated ?? this.isAuthenticated,
      userId: userId ?? this.userId,
      role: role ?? this.role,
      isLoading: isLoading ?? this.isLoading,
      error: error, // We allow error to be nullified
    );
  }
}

class AuthController extends StateNotifier<AuthState> {
  final AuthService _authService;

  AuthController(this._authService)
      : super(AuthState(isAuthenticated: false));

  Future<void> login(String userId, String pin) async {
    state = state.copyWith(isLoading: true, error: null);
    try {
      final data = await _authService.login(userId, pin);
      state = AuthState(
        isAuthenticated: true, 
        userId: data['user']['id'],
        role: data['user']['role'],
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  Future<void> logout() async {
    await _authService.logout();
    state = AuthState(isAuthenticated: false);
  }

  Future<void> checkAuthStatus() async {
    final token = await _authService.getToken();
    if (token != null) {
      // For now, let's assume if a token exists, the user is authenticated.
      state = AuthState(isAuthenticated: true, userId: 'some_user_id', role: 'admin'); // Placeholder
    }
  }
}

final authControllerProvider = StateNotifierProvider<AuthController, AuthState>((ref) {
  return AuthController(ref.watch(authServiceProvider));
});

================
File: qristal_mobile/lib/features/hardware/services/receipt_generator.dart
================
import 'dart:typed_data';

import 'package:esc_pos_utils_plus/esc_pos_utils_plus.dart';
import 'package:intl/intl.dart';
import '../../pos/models/cart_item.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;

class ReceiptGenerator {
  final fmt = NumberFormat("#,##0", "en_US");

  // ==========================================
  // 1. ESC/POS (ANDROID BLUETOOTH)
  // ==========================================
  Future<List<int>> generateTicket({
    required String orderId,
    required List<CartItem> items,
    required double total,
    required double tendered,
    required String paymentMethod,
    required String cashierName,
  }) async {
    final profile = await CapabilityProfile.load();
    final generator = Generator(PaperSize.mm58, profile);

    List<int> bytes = [];

    bytes += generator.text(
      'QRISTAL POS',
      styles: const PosStyles(
        align: PosAlign.center,
        height: PosTextSize.size2,
        width: PosTextSize.size2,
        bold: true,
      ),
    );
    bytes += generator.text(
      'Kampala, Uganda',
      styles: const PosStyles(align: PosAlign.center),
    );
    bytes += generator.text(
      'Tel: +256 700 000000',
      styles: const PosStyles(align: PosAlign.center),
    );
    bytes += generator.hr();

    bytes += generator.row([
      PosColumn(text: 'Rcpt: ${orderId.substring(0, 6)}', width: 6),
      PosColumn(
        text: 'Staff: $cashierName',
        width: 6,
        styles: const PosStyles(align: PosAlign.right),
      ),
    ]);
    bytes += generator.text(
      'Date: ${DateFormat('dd/MM/yyyy HH:mm').format(DateTime.now())}',
    );
    bytes += generator.hr();

    bytes += generator.row([
      PosColumn(text: 'Item', width: 6, styles: const PosStyles(bold: true)),
      PosColumn(
        text: 'Total',
        width: 6,
        styles: const PosStyles(bold: true, align: PosAlign.right),
      ),
    ]);

    for (var item in items) {
      bytes += generator.row([
        PosColumn(
          text: '${item.quantity}x ${item.product.name}',
          width: 8,
          styles: const PosStyles(align: PosAlign.left),
        ),
        PosColumn(
          text: fmt.format(item.total),
          width: 4,
          styles: const PosStyles(align: PosAlign.right),
        ),
      ]);
    }
    bytes += generator.hr();

    bytes += generator.row([
      PosColumn(
        text: 'TOTAL',
        width: 6,
        styles: const PosStyles(height: PosTextSize.size2, bold: true),
      ),
      PosColumn(
        text: fmt.format(total),
        width: 6,
        styles: const PosStyles(
          align: PosAlign.right,
          height: PosTextSize.size2,
          bold: true,
        ),
      ),
    ]);

    bytes += generator.text('Paid via $paymentMethod: ${fmt.format(tendered)}');
    bytes += generator.text('Change: ${fmt.format(tendered - total)}');

    bytes += generator.feed(1);
    bytes += generator.text(
      'Thank you for visiting!',
      styles: const PosStyles(align: PosAlign.center, bold: true),
    );
    bytes += generator.feed(2);
    bytes += generator.cut();

    return bytes;
  }

  Future<List<int>> generateZReport({
    required String shiftId,
    required String cashierName,
    required DateTime openingTime,
    required DateTime closingTime,
    required double openingCash,
    required double totalSales,
    required double cashSales,
    required double digitalSales,
    required double expectedCash,
    required double actualCash,
  }) async {
    final profile = await CapabilityProfile.load();
    final generator = Generator(PaperSize.mm58, profile);
    final fmt = NumberFormat("#,##0", "en_US");

    List<int> bytes = [];

    // Header
    bytes += generator.text(
      'Z-REPORT (END OF DAY)',
      styles: const PosStyles(
        align: PosAlign.center,
        bold: true,
        height: PosTextSize.size2,
      ),
    );
    bytes += generator.text(
      'QRISTAL POS',
      styles: const PosStyles(align: PosAlign.center),
    );
    bytes += generator.text(
      'Shift ID: ${shiftId.substring(0, 8)}',
      styles: const PosStyles(align: PosAlign.center),
    );
    bytes += generator.hr();

    // Time Info
    bytes += generator.text('Staff: $cashierName');
    bytes += generator.text(
      'Open: ${DateFormat('dd/MM HH:mm').format(openingTime)}',
    );
    bytes += generator.text(
      'Close: ${DateFormat('dd/MM HH:mm').format(closingTime)}',
    );
    bytes += generator.hr();

    // Financials
    bytes += generator.row([
      PosColumn(text: 'Opening Float:', width: 7),
      PosColumn(
        text: fmt.format(openingCash),
        width: 5,
        styles: const PosStyles(align: PosAlign.right),
      ),
    ]);

    bytes += generator.row([
      PosColumn(
        text: 'Total Sales:',
        width: 7,
        styles: const PosStyles(bold: true),
      ),
      PosColumn(
        text: fmt.format(totalSales),
        width: 5,
        styles: const PosStyles(align: PosAlign.right, bold: true),
      ),
    ]);

    bytes += generator.hr();

    // Payment Breakdown
    bytes += generator.text(
      'Payment Breakdown:',
      styles: const PosStyles(bold: true),
    );
    bytes += generator.row([
      PosColumn(text: '- Cash:', width: 7),
      PosColumn(
        text: fmt.format(cashSales),
        width: 5,
        styles: const PosStyles(align: PosAlign.right),
      ),
    ]);
    bytes += generator.row([
      PosColumn(text: '- Digital/Mobile:', width: 7),
      PosColumn(
        text: fmt.format(digitalSales),
        width: 5,
        styles: const PosStyles(align: PosAlign.right),
      ),
    ]);

    bytes += generator.hr();

    // Cash Reconciliation
    bytes += generator.text(
      'Cash Reconciliation:',
      styles: const PosStyles(bold: true),
    );
    bytes += generator.row([
      PosColumn(text: 'Expected Cash:', width: 7),
      PosColumn(
        text: fmt.format(expectedCash),
        width: 5,
        styles: const PosStyles(align: PosAlign.right),
      ),
    ]);
    bytes += generator.row([
      PosColumn(text: 'Actual Cash:', width: 7),
      PosColumn(
        text: fmt.format(actualCash),
        width: 5,
        styles: const PosStyles(align: PosAlign.right),
      ),
    ]);

    final double variance = actualCash - expectedCash;
    bytes += generator.row([
      PosColumn(text: 'Variance:', width: 7),
      PosColumn(
        text: fmt.format(variance),
        width: 5,
        styles: PosStyles(
          align: PosAlign.right,
          bold: true,
          reverse: variance < 0,
        ), // Highlight negatives
      ),
    ]);

    bytes += generator.feed(2);
    bytes += generator.cut();

    return bytes;
  }

  // ==========================================
  // 2. PDF GENERATION (WINDOWS NATIVE SPOOLER)
  // ==========================================
  Future<Uint8List> generatePdfReceipt({
    required String orderId,
    required List<CartItem> items,
    required double total,
    required double tendered,
    required String paymentMethod,
    required String cashierName,
  }) async {
    final doc = pw.Document();

    doc.addPage(
      pw.Page(
        pageFormat:
            PdfPageFormat.roll57, // Auto-sizes length for 58mm printers!
        build: (pw.Context context) {
          return pw.Column(
            crossAxisAlignment: pw.CrossAxisAlignment.start,
            children: [
              pw.Center(
                child: pw.Text(
                  'QRISTAL POS',
                  style: pw.TextStyle(
                    fontWeight: pw.FontWeight.bold,
                    fontSize: 16,
                  ),
                ),
              ),
              pw.Center(
                child: pw.Text(
                  'Kampala, Uganda',
                  style: const pw.TextStyle(fontSize: 10),
                ),
              ),
              pw.Divider(borderStyle: pw.BorderStyle.dashed),
              pw.Row(
                mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                children: [
                  pw.Text(
                    'Rcpt: ${orderId.substring(0, 6)}',
                    style: const pw.TextStyle(fontSize: 10),
                  ),
                  pw.Text(
                    'Staff: $cashierName',
                    style: const pw.TextStyle(fontSize: 10),
                  ),
                ],
              ),
              pw.Text(
                'Date: ${DateFormat('dd/MM/yyyy HH:mm').format(DateTime.now())}',
                style: const pw.TextStyle(fontSize: 10),
              ),
              pw.Divider(borderStyle: pw.BorderStyle.dashed),
              pw.Row(
                mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                children: [
                  pw.Text(
                    'Item',
                    style: pw.TextStyle(
                      fontWeight: pw.FontWeight.bold,
                      fontSize: 10,
                    ),
                  ),
                  pw.Text(
                    'Total',
                    style: pw.TextStyle(
                      fontWeight: pw.FontWeight.bold,
                      fontSize: 10,
                    ),
                  ),
                ],
              ),
              pw.SizedBox(height: 5),
              for (var item in items)
                pw.Row(
                  mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                  children: [
                    pw.Expanded(
                      child: pw.Text(
                        '${item.quantity}x ${item.product.name}',
                        style: const pw.TextStyle(fontSize: 10),
                      ),
                    ),
                    pw.Text(
                      fmt.format(item.total),
                      style: const pw.TextStyle(fontSize: 10),
                    ),
                  ],
                ),
              pw.Divider(borderStyle: pw.BorderStyle.dashed),
              pw.Row(
                mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                children: [
                  pw.Text(
                    'TOTAL',
                    style: pw.TextStyle(
                      fontWeight: pw.FontWeight.bold,
                      fontSize: 14,
                    ),
                  ),
                  pw.Text(
                    fmt.format(total),
                    style: pw.TextStyle(
                      fontWeight: pw.FontWeight.bold,
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
              pw.SizedBox(height: 5),
              pw.Text(
                'Paid via $paymentMethod: ${fmt.format(tendered)}',
                style: const pw.TextStyle(fontSize: 10),
              ),
              pw.Text(
                'Change: ${fmt.format(tendered - total)}',
                style: const pw.TextStyle(fontSize: 10),
              ),
              pw.SizedBox(height: 10),
              pw.Center(
                child: pw.Text(
                  'Thank you for visiting!',
                  style: pw.TextStyle(
                    fontWeight: pw.FontWeight.bold,
                    fontSize: 10,
                  ),
                ),
              ),
            ],
          );
        },
      ),
    );

    return doc.save();
  }
}

================
File: qristal_mobile/lib/features/kitchen/screens/kitchen_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/theme/app_theme.dart';
import '../../../core/providers/database_provider.dart';
import '../../../database/database.dart';
import '../../auth/providers/auth_provider.dart';
import '../../auth/screens/login_screen.dart';
import '../../sync/providers/sync_provider.dart';

class KitchenScreen extends ConsumerWidget {
  const KitchenScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final db = ref.watch(databaseProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text("Kitchen Display System"),
        backgroundColor: AppTheme.surface,
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            tooltip: "Force Sync",
            onPressed: () {
              ref.read(syncControllerProvider.notifier).performSync();
              ScaffoldMessenger.of(context)
                  .showSnackBar(const SnackBar(content: Text("Syncing...")));
            },
          ),
          const SizedBox(width: 16),
          // ADD LOGOUT BUTTON HERE
          TextButton.icon(
            icon: const Icon(Icons.logout, color: AppTheme.error),
            label:
                const Text("LOGOUT", style: TextStyle(color: AppTheme.error)),
            onPressed: () async {
              await ref.read(authControllerProvider.notifier).logout();
              if (context.mounted) {
                Navigator.of(context).pushAndRemoveUntil(
                  MaterialPageRoute(builder: (_) => const LoginScreen()),
                  (route) => false,
                );
              }
            },
          ),
          const SizedBox(width: 16),
        ],
      ),
      body: StreamBuilder<List<Order>>(
        stream: db.watchKitchenOrders(),
        builder: (context, snapshot) {
          if (!snapshot.hasData) {
            return const Center(child: CircularProgressIndicator());
          }

          if (snapshot.hasError) {
            return Center(
              child: Text(
                'Error loading orders: ${snapshot.error}',
                style: const TextStyle(color: Colors.red),
              ),
            );
          }

          final orders = snapshot.data ?? [];

          if (orders.isEmpty) {
            return const Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.check_circle_outline,
                    size: 80,
                    color: Colors.green,
                  ),
                  SizedBox(height: 16),
                  Text(
                    "No pending orders. Good job!",
                    style: TextStyle(color: Colors.grey, fontSize: 24),
                  ),
                ],
              ),
            );
          }

          return ListView.builder(
            scrollDirection: Axis.horizontal, // KDS usually scrolls sideways
            itemCount: orders.length,
            padding: const EdgeInsets.all(16),
            itemBuilder: (context, index) {
              return KitchenTicket(order: orders[index]);
            },
          );
        },
      ),
    );
  }
}

class KitchenTicket extends ConsumerStatefulWidget {
  final Order order;
  const KitchenTicket({super.key, required this.order});

  @override
  ConsumerState<KitchenTicket> createState() => _KitchenTicketState();
}

class _KitchenTicketState extends ConsumerState<KitchenTicket> {
  late Future<List<TypedOrderItem>> _itemsFuture;

  @override
  void initState() {
    super.initState();
    _loadItems();
  }

  void _loadItems() {
    final db = ref.read(databaseProvider);
    _itemsFuture = db.getOrderItems(widget.order.id);
  }

  @override
  Widget build(BuildContext context) {
    final db = ref.read(databaseProvider);
    final isPreparing = widget.order.status == 'PREPARING';

    return Container(
      width: 300,
      margin: const EdgeInsets.only(right: 16),
      decoration: BoxDecoration(
        color: AppTheme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: isPreparing ? Colors.orange : AppTheme.qristalBlue,
          width: 3,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.3),
            blurRadius: 8,
            offset: const Offset(4, 4),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // Header
          Container(
            padding: const EdgeInsets.all(12),
            color: isPreparing
                ? Colors.orange.withOpacity(0.2)
                : AppTheme.qristalBlue.withOpacity(0.2),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  "#${widget.order.receiptNumber}",
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 18,
                  ),
                ),
                Text(
                  widget.order.createdAt
                      .toLocal()
                      .toString()
                      .split(' ')[1]
                      .substring(0, 5), // Time HH:MM
                  style: const TextStyle(color: Colors.grey),
                ),
              ],
            ),
          ),

          // Items List
          Expanded(
            child: FutureBuilder<List<TypedOrderItem>>(
              future: _itemsFuture,
              builder: (context, snapshot) {
                if (!snapshot.hasData)
                  return const Center(child: CircularProgressIndicator());

                return ListView.separated(
                  padding: const EdgeInsets.all(12),
                  itemCount: snapshot.data!.length,
                  separatorBuilder: (_, __) => const Divider(),
                  itemBuilder: (context, index) {
                    final itemData = snapshot.data![index];
                    return Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 8,
                            vertical: 4,
                          ),
                          decoration: BoxDecoration(
                            color: Colors.grey[800],
                            borderRadius: BorderRadius.circular(4),
                          ),
                          child: Text(
                            "${itemData.item.quantity}x",
                            style: const TextStyle(fontWeight: FontWeight.bold),
                          ),
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                itemData.product.name,
                                style: const TextStyle(fontSize: 16),
                              ),
                              if (itemData.item.notes != null &&
                                  itemData.item.notes!.isNotEmpty)
                                Text(
                                  "Note: ${itemData.item.notes}",
                                  style: const TextStyle(
                                    color: AppTheme.error,
                                    fontSize: 12,
                                  ),
                                ),
                            ],
                          ),
                        ),
                      ],
                    );
                  },
                );
              },
            ),
          ),

          // Footer Actions
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: SizedBox(
              width: double.infinity,
              height: 50,
              child: ElevatedButton(
                style: ElevatedButton.styleFrom(
                  backgroundColor:
                      isPreparing ? AppTheme.emerald : Colors.orange,
                ),
                onPressed: () async {
                  String newStatus = isPreparing ? 'READY' : 'PREPARING';
                  await db.updateOrderStatus(widget.order.id, newStatus);

                  // Trigger sync to let server/cashiers know
                  ref.read(syncControllerProvider.notifier).performSync();
                },
                child: Text(isPreparing ? "MARK DONE" : "START COOKING"),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

================
File: qristal_mobile/lib/main.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'core/theme/app_theme.dart';
import 'features/auth/screens/login_screen.dart';
import 'features/tables/screens/floor_plan_screen.dart';
import 'services/websocket_service.dart';
import 'package:sentry_flutter/sentry_flutter.dart';

Future<void> main() async {
  await SentryFlutter.init(
    (options) {
      options.dsn = 'https://04c7b6ac5293308f78c72bb89a9996e7@o4510936622891008.ingest.us.sentry.io/4510936624660480';
      // Adds request headers and IP for users, for more info visit:
      // https://docs.sentry.io/platforms/dart/guides/flutter/data-management/data-collected/
      options.sendDefaultPii = true;
      options.enableLogs = true;
      // Set tracesSampleRate to 1.0 to capture 100% of transactions for tracing.
      // We recommend adjusting this value in production.
      options.tracesSampleRate = 1.0;
      // Configure Session Replay
      options.replay.sessionSampleRate = 0.1;
      options.replay.onErrorSampleRate = 1.0;
    },
    appRunner: () => runApp(SentryWidget(child: const ProviderScope(child: QristalApp()))),
  );
  
}

class QristalApp extends ConsumerWidget { // Change to ConsumerWidget
  const QristalApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    ref.read(webSocketProvider); 
    return MaterialApp(
      title: 'Qristal POS',
      navigatorObservers: [
        SentryNavigatorObserver(),
      ],
      debugShowCheckedModeBanner: false,
      theme: AppTheme.darkTheme,
      home: const LoginScreen(),
      routes: {'/home': (context) => const FloorPlanScreen()},
    );
  }
}

================
File: qristal_mobile/lib/features/hardware/services/printer_service.dart
================
import 'dart:io';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:print_bluetooth_thermal/print_bluetooth_thermal.dart';
import 'package:printing/printing.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../../pos/models/cart_item.dart';
import 'receipt_generator.dart';

class PrinterService {
  final _generator = ReceiptGenerator();
  
  // --- BLUETOOTH METHODS (Android) ---
  Future<bool> checkPermission() async {
    if (!Platform.isAndroid) return false;
    return await PrintBluetoothThermal.isPermissionBluetoothGranted;
  }

  Future<List<BluetoothInfo>> getPairedDevices() async {
    if (!Platform.isAndroid) return [];
    return await PrintBluetoothThermal.pairedBluetooths;
  }

  Future<bool> connect(String macAddress) async {
    if (!Platform.isAndroid) return false;
    return await PrintBluetoothThermal.connect(macPrinterAddress: macAddress);
  }

  // --- UNIVERSAL PRINT ROUTER ---
  Future<void> printReceipt({
    required String orderId,
    required List<CartItem> items,
    required double total,
    required double tendered,
    required String paymentMethod,
    required String cashierName,
  }) async {
    
    // 1. WINDOWS ROUTING (OS Print Spooler via PDF)
    if (Platform.isWindows) {
      final prefs = await SharedPreferences.getInstance();
      final targetPrinterName = prefs.getString('os_printer_name');

      final pdfBytes = await _generator.generatePdfReceipt(
        orderId: orderId, items: items, total: total, 
        tendered: tendered, paymentMethod: paymentMethod, cashierName: cashierName
      );

      if (targetPrinterName != null && targetPrinterName.isNotEmpty) {
        // Print directly silently if configured
        final targetPrinter = Printer(url: targetPrinterName, isAvailable: true, name: targetPrinterName);
        await Printing.directPrintPdf(printer: targetPrinter, onLayout: (_) => pdfBytes);
      } else {
        // Fallback: Show print dialog
        await Printing.layoutPdf(onLayout: (_) => pdfBytes, name: 'Receipt_$orderId');
      }
      return;
    }

    // 2. ANDROID ROUTING (Bluetooth ESC/POS)
    if (Platform.isAndroid) {
      final bool isConnected = await PrintBluetoothThermal.connectionStatus;
      if (isConnected) {
        final List<int> bytes = await _generator.generateTicket(
          orderId: orderId, items: items, total: total, 
          tendered: tendered, paymentMethod: paymentMethod, cashierName: cashierName
        );
        await PrintBluetoothThermal.writeBytes(bytes);
      } else {
        print("Bluetooth Printer not connected on Android.");
      }
    }
  }

  Future<void> printZReport({
    required String shiftId, required String cashierName, required DateTime openingTime,
    required DateTime closingTime, required double openingCash, required double totalSales,
    required double cashSales, required double digitalSales, required double expectedCash,
    required double actualCash,
  }) async {
    if (Platform.isWindows) {
       // Similar implementation using pdf document builder for Z-report...
       // For now, prompt the layout
       await Printing.layoutPdf(onLayout: (_) => _generator.generatePdfReceipt(
          orderId: shiftId, items: [], total: totalSales, tendered: actualCash, paymentMethod: "Z-REPORT", cashierName: cashierName
       ));
       return;
    }
    
    if (Platform.isAndroid && await PrintBluetoothThermal.connectionStatus) {
       final bytes = await _generator.generateZReport(
          shiftId: shiftId, cashierName: cashierName, openingTime: openingTime, closingTime: closingTime, openingCash: openingCash, totalSales: totalSales, cashSales: cashSales, digitalSales: digitalSales, expectedCash: expectedCash, actualCash: actualCash
       );
       await PrintBluetoothThermal.writeBytes(bytes);
    }
  }
}

final printerServiceProvider = Provider((ref) => PrinterService());

================
File: qristal_mobile/lib/features/shifts/screens/close_shift_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/theme/app_theme.dart';
import '../../hardware/services/printer_service.dart';
import '../../sync/providers/sync_provider.dart';
import '../../auth/providers/auth_provider.dart';
import '../../auth/screens/login_screen.dart';
import '../providers/shift_provider.dart';

class CloseShiftScreen extends ConsumerStatefulWidget {
  const CloseShiftScreen({super.key});

  @override
  ConsumerState<CloseShiftScreen> createState() => _CloseShiftScreenState();
}

class _CloseShiftScreenState extends ConsumerState<CloseShiftScreen> {
  final _cashController = TextEditingController();
  ShiftSummary? _summary;
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  Future<void> _loadData() async {
    final shiftId = ref.read(activeShiftIdProvider);

    if (shiftId == null) {
      if (!mounted) return;
      setState(() {
        _isLoading = false;
      });
      return;
    }

    final summary = await ref.read(shiftServiceProvider).getShiftSummary(shiftId);
    if (!mounted) return;

    setState(() {
      _summary = summary;
      _isLoading = false;
    });
  }

  Future<void> _handleCloseShift() async {
    if (_summary == null) return;

    final actualCash = double.tryParse(_cashController.text) ?? 0.0;
    final shiftId = _summary!.shift.id;

    try {
      await ref.read(printerServiceProvider).printZReport(
            shiftId: shiftId,
            cashierName: "Cashier", // Replace with real name later
            openingTime: _summary!.shift.openingTime,
            closingTime: DateTime.now(),
            openingCash: _summary!.shift.startingCash,
            totalSales: _summary!.totalSales,
            cashSales: _summary!.cashSales,
            digitalSales: _summary!.digitalSales,
            expectedCash: _summary!.expectedCash,
            actualCash: actualCash,
          );
    } catch (e) {
      if (mounted) {
        final shouldContinue = await showDialog<bool>(
          context: context,
          builder: (context) => AlertDialog(
            title: const Text('Printing Failed'),
            content: const Text(
                'Could not print the Z-Report. Do you want to continue closing the shift without printing?'),
            actions: [
              TextButton(
                onPressed: () {
                  // To allow retrying, we just close the dialog.
                  // The user can then press the "CLOSE SHIFT & PRINT" button again.
                  Navigator.of(context).pop(false);
                },
                child: const Text('Retry'),
              ),
              TextButton(
                onPressed: () {
                  // Continue with closing the shift.
                  Navigator.of(context).pop(true);
                },
                child: const Text('Continue without Printing'),
              ),
            ],
          ),
        );

        // If the user chooses to not continue (i.e., they want to retry),
        // we stop the execution of this function.
        if (shouldContinue != true) {
          return; // Stop the close shift process.
        }
      }
    }
    
    // 1. Update Database
    await ref.read(shiftServiceProvider).closeShift(shiftId, actualCash);

    // 2. Clear active shift state
    ref.read(activeShiftIdProvider.notifier).state = null;

    // 3. Force Sync
    ref.read(syncControllerProvider.notifier).performSync();

    // 4. Navigate to Login
    if (mounted) {
      Navigator.of(context).pushAndRemoveUntil(
        MaterialPageRoute(builder: (context) => const LoginScreen()),
        (route) => false,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    if (_summary == null) {
      return Scaffold(
        appBar: AppBar(title: const Text("Close Shift")),
        body: const Center(
          child: Text("No active shift."),
        ),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text("Close Shift"),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text("Shift Summary", ),
            const Divider(height: 30),
            _buildSummaryRow("Total Sales:", _summary!.totalSales),
            _buildSummaryRow("Cash Sales:", _summary!.cashSales),
            _buildSummaryRow("Digital Sales:", _summary!.digitalSales),
            const Divider(height: 30),
            _buildSummaryRow("Starting Cash:", _summary!.shift.startingCash),
            _buildSummaryRow("Expected Cash in Drawer:", _summary!.expectedCash),
            const SizedBox(height: 30),
            Text("Counted Cash", ),
            const SizedBox(height: 10),
            TextField(
              controller: _cashController,
              keyboardType: const TextInputType.numberWithOptions(decimal: true),
              decoration: const InputDecoration(
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.attach_money),
                hintText: "Enter amount counted",
              ),
            ),
            const SizedBox(height: 40),
            SizedBox(
              width: double.infinity,
              height: 60,
              child: ElevatedButton(
                style:
                    ElevatedButton.styleFrom(backgroundColor: AppTheme.error),
                onPressed: _handleCloseShift,
                child: const Text("CLOSE SHIFT & PRINT",
                    style: TextStyle(fontSize: 18)),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSummaryRow(String label, double value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(label, style: const TextStyle(fontSize: 16)),
          Text("${value.toStringAsFixed(2)}",
              style:
                  const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _cashController.dispose();
    super.dispose();
  }
}

================
File: qristal_mobile/windows/flutter/generated_plugin_registrant.cc
================
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"

#include <connectivity_plus/connectivity_plus_windows_plugin.h>
#include <flutter_secure_storage_windows/flutter_secure_storage_windows_plugin.h>
#include <permission_handler_windows/permission_handler_windows_plugin.h>
#include <print_bluetooth_thermal/print_bluetooth_thermal_plugin_c_api.h>
#include <printing/printing_plugin.h>
#include <sentry_flutter/sentry_flutter_plugin.h>
#include <sqlite3_flutter_libs/sqlite3_flutter_libs_plugin.h>

void RegisterPlugins(flutter::PluginRegistry* registry) {
  ConnectivityPlusWindowsPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("ConnectivityPlusWindowsPlugin"));
  FlutterSecureStorageWindowsPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("FlutterSecureStorageWindowsPlugin"));
  PermissionHandlerWindowsPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("PermissionHandlerWindowsPlugin"));
  PrintBluetoothThermalPluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("PrintBluetoothThermalPluginCApi"));
  PrintingPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("PrintingPlugin"));
  SentryFlutterPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("SentryFlutterPlugin"));
  Sqlite3FlutterLibsPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("Sqlite3FlutterLibsPlugin"));
}

================
File: qristal_mobile/windows/flutter/generated_plugins.cmake
================
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
  connectivity_plus
  flutter_secure_storage_windows
  permission_handler_windows
  print_bluetooth_thermal
  printing
  sentry_flutter
  sqlite3_flutter_libs
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
  jni
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/windows plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/windows plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)

================
File: qristal_mobile/lib/features/pos/services/order_service.dart
================
import 'package:drift/drift.dart';
import 'package:uuid/uuid.dart';
import '../../../database/database.dart';
import '../models/cart_item.dart';

class OrderService {
  final AppDatabase db;
  final Uuid uuid = const Uuid();

  OrderService(this.db);

  Future<void> placeOrder({
    required List<CartItem> cartItems,
    required String userId,
    required String shiftId,
    String? tableId,
  }) async {
    final orderId = uuid.v4();
    final totalAmount = cartItems.fold(0.0, (sum, item) => sum + item.total);

    await db.transaction(() async {
      await db.into(db.orders).insert(
            OrdersCompanion(
              id: Value(orderId),
              userId: Value(userId),
              shiftId: Value(shiftId),
              tableId: Value(tableId),
              receiptNumber: Value(orderId.substring(0, 4).toUpperCase()),
              totalAmount: Value(totalAmount),
              status: const Value('KITCHEN'),
              isSynced: const Value(false),
              createdAt: Value(DateTime.now()),
              updatedAt: Value(DateTime.now()),
            ),
          );

      for (final item in cartItems) {
        final orderItemId = uuid.v4();
        await db.into(db.orderItems).insert(
              OrderItemsCompanion(
                id: Value(orderItemId),
                orderId: Value(orderId),
                productId: Value(item.product.id),
                quantity: Value(item.quantity),
                priceAtTimeOfOrder: Value(item.product.price),
                routeTo: Value(item.routeTo),
                notes: Value(item.notes.isEmpty ? null : item.notes),
              ),
            );

        for (final modifier in item.modifiers) {
          await db.into(db.orderItemModifiers).insert(
                OrderItemModifiersCompanion(
                  id: Value(uuid.v4()),
                  orderItemId: Value(orderItemId),
                  name: Value(modifier.name),
                  priceDelta: Value(modifier.priceDelta),
                  routeTo: Value(modifier.routeTo),
                ),
              );
        }

        for (final side in item.sides) {
          await db.into(db.orderItemSides).insert(
                OrderItemSidesCompanion(
                  id: Value(uuid.v4()),
                  orderItemId: Value(orderItemId),
                  name: Value(side.name),
                  quantity: Value(side.quantity),
                  priceDelta: Value(side.priceDelta),
                  routeTo: Value(side.routeTo),
                ),
              );
        }
      }

      if (tableId != null) {
        await (db.update(db.seatingTables)..where((t) => t.id.equals(tableId)))
            .write(const SeatingTablesCompanion(
          status: Value('OCCUPIED'),
          isSynced: Value(true),
        ));
      }
    });
  }

  Future<void> closeOrder(
      String orderId, double totalAmount, List<Payment> payments) async {
    await db.transaction(() async {
      final order =
          await (db.select(db.orders)..where((t) => t.id.equals(orderId)))
              .getSingleOrNull();

      if (order == null) {
        return;
      }

      await (db.update(db.orders)..where((t) => t.id.equals(orderId))).write(
        OrdersCompanion(
          status: const Value('CLOSED'),
          totalAmount: Value(totalAmount),
          isSynced: const Value(false),
          updatedAt: Value(DateTime.now()),
        ),
      );

      for (final payment in payments) {
        await db.into(db.payments).insert(payment.toCompanion(true));
      }

      if (order.tableId != null) {
        await (db.update(db.seatingTables)
              ..where((t) => t.id.equals(order.tableId!)))
            .write(const SeatingTablesCompanion(
          status: Value('FREE'),
          isSynced: Value(true),
        ));
      }
    });
  }
}

================
File: qristal_mobile/lib/database/database.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $CategoriesTable extends Categories
    with TableInfo<$CategoriesTable, Category> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CategoriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _branchIdMeta = const VerificationMeta(
    'branchId',
  );
  @override
  late final GeneratedColumn<String> branchId = GeneratedColumn<String>(
    'branch_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('BRANCH-01'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _colorHexMeta = const VerificationMeta(
    'colorHex',
  );
  @override
  late final GeneratedColumn<String> colorHex = GeneratedColumn<String>(
    'color_hex',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sortOrderMeta = const VerificationMeta(
    'sortOrder',
  );
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
    'sort_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    branchId,
    name,
    colorHex,
    sortOrder,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'categories';
  @override
  VerificationContext validateIntegrity(
    Insertable<Category> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('branch_id')) {
      context.handle(
        _branchIdMeta,
        branchId.isAcceptableOrUnknown(data['branch_id']!, _branchIdMeta),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('color_hex')) {
      context.handle(
        _colorHexMeta,
        colorHex.isAcceptableOrUnknown(data['color_hex']!, _colorHexMeta),
      );
    }
    if (data.containsKey('sort_order')) {
      context.handle(
        _sortOrderMeta,
        sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Category map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Category(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      branchId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}branch_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      colorHex: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}color_hex'],
      ),
      sortOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sort_order'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      ),
    );
  }

  @override
  $CategoriesTable createAlias(String alias) {
    return $CategoriesTable(attachedDatabase, alias);
  }
}

class Category extends DataClass implements Insertable<Category> {
  final String id;
  final String branchId;
  final String name;
  final String? colorHex;
  final int sortOrder;
  final DateTime? updatedAt;
  const Category({
    required this.id,
    required this.branchId,
    required this.name,
    this.colorHex,
    required this.sortOrder,
    this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['branch_id'] = Variable<String>(branchId);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || colorHex != null) {
      map['color_hex'] = Variable<String>(colorHex);
    }
    map['sort_order'] = Variable<int>(sortOrder);
    if (!nullToAbsent || updatedAt != null) {
      map['updated_at'] = Variable<DateTime>(updatedAt);
    }
    return map;
  }

  CategoriesCompanion toCompanion(bool nullToAbsent) {
    return CategoriesCompanion(
      id: Value(id),
      branchId: Value(branchId),
      name: Value(name),
      colorHex: colorHex == null && nullToAbsent
          ? const Value.absent()
          : Value(colorHex),
      sortOrder: Value(sortOrder),
      updatedAt: updatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAt),
    );
  }

  factory Category.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Category(
      id: serializer.fromJson<String>(json['id']),
      branchId: serializer.fromJson<String>(json['branchId']),
      name: serializer.fromJson<String>(json['name']),
      colorHex: serializer.fromJson<String?>(json['colorHex']),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
      updatedAt: serializer.fromJson<DateTime?>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'branchId': serializer.toJson<String>(branchId),
      'name': serializer.toJson<String>(name),
      'colorHex': serializer.toJson<String?>(colorHex),
      'sortOrder': serializer.toJson<int>(sortOrder),
      'updatedAt': serializer.toJson<DateTime?>(updatedAt),
    };
  }

  Category copyWith({
    String? id,
    String? branchId,
    String? name,
    Value<String?> colorHex = const Value.absent(),
    int? sortOrder,
    Value<DateTime?> updatedAt = const Value.absent(),
  }) => Category(
    id: id ?? this.id,
    branchId: branchId ?? this.branchId,
    name: name ?? this.name,
    colorHex: colorHex.present ? colorHex.value : this.colorHex,
    sortOrder: sortOrder ?? this.sortOrder,
    updatedAt: updatedAt.present ? updatedAt.value : this.updatedAt,
  );
  Category copyWithCompanion(CategoriesCompanion data) {
    return Category(
      id: data.id.present ? data.id.value : this.id,
      branchId: data.branchId.present ? data.branchId.value : this.branchId,
      name: data.name.present ? data.name.value : this.name,
      colorHex: data.colorHex.present ? data.colorHex.value : this.colorHex,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Category(')
          ..write('id: $id, ')
          ..write('branchId: $branchId, ')
          ..write('name: $name, ')
          ..write('colorHex: $colorHex, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, branchId, name, colorHex, sortOrder, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Category &&
          other.id == this.id &&
          other.branchId == this.branchId &&
          other.name == this.name &&
          other.colorHex == this.colorHex &&
          other.sortOrder == this.sortOrder &&
          other.updatedAt == this.updatedAt);
}

class CategoriesCompanion extends UpdateCompanion<Category> {
  final Value<String> id;
  final Value<String> branchId;
  final Value<String> name;
  final Value<String?> colorHex;
  final Value<int> sortOrder;
  final Value<DateTime?> updatedAt;
  final Value<int> rowid;
  const CategoriesCompanion({
    this.id = const Value.absent(),
    this.branchId = const Value.absent(),
    this.name = const Value.absent(),
    this.colorHex = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CategoriesCompanion.insert({
    required String id,
    this.branchId = const Value.absent(),
    required String name,
    this.colorHex = const Value.absent(),
    this.sortOrder = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name);
  static Insertable<Category> custom({
    Expression<String>? id,
    Expression<String>? branchId,
    Expression<String>? name,
    Expression<String>? colorHex,
    Expression<int>? sortOrder,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (branchId != null) 'branch_id': branchId,
      if (name != null) 'name': name,
      if (colorHex != null) 'color_hex': colorHex,
      if (sortOrder != null) 'sort_order': sortOrder,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CategoriesCompanion copyWith({
    Value<String>? id,
    Value<String>? branchId,
    Value<String>? name,
    Value<String?>? colorHex,
    Value<int>? sortOrder,
    Value<DateTime?>? updatedAt,
    Value<int>? rowid,
  }) {
    return CategoriesCompanion(
      id: id ?? this.id,
      branchId: branchId ?? this.branchId,
      name: name ?? this.name,
      colorHex: colorHex ?? this.colorHex,
      sortOrder: sortOrder ?? this.sortOrder,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (branchId.present) {
      map['branch_id'] = Variable<String>(branchId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (colorHex.present) {
      map['color_hex'] = Variable<String>(colorHex.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CategoriesCompanion(')
          ..write('id: $id, ')
          ..write('branchId: $branchId, ')
          ..write('name: $name, ')
          ..write('colorHex: $colorHex, ')
          ..write('sortOrder: $sortOrder, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ProductsTable extends Products with TableInfo<$ProductsTable, Product> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProductsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _branchIdMeta = const VerificationMeta(
    'branchId',
  );
  @override
  late final GeneratedColumn<String> branchId = GeneratedColumn<String>(
    'branch_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('BRANCH-01'),
  );
  static const VerificationMeta _categoryIdMeta = const VerificationMeta(
    'categoryId',
  );
  @override
  late final GeneratedColumn<String> categoryId = GeneratedColumn<String>(
    'category_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES categories (id)',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
    'price',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isAvailableMeta = const VerificationMeta(
    'isAvailable',
  );
  @override
  late final GeneratedColumn<bool> isAvailable = GeneratedColumn<bool>(
    'is_available',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_available" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    branchId,
    categoryId,
    name,
    price,
    isAvailable,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'products';
  @override
  VerificationContext validateIntegrity(
    Insertable<Product> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('branch_id')) {
      context.handle(
        _branchIdMeta,
        branchId.isAcceptableOrUnknown(data['branch_id']!, _branchIdMeta),
      );
    }
    if (data.containsKey('category_id')) {
      context.handle(
        _categoryIdMeta,
        categoryId.isAcceptableOrUnknown(data['category_id']!, _categoryIdMeta),
      );
    } else if (isInserting) {
      context.missing(_categoryIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('price')) {
      context.handle(
        _priceMeta,
        price.isAcceptableOrUnknown(data['price']!, _priceMeta),
      );
    } else if (isInserting) {
      context.missing(_priceMeta);
    }
    if (data.containsKey('is_available')) {
      context.handle(
        _isAvailableMeta,
        isAvailable.isAcceptableOrUnknown(
          data['is_available']!,
          _isAvailableMeta,
        ),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Product map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Product(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      branchId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}branch_id'],
      )!,
      categoryId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}category_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      price: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price'],
      )!,
      isAvailable: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_available'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      ),
    );
  }

  @override
  $ProductsTable createAlias(String alias) {
    return $ProductsTable(attachedDatabase, alias);
  }
}

class Product extends DataClass implements Insertable<Product> {
  final String id;
  final String branchId;
  final String categoryId;
  final String name;
  final double price;
  final bool isAvailable;
  final DateTime? updatedAt;
  const Product({
    required this.id,
    required this.branchId,
    required this.categoryId,
    required this.name,
    required this.price,
    required this.isAvailable,
    this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['branch_id'] = Variable<String>(branchId);
    map['category_id'] = Variable<String>(categoryId);
    map['name'] = Variable<String>(name);
    map['price'] = Variable<double>(price);
    map['is_available'] = Variable<bool>(isAvailable);
    if (!nullToAbsent || updatedAt != null) {
      map['updated_at'] = Variable<DateTime>(updatedAt);
    }
    return map;
  }

  ProductsCompanion toCompanion(bool nullToAbsent) {
    return ProductsCompanion(
      id: Value(id),
      branchId: Value(branchId),
      categoryId: Value(categoryId),
      name: Value(name),
      price: Value(price),
      isAvailable: Value(isAvailable),
      updatedAt: updatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAt),
    );
  }

  factory Product.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Product(
      id: serializer.fromJson<String>(json['id']),
      branchId: serializer.fromJson<String>(json['branchId']),
      categoryId: serializer.fromJson<String>(json['categoryId']),
      name: serializer.fromJson<String>(json['name']),
      price: serializer.fromJson<double>(json['price']),
      isAvailable: serializer.fromJson<bool>(json['isAvailable']),
      updatedAt: serializer.fromJson<DateTime?>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'branchId': serializer.toJson<String>(branchId),
      'categoryId': serializer.toJson<String>(categoryId),
      'name': serializer.toJson<String>(name),
      'price': serializer.toJson<double>(price),
      'isAvailable': serializer.toJson<bool>(isAvailable),
      'updatedAt': serializer.toJson<DateTime?>(updatedAt),
    };
  }

  Product copyWith({
    String? id,
    String? branchId,
    String? categoryId,
    String? name,
    double? price,
    bool? isAvailable,
    Value<DateTime?> updatedAt = const Value.absent(),
  }) => Product(
    id: id ?? this.id,
    branchId: branchId ?? this.branchId,
    categoryId: categoryId ?? this.categoryId,
    name: name ?? this.name,
    price: price ?? this.price,
    isAvailable: isAvailable ?? this.isAvailable,
    updatedAt: updatedAt.present ? updatedAt.value : this.updatedAt,
  );
  Product copyWithCompanion(ProductsCompanion data) {
    return Product(
      id: data.id.present ? data.id.value : this.id,
      branchId: data.branchId.present ? data.branchId.value : this.branchId,
      categoryId: data.categoryId.present
          ? data.categoryId.value
          : this.categoryId,
      name: data.name.present ? data.name.value : this.name,
      price: data.price.present ? data.price.value : this.price,
      isAvailable: data.isAvailable.present
          ? data.isAvailable.value
          : this.isAvailable,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Product(')
          ..write('id: $id, ')
          ..write('branchId: $branchId, ')
          ..write('categoryId: $categoryId, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('isAvailable: $isAvailable, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    branchId,
    categoryId,
    name,
    price,
    isAvailable,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Product &&
          other.id == this.id &&
          other.branchId == this.branchId &&
          other.categoryId == this.categoryId &&
          other.name == this.name &&
          other.price == this.price &&
          other.isAvailable == this.isAvailable &&
          other.updatedAt == this.updatedAt);
}

class ProductsCompanion extends UpdateCompanion<Product> {
  final Value<String> id;
  final Value<String> branchId;
  final Value<String> categoryId;
  final Value<String> name;
  final Value<double> price;
  final Value<bool> isAvailable;
  final Value<DateTime?> updatedAt;
  final Value<int> rowid;
  const ProductsCompanion({
    this.id = const Value.absent(),
    this.branchId = const Value.absent(),
    this.categoryId = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.isAvailable = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ProductsCompanion.insert({
    required String id,
    this.branchId = const Value.absent(),
    required String categoryId,
    required String name,
    required double price,
    this.isAvailable = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       categoryId = Value(categoryId),
       name = Value(name),
       price = Value(price);
  static Insertable<Product> custom({
    Expression<String>? id,
    Expression<String>? branchId,
    Expression<String>? categoryId,
    Expression<String>? name,
    Expression<double>? price,
    Expression<bool>? isAvailable,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (branchId != null) 'branch_id': branchId,
      if (categoryId != null) 'category_id': categoryId,
      if (name != null) 'name': name,
      if (price != null) 'price': price,
      if (isAvailable != null) 'is_available': isAvailable,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ProductsCompanion copyWith({
    Value<String>? id,
    Value<String>? branchId,
    Value<String>? categoryId,
    Value<String>? name,
    Value<double>? price,
    Value<bool>? isAvailable,
    Value<DateTime?>? updatedAt,
    Value<int>? rowid,
  }) {
    return ProductsCompanion(
      id: id ?? this.id,
      branchId: branchId ?? this.branchId,
      categoryId: categoryId ?? this.categoryId,
      name: name ?? this.name,
      price: price ?? this.price,
      isAvailable: isAvailable ?? this.isAvailable,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (branchId.present) {
      map['branch_id'] = Variable<String>(branchId.value);
    }
    if (categoryId.present) {
      map['category_id'] = Variable<String>(categoryId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (isAvailable.present) {
      map['is_available'] = Variable<bool>(isAvailable.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProductsCompanion(')
          ..write('id: $id, ')
          ..write('branchId: $branchId, ')
          ..write('categoryId: $categoryId, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('isAvailable: $isAvailable, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ShiftsTable extends Shifts with TableInfo<$ShiftsTable, Shift> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ShiftsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _branchIdMeta = const VerificationMeta(
    'branchId',
  );
  @override
  late final GeneratedColumn<String> branchId = GeneratedColumn<String>(
    'branch_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('BRANCH-01'),
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _openingTimeMeta = const VerificationMeta(
    'openingTime',
  );
  @override
  late final GeneratedColumn<DateTime> openingTime = GeneratedColumn<DateTime>(
    'opening_time',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _closingTimeMeta = const VerificationMeta(
    'closingTime',
  );
  @override
  late final GeneratedColumn<DateTime> closingTime = GeneratedColumn<DateTime>(
    'closing_time',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _startingCashMeta = const VerificationMeta(
    'startingCash',
  );
  @override
  late final GeneratedColumn<double> startingCash = GeneratedColumn<double>(
    'starting_cash',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0.0),
  );
  static const VerificationMeta _expectedCashMeta = const VerificationMeta(
    'expectedCash',
  );
  @override
  late final GeneratedColumn<double> expectedCash = GeneratedColumn<double>(
    'expected_cash',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _actualCashMeta = const VerificationMeta(
    'actualCash',
  );
  @override
  late final GeneratedColumn<double> actualCash = GeneratedColumn<double>(
    'actual_cash',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    branchId,
    userId,
    openingTime,
    closingTime,
    startingCash,
    expectedCash,
    actualCash,
    notes,
    isSynced,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'shifts';
  @override
  VerificationContext validateIntegrity(
    Insertable<Shift> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('branch_id')) {
      context.handle(
        _branchIdMeta,
        branchId.isAcceptableOrUnknown(data['branch_id']!, _branchIdMeta),
      );
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('opening_time')) {
      context.handle(
        _openingTimeMeta,
        openingTime.isAcceptableOrUnknown(
          data['opening_time']!,
          _openingTimeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_openingTimeMeta);
    }
    if (data.containsKey('closing_time')) {
      context.handle(
        _closingTimeMeta,
        closingTime.isAcceptableOrUnknown(
          data['closing_time']!,
          _closingTimeMeta,
        ),
      );
    }
    if (data.containsKey('starting_cash')) {
      context.handle(
        _startingCashMeta,
        startingCash.isAcceptableOrUnknown(
          data['starting_cash']!,
          _startingCashMeta,
        ),
      );
    }
    if (data.containsKey('expected_cash')) {
      context.handle(
        _expectedCashMeta,
        expectedCash.isAcceptableOrUnknown(
          data['expected_cash']!,
          _expectedCashMeta,
        ),
      );
    }
    if (data.containsKey('actual_cash')) {
      context.handle(
        _actualCashMeta,
        actualCash.isAcceptableOrUnknown(data['actual_cash']!, _actualCashMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Shift map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Shift(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      branchId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}branch_id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      openingTime: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}opening_time'],
      )!,
      closingTime: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}closing_time'],
      ),
      startingCash: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}starting_cash'],
      )!,
      expectedCash: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}expected_cash'],
      ),
      actualCash: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}actual_cash'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
    );
  }

  @override
  $ShiftsTable createAlias(String alias) {
    return $ShiftsTable(attachedDatabase, alias);
  }
}

class Shift extends DataClass implements Insertable<Shift> {
  final String id;
  final String branchId;
  final String userId;
  final DateTime openingTime;
  final DateTime? closingTime;
  final double startingCash;
  final double? expectedCash;
  final double? actualCash;
  final String? notes;
  final bool isSynced;
  const Shift({
    required this.id,
    required this.branchId,
    required this.userId,
    required this.openingTime,
    this.closingTime,
    required this.startingCash,
    this.expectedCash,
    this.actualCash,
    this.notes,
    required this.isSynced,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['branch_id'] = Variable<String>(branchId);
    map['user_id'] = Variable<String>(userId);
    map['opening_time'] = Variable<DateTime>(openingTime);
    if (!nullToAbsent || closingTime != null) {
      map['closing_time'] = Variable<DateTime>(closingTime);
    }
    map['starting_cash'] = Variable<double>(startingCash);
    if (!nullToAbsent || expectedCash != null) {
      map['expected_cash'] = Variable<double>(expectedCash);
    }
    if (!nullToAbsent || actualCash != null) {
      map['actual_cash'] = Variable<double>(actualCash);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['is_synced'] = Variable<bool>(isSynced);
    return map;
  }

  ShiftsCompanion toCompanion(bool nullToAbsent) {
    return ShiftsCompanion(
      id: Value(id),
      branchId: Value(branchId),
      userId: Value(userId),
      openingTime: Value(openingTime),
      closingTime: closingTime == null && nullToAbsent
          ? const Value.absent()
          : Value(closingTime),
      startingCash: Value(startingCash),
      expectedCash: expectedCash == null && nullToAbsent
          ? const Value.absent()
          : Value(expectedCash),
      actualCash: actualCash == null && nullToAbsent
          ? const Value.absent()
          : Value(actualCash),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      isSynced: Value(isSynced),
    );
  }

  factory Shift.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Shift(
      id: serializer.fromJson<String>(json['id']),
      branchId: serializer.fromJson<String>(json['branchId']),
      userId: serializer.fromJson<String>(json['userId']),
      openingTime: serializer.fromJson<DateTime>(json['openingTime']),
      closingTime: serializer.fromJson<DateTime?>(json['closingTime']),
      startingCash: serializer.fromJson<double>(json['startingCash']),
      expectedCash: serializer.fromJson<double?>(json['expectedCash']),
      actualCash: serializer.fromJson<double?>(json['actualCash']),
      notes: serializer.fromJson<String?>(json['notes']),
      isSynced: serializer.fromJson<bool>(json['isSynced']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'branchId': serializer.toJson<String>(branchId),
      'userId': serializer.toJson<String>(userId),
      'openingTime': serializer.toJson<DateTime>(openingTime),
      'closingTime': serializer.toJson<DateTime?>(closingTime),
      'startingCash': serializer.toJson<double>(startingCash),
      'expectedCash': serializer.toJson<double?>(expectedCash),
      'actualCash': serializer.toJson<double?>(actualCash),
      'notes': serializer.toJson<String?>(notes),
      'isSynced': serializer.toJson<bool>(isSynced),
    };
  }

  Shift copyWith({
    String? id,
    String? branchId,
    String? userId,
    DateTime? openingTime,
    Value<DateTime?> closingTime = const Value.absent(),
    double? startingCash,
    Value<double?> expectedCash = const Value.absent(),
    Value<double?> actualCash = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    bool? isSynced,
  }) => Shift(
    id: id ?? this.id,
    branchId: branchId ?? this.branchId,
    userId: userId ?? this.userId,
    openingTime: openingTime ?? this.openingTime,
    closingTime: closingTime.present ? closingTime.value : this.closingTime,
    startingCash: startingCash ?? this.startingCash,
    expectedCash: expectedCash.present ? expectedCash.value : this.expectedCash,
    actualCash: actualCash.present ? actualCash.value : this.actualCash,
    notes: notes.present ? notes.value : this.notes,
    isSynced: isSynced ?? this.isSynced,
  );
  Shift copyWithCompanion(ShiftsCompanion data) {
    return Shift(
      id: data.id.present ? data.id.value : this.id,
      branchId: data.branchId.present ? data.branchId.value : this.branchId,
      userId: data.userId.present ? data.userId.value : this.userId,
      openingTime: data.openingTime.present
          ? data.openingTime.value
          : this.openingTime,
      closingTime: data.closingTime.present
          ? data.closingTime.value
          : this.closingTime,
      startingCash: data.startingCash.present
          ? data.startingCash.value
          : this.startingCash,
      expectedCash: data.expectedCash.present
          ? data.expectedCash.value
          : this.expectedCash,
      actualCash: data.actualCash.present
          ? data.actualCash.value
          : this.actualCash,
      notes: data.notes.present ? data.notes.value : this.notes,
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Shift(')
          ..write('id: $id, ')
          ..write('branchId: $branchId, ')
          ..write('userId: $userId, ')
          ..write('openingTime: $openingTime, ')
          ..write('closingTime: $closingTime, ')
          ..write('startingCash: $startingCash, ')
          ..write('expectedCash: $expectedCash, ')
          ..write('actualCash: $actualCash, ')
          ..write('notes: $notes, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    branchId,
    userId,
    openingTime,
    closingTime,
    startingCash,
    expectedCash,
    actualCash,
    notes,
    isSynced,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Shift &&
          other.id == this.id &&
          other.branchId == this.branchId &&
          other.userId == this.userId &&
          other.openingTime == this.openingTime &&
          other.closingTime == this.closingTime &&
          other.startingCash == this.startingCash &&
          other.expectedCash == this.expectedCash &&
          other.actualCash == this.actualCash &&
          other.notes == this.notes &&
          other.isSynced == this.isSynced);
}

class ShiftsCompanion extends UpdateCompanion<Shift> {
  final Value<String> id;
  final Value<String> branchId;
  final Value<String> userId;
  final Value<DateTime> openingTime;
  final Value<DateTime?> closingTime;
  final Value<double> startingCash;
  final Value<double?> expectedCash;
  final Value<double?> actualCash;
  final Value<String?> notes;
  final Value<bool> isSynced;
  final Value<int> rowid;
  const ShiftsCompanion({
    this.id = const Value.absent(),
    this.branchId = const Value.absent(),
    this.userId = const Value.absent(),
    this.openingTime = const Value.absent(),
    this.closingTime = const Value.absent(),
    this.startingCash = const Value.absent(),
    this.expectedCash = const Value.absent(),
    this.actualCash = const Value.absent(),
    this.notes = const Value.absent(),
    this.isSynced = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ShiftsCompanion.insert({
    required String id,
    this.branchId = const Value.absent(),
    required String userId,
    required DateTime openingTime,
    this.closingTime = const Value.absent(),
    this.startingCash = const Value.absent(),
    this.expectedCash = const Value.absent(),
    this.actualCash = const Value.absent(),
    this.notes = const Value.absent(),
    this.isSynced = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       openingTime = Value(openingTime);
  static Insertable<Shift> custom({
    Expression<String>? id,
    Expression<String>? branchId,
    Expression<String>? userId,
    Expression<DateTime>? openingTime,
    Expression<DateTime>? closingTime,
    Expression<double>? startingCash,
    Expression<double>? expectedCash,
    Expression<double>? actualCash,
    Expression<String>? notes,
    Expression<bool>? isSynced,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (branchId != null) 'branch_id': branchId,
      if (userId != null) 'user_id': userId,
      if (openingTime != null) 'opening_time': openingTime,
      if (closingTime != null) 'closing_time': closingTime,
      if (startingCash != null) 'starting_cash': startingCash,
      if (expectedCash != null) 'expected_cash': expectedCash,
      if (actualCash != null) 'actual_cash': actualCash,
      if (notes != null) 'notes': notes,
      if (isSynced != null) 'is_synced': isSynced,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ShiftsCompanion copyWith({
    Value<String>? id,
    Value<String>? branchId,
    Value<String>? userId,
    Value<DateTime>? openingTime,
    Value<DateTime?>? closingTime,
    Value<double>? startingCash,
    Value<double?>? expectedCash,
    Value<double?>? actualCash,
    Value<String?>? notes,
    Value<bool>? isSynced,
    Value<int>? rowid,
  }) {
    return ShiftsCompanion(
      id: id ?? this.id,
      branchId: branchId ?? this.branchId,
      userId: userId ?? this.userId,
      openingTime: openingTime ?? this.openingTime,
      closingTime: closingTime ?? this.closingTime,
      startingCash: startingCash ?? this.startingCash,
      expectedCash: expectedCash ?? this.expectedCash,
      actualCash: actualCash ?? this.actualCash,
      notes: notes ?? this.notes,
      isSynced: isSynced ?? this.isSynced,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (branchId.present) {
      map['branch_id'] = Variable<String>(branchId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (openingTime.present) {
      map['opening_time'] = Variable<DateTime>(openingTime.value);
    }
    if (closingTime.present) {
      map['closing_time'] = Variable<DateTime>(closingTime.value);
    }
    if (startingCash.present) {
      map['starting_cash'] = Variable<double>(startingCash.value);
    }
    if (expectedCash.present) {
      map['expected_cash'] = Variable<double>(expectedCash.value);
    }
    if (actualCash.present) {
      map['actual_cash'] = Variable<double>(actualCash.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ShiftsCompanion(')
          ..write('id: $id, ')
          ..write('branchId: $branchId, ')
          ..write('userId: $userId, ')
          ..write('openingTime: $openingTime, ')
          ..write('closingTime: $closingTime, ')
          ..write('startingCash: $startingCash, ')
          ..write('expectedCash: $expectedCash, ')
          ..write('actualCash: $actualCash, ')
          ..write('notes: $notes, ')
          ..write('isSynced: $isSynced, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OrdersTable extends Orders with TableInfo<$OrdersTable, Order> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OrdersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _branchIdMeta = const VerificationMeta(
    'branchId',
  );
  @override
  late final GeneratedColumn<String> branchId = GeneratedColumn<String>(
    'branch_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('BRANCH-01'),
  );
  static const VerificationMeta _receiptNumberMeta = const VerificationMeta(
    'receiptNumber',
  );
  @override
  late final GeneratedColumn<String> receiptNumber = GeneratedColumn<String>(
    'receipt_number',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _tableIdMeta = const VerificationMeta(
    'tableId',
  );
  @override
  late final GeneratedColumn<String> tableId = GeneratedColumn<String>(
    'table_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _totalAmountMeta = const VerificationMeta(
    'totalAmount',
  );
  @override
  late final GeneratedColumn<double> totalAmount = GeneratedColumn<double>(
    'total_amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _shiftIdMeta = const VerificationMeta(
    'shiftId',
  );
  @override
  late final GeneratedColumn<String> shiftId = GeneratedColumn<String>(
    'shift_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES shifts (id)',
    ),
  );
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    branchId,
    receiptNumber,
    userId,
    tableId,
    totalAmount,
    status,
    createdAt,
    updatedAt,
    shiftId,
    isSynced,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'orders';
  @override
  VerificationContext validateIntegrity(
    Insertable<Order> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('branch_id')) {
      context.handle(
        _branchIdMeta,
        branchId.isAcceptableOrUnknown(data['branch_id']!, _branchIdMeta),
      );
    }
    if (data.containsKey('receipt_number')) {
      context.handle(
        _receiptNumberMeta,
        receiptNumber.isAcceptableOrUnknown(
          data['receipt_number']!,
          _receiptNumberMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_receiptNumberMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('table_id')) {
      context.handle(
        _tableIdMeta,
        tableId.isAcceptableOrUnknown(data['table_id']!, _tableIdMeta),
      );
    }
    if (data.containsKey('total_amount')) {
      context.handle(
        _totalAmountMeta,
        totalAmount.isAcceptableOrUnknown(
          data['total_amount']!,
          _totalAmountMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_totalAmountMeta);
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    } else if (isInserting) {
      context.missing(_statusMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('shift_id')) {
      context.handle(
        _shiftIdMeta,
        shiftId.isAcceptableOrUnknown(data['shift_id']!, _shiftIdMeta),
      );
    } else if (isInserting) {
      context.missing(_shiftIdMeta);
    }
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Order map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Order(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      branchId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}branch_id'],
      )!,
      receiptNumber: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}receipt_number'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      tableId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}table_id'],
      ),
      totalAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}total_amount'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      shiftId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}shift_id'],
      )!,
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
    );
  }

  @override
  $OrdersTable createAlias(String alias) {
    return $OrdersTable(attachedDatabase, alias);
  }
}

class Order extends DataClass implements Insertable<Order> {
  final String id;
  final String branchId;
  final String receiptNumber;
  final String userId;
  final String? tableId;
  final double totalAmount;
  final String status;
  final DateTime createdAt;
  final DateTime updatedAt;
  final String shiftId;
  final bool isSynced;
  const Order({
    required this.id,
    required this.branchId,
    required this.receiptNumber,
    required this.userId,
    this.tableId,
    required this.totalAmount,
    required this.status,
    required this.createdAt,
    required this.updatedAt,
    required this.shiftId,
    required this.isSynced,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['branch_id'] = Variable<String>(branchId);
    map['receipt_number'] = Variable<String>(receiptNumber);
    map['user_id'] = Variable<String>(userId);
    if (!nullToAbsent || tableId != null) {
      map['table_id'] = Variable<String>(tableId);
    }
    map['total_amount'] = Variable<double>(totalAmount);
    map['status'] = Variable<String>(status);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['shift_id'] = Variable<String>(shiftId);
    map['is_synced'] = Variable<bool>(isSynced);
    return map;
  }

  OrdersCompanion toCompanion(bool nullToAbsent) {
    return OrdersCompanion(
      id: Value(id),
      branchId: Value(branchId),
      receiptNumber: Value(receiptNumber),
      userId: Value(userId),
      tableId: tableId == null && nullToAbsent
          ? const Value.absent()
          : Value(tableId),
      totalAmount: Value(totalAmount),
      status: Value(status),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      shiftId: Value(shiftId),
      isSynced: Value(isSynced),
    );
  }

  factory Order.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Order(
      id: serializer.fromJson<String>(json['id']),
      branchId: serializer.fromJson<String>(json['branchId']),
      receiptNumber: serializer.fromJson<String>(json['receiptNumber']),
      userId: serializer.fromJson<String>(json['userId']),
      tableId: serializer.fromJson<String?>(json['tableId']),
      totalAmount: serializer.fromJson<double>(json['totalAmount']),
      status: serializer.fromJson<String>(json['status']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      shiftId: serializer.fromJson<String>(json['shiftId']),
      isSynced: serializer.fromJson<bool>(json['isSynced']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'branchId': serializer.toJson<String>(branchId),
      'receiptNumber': serializer.toJson<String>(receiptNumber),
      'userId': serializer.toJson<String>(userId),
      'tableId': serializer.toJson<String?>(tableId),
      'totalAmount': serializer.toJson<double>(totalAmount),
      'status': serializer.toJson<String>(status),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'shiftId': serializer.toJson<String>(shiftId),
      'isSynced': serializer.toJson<bool>(isSynced),
    };
  }

  Order copyWith({
    String? id,
    String? branchId,
    String? receiptNumber,
    String? userId,
    Value<String?> tableId = const Value.absent(),
    double? totalAmount,
    String? status,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? shiftId,
    bool? isSynced,
  }) => Order(
    id: id ?? this.id,
    branchId: branchId ?? this.branchId,
    receiptNumber: receiptNumber ?? this.receiptNumber,
    userId: userId ?? this.userId,
    tableId: tableId.present ? tableId.value : this.tableId,
    totalAmount: totalAmount ?? this.totalAmount,
    status: status ?? this.status,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    shiftId: shiftId ?? this.shiftId,
    isSynced: isSynced ?? this.isSynced,
  );
  Order copyWithCompanion(OrdersCompanion data) {
    return Order(
      id: data.id.present ? data.id.value : this.id,
      branchId: data.branchId.present ? data.branchId.value : this.branchId,
      receiptNumber: data.receiptNumber.present
          ? data.receiptNumber.value
          : this.receiptNumber,
      userId: data.userId.present ? data.userId.value : this.userId,
      tableId: data.tableId.present ? data.tableId.value : this.tableId,
      totalAmount: data.totalAmount.present
          ? data.totalAmount.value
          : this.totalAmount,
      status: data.status.present ? data.status.value : this.status,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      shiftId: data.shiftId.present ? data.shiftId.value : this.shiftId,
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Order(')
          ..write('id: $id, ')
          ..write('branchId: $branchId, ')
          ..write('receiptNumber: $receiptNumber, ')
          ..write('userId: $userId, ')
          ..write('tableId: $tableId, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('shiftId: $shiftId, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    branchId,
    receiptNumber,
    userId,
    tableId,
    totalAmount,
    status,
    createdAt,
    updatedAt,
    shiftId,
    isSynced,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Order &&
          other.id == this.id &&
          other.branchId == this.branchId &&
          other.receiptNumber == this.receiptNumber &&
          other.userId == this.userId &&
          other.tableId == this.tableId &&
          other.totalAmount == this.totalAmount &&
          other.status == this.status &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.shiftId == this.shiftId &&
          other.isSynced == this.isSynced);
}

class OrdersCompanion extends UpdateCompanion<Order> {
  final Value<String> id;
  final Value<String> branchId;
  final Value<String> receiptNumber;
  final Value<String> userId;
  final Value<String?> tableId;
  final Value<double> totalAmount;
  final Value<String> status;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<String> shiftId;
  final Value<bool> isSynced;
  final Value<int> rowid;
  const OrdersCompanion({
    this.id = const Value.absent(),
    this.branchId = const Value.absent(),
    this.receiptNumber = const Value.absent(),
    this.userId = const Value.absent(),
    this.tableId = const Value.absent(),
    this.totalAmount = const Value.absent(),
    this.status = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.shiftId = const Value.absent(),
    this.isSynced = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OrdersCompanion.insert({
    required String id,
    this.branchId = const Value.absent(),
    required String receiptNumber,
    required String userId,
    this.tableId = const Value.absent(),
    required double totalAmount,
    required String status,
    required DateTime createdAt,
    required DateTime updatedAt,
    required String shiftId,
    this.isSynced = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       receiptNumber = Value(receiptNumber),
       userId = Value(userId),
       totalAmount = Value(totalAmount),
       status = Value(status),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt),
       shiftId = Value(shiftId);
  static Insertable<Order> custom({
    Expression<String>? id,
    Expression<String>? branchId,
    Expression<String>? receiptNumber,
    Expression<String>? userId,
    Expression<String>? tableId,
    Expression<double>? totalAmount,
    Expression<String>? status,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<String>? shiftId,
    Expression<bool>? isSynced,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (branchId != null) 'branch_id': branchId,
      if (receiptNumber != null) 'receipt_number': receiptNumber,
      if (userId != null) 'user_id': userId,
      if (tableId != null) 'table_id': tableId,
      if (totalAmount != null) 'total_amount': totalAmount,
      if (status != null) 'status': status,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (shiftId != null) 'shift_id': shiftId,
      if (isSynced != null) 'is_synced': isSynced,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OrdersCompanion copyWith({
    Value<String>? id,
    Value<String>? branchId,
    Value<String>? receiptNumber,
    Value<String>? userId,
    Value<String?>? tableId,
    Value<double>? totalAmount,
    Value<String>? status,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<String>? shiftId,
    Value<bool>? isSynced,
    Value<int>? rowid,
  }) {
    return OrdersCompanion(
      id: id ?? this.id,
      branchId: branchId ?? this.branchId,
      receiptNumber: receiptNumber ?? this.receiptNumber,
      userId: userId ?? this.userId,
      tableId: tableId ?? this.tableId,
      totalAmount: totalAmount ?? this.totalAmount,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      shiftId: shiftId ?? this.shiftId,
      isSynced: isSynced ?? this.isSynced,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (branchId.present) {
      map['branch_id'] = Variable<String>(branchId.value);
    }
    if (receiptNumber.present) {
      map['receipt_number'] = Variable<String>(receiptNumber.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (tableId.present) {
      map['table_id'] = Variable<String>(tableId.value);
    }
    if (totalAmount.present) {
      map['total_amount'] = Variable<double>(totalAmount.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (shiftId.present) {
      map['shift_id'] = Variable<String>(shiftId.value);
    }
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OrdersCompanion(')
          ..write('id: $id, ')
          ..write('branchId: $branchId, ')
          ..write('receiptNumber: $receiptNumber, ')
          ..write('userId: $userId, ')
          ..write('tableId: $tableId, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('shiftId: $shiftId, ')
          ..write('isSynced: $isSynced, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OrderItemsTable extends OrderItems
    with TableInfo<$OrderItemsTable, OrderItem> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OrderItemsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _orderIdMeta = const VerificationMeta(
    'orderId',
  );
  @override
  late final GeneratedColumn<String> orderId = GeneratedColumn<String>(
    'order_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES orders (id)',
    ),
  );
  static const VerificationMeta _productIdMeta = const VerificationMeta(
    'productId',
  );
  @override
  late final GeneratedColumn<String> productId = GeneratedColumn<String>(
    'product_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES products (id)',
    ),
  );
  static const VerificationMeta _quantityMeta = const VerificationMeta(
    'quantity',
  );
  @override
  late final GeneratedColumn<int> quantity = GeneratedColumn<int>(
    'quantity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _priceAtTimeOfOrderMeta =
      const VerificationMeta('priceAtTimeOfOrder');
  @override
  late final GeneratedColumn<double> priceAtTimeOfOrder =
      GeneratedColumn<double>(
        'price_at_time_of_order',
        aliasedName,
        false,
        type: DriftSqlType.double,
        requiredDuringInsert: true,
      );
  static const VerificationMeta _routeToMeta = const VerificationMeta(
    'routeTo',
  );
  @override
  late final GeneratedColumn<String> routeTo = GeneratedColumn<String>(
    'route_to',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    orderId,
    productId,
    quantity,
    priceAtTimeOfOrder,
    routeTo,
    notes,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'order_items';
  @override
  VerificationContext validateIntegrity(
    Insertable<OrderItem> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('order_id')) {
      context.handle(
        _orderIdMeta,
        orderId.isAcceptableOrUnknown(data['order_id']!, _orderIdMeta),
      );
    } else if (isInserting) {
      context.missing(_orderIdMeta);
    }
    if (data.containsKey('product_id')) {
      context.handle(
        _productIdMeta,
        productId.isAcceptableOrUnknown(data['product_id']!, _productIdMeta),
      );
    } else if (isInserting) {
      context.missing(_productIdMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(
        _quantityMeta,
        quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta),
      );
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('price_at_time_of_order')) {
      context.handle(
        _priceAtTimeOfOrderMeta,
        priceAtTimeOfOrder.isAcceptableOrUnknown(
          data['price_at_time_of_order']!,
          _priceAtTimeOfOrderMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_priceAtTimeOfOrderMeta);
    }
    if (data.containsKey('route_to')) {
      context.handle(
        _routeToMeta,
        routeTo.isAcceptableOrUnknown(data['route_to']!, _routeToMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OrderItem map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OrderItem(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      orderId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}order_id'],
      )!,
      productId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}product_id'],
      )!,
      quantity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}quantity'],
      )!,
      priceAtTimeOfOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price_at_time_of_order'],
      )!,
      routeTo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}route_to'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
    );
  }

  @override
  $OrderItemsTable createAlias(String alias) {
    return $OrderItemsTable(attachedDatabase, alias);
  }
}

class OrderItem extends DataClass implements Insertable<OrderItem> {
  final String id;
  final String orderId;
  final String productId;
  final int quantity;
  final double priceAtTimeOfOrder;
  final String? routeTo;
  final String? notes;
  const OrderItem({
    required this.id,
    required this.orderId,
    required this.productId,
    required this.quantity,
    required this.priceAtTimeOfOrder,
    this.routeTo,
    this.notes,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['order_id'] = Variable<String>(orderId);
    map['product_id'] = Variable<String>(productId);
    map['quantity'] = Variable<int>(quantity);
    map['price_at_time_of_order'] = Variable<double>(priceAtTimeOfOrder);
    if (!nullToAbsent || routeTo != null) {
      map['route_to'] = Variable<String>(routeTo);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    return map;
  }

  OrderItemsCompanion toCompanion(bool nullToAbsent) {
    return OrderItemsCompanion(
      id: Value(id),
      orderId: Value(orderId),
      productId: Value(productId),
      quantity: Value(quantity),
      priceAtTimeOfOrder: Value(priceAtTimeOfOrder),
      routeTo: routeTo == null && nullToAbsent
          ? const Value.absent()
          : Value(routeTo),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
    );
  }

  factory OrderItem.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OrderItem(
      id: serializer.fromJson<String>(json['id']),
      orderId: serializer.fromJson<String>(json['orderId']),
      productId: serializer.fromJson<String>(json['productId']),
      quantity: serializer.fromJson<int>(json['quantity']),
      priceAtTimeOfOrder: serializer.fromJson<double>(
        json['priceAtTimeOfOrder'],
      ),
      routeTo: serializer.fromJson<String?>(json['routeTo']),
      notes: serializer.fromJson<String?>(json['notes']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'orderId': serializer.toJson<String>(orderId),
      'productId': serializer.toJson<String>(productId),
      'quantity': serializer.toJson<int>(quantity),
      'priceAtTimeOfOrder': serializer.toJson<double>(priceAtTimeOfOrder),
      'routeTo': serializer.toJson<String?>(routeTo),
      'notes': serializer.toJson<String?>(notes),
    };
  }

  OrderItem copyWith({
    String? id,
    String? orderId,
    String? productId,
    int? quantity,
    double? priceAtTimeOfOrder,
    Value<String?> routeTo = const Value.absent(),
    Value<String?> notes = const Value.absent(),
  }) => OrderItem(
    id: id ?? this.id,
    orderId: orderId ?? this.orderId,
    productId: productId ?? this.productId,
    quantity: quantity ?? this.quantity,
    priceAtTimeOfOrder: priceAtTimeOfOrder ?? this.priceAtTimeOfOrder,
    routeTo: routeTo.present ? routeTo.value : this.routeTo,
    notes: notes.present ? notes.value : this.notes,
  );
  OrderItem copyWithCompanion(OrderItemsCompanion data) {
    return OrderItem(
      id: data.id.present ? data.id.value : this.id,
      orderId: data.orderId.present ? data.orderId.value : this.orderId,
      productId: data.productId.present ? data.productId.value : this.productId,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      priceAtTimeOfOrder: data.priceAtTimeOfOrder.present
          ? data.priceAtTimeOfOrder.value
          : this.priceAtTimeOfOrder,
      routeTo: data.routeTo.present ? data.routeTo.value : this.routeTo,
      notes: data.notes.present ? data.notes.value : this.notes,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OrderItem(')
          ..write('id: $id, ')
          ..write('orderId: $orderId, ')
          ..write('productId: $productId, ')
          ..write('quantity: $quantity, ')
          ..write('priceAtTimeOfOrder: $priceAtTimeOfOrder, ')
          ..write('routeTo: $routeTo, ')
          ..write('notes: $notes')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    orderId,
    productId,
    quantity,
    priceAtTimeOfOrder,
    routeTo,
    notes,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OrderItem &&
          other.id == this.id &&
          other.orderId == this.orderId &&
          other.productId == this.productId &&
          other.quantity == this.quantity &&
          other.priceAtTimeOfOrder == this.priceAtTimeOfOrder &&
          other.routeTo == this.routeTo &&
          other.notes == this.notes);
}

class OrderItemsCompanion extends UpdateCompanion<OrderItem> {
  final Value<String> id;
  final Value<String> orderId;
  final Value<String> productId;
  final Value<int> quantity;
  final Value<double> priceAtTimeOfOrder;
  final Value<String?> routeTo;
  final Value<String?> notes;
  final Value<int> rowid;
  const OrderItemsCompanion({
    this.id = const Value.absent(),
    this.orderId = const Value.absent(),
    this.productId = const Value.absent(),
    this.quantity = const Value.absent(),
    this.priceAtTimeOfOrder = const Value.absent(),
    this.routeTo = const Value.absent(),
    this.notes = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OrderItemsCompanion.insert({
    required String id,
    required String orderId,
    required String productId,
    required int quantity,
    required double priceAtTimeOfOrder,
    this.routeTo = const Value.absent(),
    this.notes = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       orderId = Value(orderId),
       productId = Value(productId),
       quantity = Value(quantity),
       priceAtTimeOfOrder = Value(priceAtTimeOfOrder);
  static Insertable<OrderItem> custom({
    Expression<String>? id,
    Expression<String>? orderId,
    Expression<String>? productId,
    Expression<int>? quantity,
    Expression<double>? priceAtTimeOfOrder,
    Expression<String>? routeTo,
    Expression<String>? notes,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (orderId != null) 'order_id': orderId,
      if (productId != null) 'product_id': productId,
      if (quantity != null) 'quantity': quantity,
      if (priceAtTimeOfOrder != null)
        'price_at_time_of_order': priceAtTimeOfOrder,
      if (routeTo != null) 'route_to': routeTo,
      if (notes != null) 'notes': notes,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OrderItemsCompanion copyWith({
    Value<String>? id,
    Value<String>? orderId,
    Value<String>? productId,
    Value<int>? quantity,
    Value<double>? priceAtTimeOfOrder,
    Value<String?>? routeTo,
    Value<String?>? notes,
    Value<int>? rowid,
  }) {
    return OrderItemsCompanion(
      id: id ?? this.id,
      orderId: orderId ?? this.orderId,
      productId: productId ?? this.productId,
      quantity: quantity ?? this.quantity,
      priceAtTimeOfOrder: priceAtTimeOfOrder ?? this.priceAtTimeOfOrder,
      routeTo: routeTo ?? this.routeTo,
      notes: notes ?? this.notes,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (orderId.present) {
      map['order_id'] = Variable<String>(orderId.value);
    }
    if (productId.present) {
      map['product_id'] = Variable<String>(productId.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<int>(quantity.value);
    }
    if (priceAtTimeOfOrder.present) {
      map['price_at_time_of_order'] = Variable<double>(
        priceAtTimeOfOrder.value,
      );
    }
    if (routeTo.present) {
      map['route_to'] = Variable<String>(routeTo.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OrderItemsCompanion(')
          ..write('id: $id, ')
          ..write('orderId: $orderId, ')
          ..write('productId: $productId, ')
          ..write('quantity: $quantity, ')
          ..write('priceAtTimeOfOrder: $priceAtTimeOfOrder, ')
          ..write('routeTo: $routeTo, ')
          ..write('notes: $notes, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OrderItemModifiersTable extends OrderItemModifiers
    with TableInfo<$OrderItemModifiersTable, OrderItemModifier> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OrderItemModifiersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _orderItemIdMeta = const VerificationMeta(
    'orderItemId',
  );
  @override
  late final GeneratedColumn<String> orderItemId = GeneratedColumn<String>(
    'order_item_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES order_items (id)',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _priceDeltaMeta = const VerificationMeta(
    'priceDelta',
  );
  @override
  late final GeneratedColumn<double> priceDelta = GeneratedColumn<double>(
    'price_delta',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _routeToMeta = const VerificationMeta(
    'routeTo',
  );
  @override
  late final GeneratedColumn<String> routeTo = GeneratedColumn<String>(
    'route_to',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    orderItemId,
    name,
    priceDelta,
    routeTo,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'order_item_modifiers';
  @override
  VerificationContext validateIntegrity(
    Insertable<OrderItemModifier> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('order_item_id')) {
      context.handle(
        _orderItemIdMeta,
        orderItemId.isAcceptableOrUnknown(
          data['order_item_id']!,
          _orderItemIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_orderItemIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('price_delta')) {
      context.handle(
        _priceDeltaMeta,
        priceDelta.isAcceptableOrUnknown(data['price_delta']!, _priceDeltaMeta),
      );
    }
    if (data.containsKey('route_to')) {
      context.handle(
        _routeToMeta,
        routeTo.isAcceptableOrUnknown(data['route_to']!, _routeToMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OrderItemModifier map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OrderItemModifier(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      orderItemId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}order_item_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      priceDelta: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price_delta'],
      )!,
      routeTo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}route_to'],
      ),
    );
  }

  @override
  $OrderItemModifiersTable createAlias(String alias) {
    return $OrderItemModifiersTable(attachedDatabase, alias);
  }
}

class OrderItemModifier extends DataClass
    implements Insertable<OrderItemModifier> {
  final String id;
  final String orderItemId;
  final String name;
  final double priceDelta;
  final String? routeTo;
  const OrderItemModifier({
    required this.id,
    required this.orderItemId,
    required this.name,
    required this.priceDelta,
    this.routeTo,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['order_item_id'] = Variable<String>(orderItemId);
    map['name'] = Variable<String>(name);
    map['price_delta'] = Variable<double>(priceDelta);
    if (!nullToAbsent || routeTo != null) {
      map['route_to'] = Variable<String>(routeTo);
    }
    return map;
  }

  OrderItemModifiersCompanion toCompanion(bool nullToAbsent) {
    return OrderItemModifiersCompanion(
      id: Value(id),
      orderItemId: Value(orderItemId),
      name: Value(name),
      priceDelta: Value(priceDelta),
      routeTo: routeTo == null && nullToAbsent
          ? const Value.absent()
          : Value(routeTo),
    );
  }

  factory OrderItemModifier.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OrderItemModifier(
      id: serializer.fromJson<String>(json['id']),
      orderItemId: serializer.fromJson<String>(json['orderItemId']),
      name: serializer.fromJson<String>(json['name']),
      priceDelta: serializer.fromJson<double>(json['priceDelta']),
      routeTo: serializer.fromJson<String?>(json['routeTo']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'orderItemId': serializer.toJson<String>(orderItemId),
      'name': serializer.toJson<String>(name),
      'priceDelta': serializer.toJson<double>(priceDelta),
      'routeTo': serializer.toJson<String?>(routeTo),
    };
  }

  OrderItemModifier copyWith({
    String? id,
    String? orderItemId,
    String? name,
    double? priceDelta,
    Value<String?> routeTo = const Value.absent(),
  }) => OrderItemModifier(
    id: id ?? this.id,
    orderItemId: orderItemId ?? this.orderItemId,
    name: name ?? this.name,
    priceDelta: priceDelta ?? this.priceDelta,
    routeTo: routeTo.present ? routeTo.value : this.routeTo,
  );
  OrderItemModifier copyWithCompanion(OrderItemModifiersCompanion data) {
    return OrderItemModifier(
      id: data.id.present ? data.id.value : this.id,
      orderItemId: data.orderItemId.present
          ? data.orderItemId.value
          : this.orderItemId,
      name: data.name.present ? data.name.value : this.name,
      priceDelta: data.priceDelta.present
          ? data.priceDelta.value
          : this.priceDelta,
      routeTo: data.routeTo.present ? data.routeTo.value : this.routeTo,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OrderItemModifier(')
          ..write('id: $id, ')
          ..write('orderItemId: $orderItemId, ')
          ..write('name: $name, ')
          ..write('priceDelta: $priceDelta, ')
          ..write('routeTo: $routeTo')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, orderItemId, name, priceDelta, routeTo);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OrderItemModifier &&
          other.id == this.id &&
          other.orderItemId == this.orderItemId &&
          other.name == this.name &&
          other.priceDelta == this.priceDelta &&
          other.routeTo == this.routeTo);
}

class OrderItemModifiersCompanion extends UpdateCompanion<OrderItemModifier> {
  final Value<String> id;
  final Value<String> orderItemId;
  final Value<String> name;
  final Value<double> priceDelta;
  final Value<String?> routeTo;
  final Value<int> rowid;
  const OrderItemModifiersCompanion({
    this.id = const Value.absent(),
    this.orderItemId = const Value.absent(),
    this.name = const Value.absent(),
    this.priceDelta = const Value.absent(),
    this.routeTo = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OrderItemModifiersCompanion.insert({
    required String id,
    required String orderItemId,
    required String name,
    this.priceDelta = const Value.absent(),
    this.routeTo = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       orderItemId = Value(orderItemId),
       name = Value(name);
  static Insertable<OrderItemModifier> custom({
    Expression<String>? id,
    Expression<String>? orderItemId,
    Expression<String>? name,
    Expression<double>? priceDelta,
    Expression<String>? routeTo,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (orderItemId != null) 'order_item_id': orderItemId,
      if (name != null) 'name': name,
      if (priceDelta != null) 'price_delta': priceDelta,
      if (routeTo != null) 'route_to': routeTo,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OrderItemModifiersCompanion copyWith({
    Value<String>? id,
    Value<String>? orderItemId,
    Value<String>? name,
    Value<double>? priceDelta,
    Value<String?>? routeTo,
    Value<int>? rowid,
  }) {
    return OrderItemModifiersCompanion(
      id: id ?? this.id,
      orderItemId: orderItemId ?? this.orderItemId,
      name: name ?? this.name,
      priceDelta: priceDelta ?? this.priceDelta,
      routeTo: routeTo ?? this.routeTo,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (orderItemId.present) {
      map['order_item_id'] = Variable<String>(orderItemId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (priceDelta.present) {
      map['price_delta'] = Variable<double>(priceDelta.value);
    }
    if (routeTo.present) {
      map['route_to'] = Variable<String>(routeTo.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OrderItemModifiersCompanion(')
          ..write('id: $id, ')
          ..write('orderItemId: $orderItemId, ')
          ..write('name: $name, ')
          ..write('priceDelta: $priceDelta, ')
          ..write('routeTo: $routeTo, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OrderItemSidesTable extends OrderItemSides
    with TableInfo<$OrderItemSidesTable, OrderItemSide> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OrderItemSidesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _orderItemIdMeta = const VerificationMeta(
    'orderItemId',
  );
  @override
  late final GeneratedColumn<String> orderItemId = GeneratedColumn<String>(
    'order_item_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES order_items (id)',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _quantityMeta = const VerificationMeta(
    'quantity',
  );
  @override
  late final GeneratedColumn<int> quantity = GeneratedColumn<int>(
    'quantity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _priceDeltaMeta = const VerificationMeta(
    'priceDelta',
  );
  @override
  late final GeneratedColumn<double> priceDelta = GeneratedColumn<double>(
    'price_delta',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _routeToMeta = const VerificationMeta(
    'routeTo',
  );
  @override
  late final GeneratedColumn<String> routeTo = GeneratedColumn<String>(
    'route_to',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    orderItemId,
    name,
    quantity,
    priceDelta,
    routeTo,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'order_item_sides';
  @override
  VerificationContext validateIntegrity(
    Insertable<OrderItemSide> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('order_item_id')) {
      context.handle(
        _orderItemIdMeta,
        orderItemId.isAcceptableOrUnknown(
          data['order_item_id']!,
          _orderItemIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_orderItemIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(
        _quantityMeta,
        quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta),
      );
    }
    if (data.containsKey('price_delta')) {
      context.handle(
        _priceDeltaMeta,
        priceDelta.isAcceptableOrUnknown(data['price_delta']!, _priceDeltaMeta),
      );
    }
    if (data.containsKey('route_to')) {
      context.handle(
        _routeToMeta,
        routeTo.isAcceptableOrUnknown(data['route_to']!, _routeToMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OrderItemSide map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OrderItemSide(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      orderItemId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}order_item_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      quantity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}quantity'],
      )!,
      priceDelta: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price_delta'],
      )!,
      routeTo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}route_to'],
      ),
    );
  }

  @override
  $OrderItemSidesTable createAlias(String alias) {
    return $OrderItemSidesTable(attachedDatabase, alias);
  }
}

class OrderItemSide extends DataClass implements Insertable<OrderItemSide> {
  final String id;
  final String orderItemId;
  final String name;
  final int quantity;
  final double priceDelta;
  final String? routeTo;
  const OrderItemSide({
    required this.id,
    required this.orderItemId,
    required this.name,
    required this.quantity,
    required this.priceDelta,
    this.routeTo,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['order_item_id'] = Variable<String>(orderItemId);
    map['name'] = Variable<String>(name);
    map['quantity'] = Variable<int>(quantity);
    map['price_delta'] = Variable<double>(priceDelta);
    if (!nullToAbsent || routeTo != null) {
      map['route_to'] = Variable<String>(routeTo);
    }
    return map;
  }

  OrderItemSidesCompanion toCompanion(bool nullToAbsent) {
    return OrderItemSidesCompanion(
      id: Value(id),
      orderItemId: Value(orderItemId),
      name: Value(name),
      quantity: Value(quantity),
      priceDelta: Value(priceDelta),
      routeTo: routeTo == null && nullToAbsent
          ? const Value.absent()
          : Value(routeTo),
    );
  }

  factory OrderItemSide.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OrderItemSide(
      id: serializer.fromJson<String>(json['id']),
      orderItemId: serializer.fromJson<String>(json['orderItemId']),
      name: serializer.fromJson<String>(json['name']),
      quantity: serializer.fromJson<int>(json['quantity']),
      priceDelta: serializer.fromJson<double>(json['priceDelta']),
      routeTo: serializer.fromJson<String?>(json['routeTo']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'orderItemId': serializer.toJson<String>(orderItemId),
      'name': serializer.toJson<String>(name),
      'quantity': serializer.toJson<int>(quantity),
      'priceDelta': serializer.toJson<double>(priceDelta),
      'routeTo': serializer.toJson<String?>(routeTo),
    };
  }

  OrderItemSide copyWith({
    String? id,
    String? orderItemId,
    String? name,
    int? quantity,
    double? priceDelta,
    Value<String?> routeTo = const Value.absent(),
  }) => OrderItemSide(
    id: id ?? this.id,
    orderItemId: orderItemId ?? this.orderItemId,
    name: name ?? this.name,
    quantity: quantity ?? this.quantity,
    priceDelta: priceDelta ?? this.priceDelta,
    routeTo: routeTo.present ? routeTo.value : this.routeTo,
  );
  OrderItemSide copyWithCompanion(OrderItemSidesCompanion data) {
    return OrderItemSide(
      id: data.id.present ? data.id.value : this.id,
      orderItemId: data.orderItemId.present
          ? data.orderItemId.value
          : this.orderItemId,
      name: data.name.present ? data.name.value : this.name,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      priceDelta: data.priceDelta.present
          ? data.priceDelta.value
          : this.priceDelta,
      routeTo: data.routeTo.present ? data.routeTo.value : this.routeTo,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OrderItemSide(')
          ..write('id: $id, ')
          ..write('orderItemId: $orderItemId, ')
          ..write('name: $name, ')
          ..write('quantity: $quantity, ')
          ..write('priceDelta: $priceDelta, ')
          ..write('routeTo: $routeTo')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, orderItemId, name, quantity, priceDelta, routeTo);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OrderItemSide &&
          other.id == this.id &&
          other.orderItemId == this.orderItemId &&
          other.name == this.name &&
          other.quantity == this.quantity &&
          other.priceDelta == this.priceDelta &&
          other.routeTo == this.routeTo);
}

class OrderItemSidesCompanion extends UpdateCompanion<OrderItemSide> {
  final Value<String> id;
  final Value<String> orderItemId;
  final Value<String> name;
  final Value<int> quantity;
  final Value<double> priceDelta;
  final Value<String?> routeTo;
  final Value<int> rowid;
  const OrderItemSidesCompanion({
    this.id = const Value.absent(),
    this.orderItemId = const Value.absent(),
    this.name = const Value.absent(),
    this.quantity = const Value.absent(),
    this.priceDelta = const Value.absent(),
    this.routeTo = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OrderItemSidesCompanion.insert({
    required String id,
    required String orderItemId,
    required String name,
    this.quantity = const Value.absent(),
    this.priceDelta = const Value.absent(),
    this.routeTo = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       orderItemId = Value(orderItemId),
       name = Value(name);
  static Insertable<OrderItemSide> custom({
    Expression<String>? id,
    Expression<String>? orderItemId,
    Expression<String>? name,
    Expression<int>? quantity,
    Expression<double>? priceDelta,
    Expression<String>? routeTo,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (orderItemId != null) 'order_item_id': orderItemId,
      if (name != null) 'name': name,
      if (quantity != null) 'quantity': quantity,
      if (priceDelta != null) 'price_delta': priceDelta,
      if (routeTo != null) 'route_to': routeTo,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OrderItemSidesCompanion copyWith({
    Value<String>? id,
    Value<String>? orderItemId,
    Value<String>? name,
    Value<int>? quantity,
    Value<double>? priceDelta,
    Value<String?>? routeTo,
    Value<int>? rowid,
  }) {
    return OrderItemSidesCompanion(
      id: id ?? this.id,
      orderItemId: orderItemId ?? this.orderItemId,
      name: name ?? this.name,
      quantity: quantity ?? this.quantity,
      priceDelta: priceDelta ?? this.priceDelta,
      routeTo: routeTo ?? this.routeTo,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (orderItemId.present) {
      map['order_item_id'] = Variable<String>(orderItemId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<int>(quantity.value);
    }
    if (priceDelta.present) {
      map['price_delta'] = Variable<double>(priceDelta.value);
    }
    if (routeTo.present) {
      map['route_to'] = Variable<String>(routeTo.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OrderItemSidesCompanion(')
          ..write('id: $id, ')
          ..write('orderItemId: $orderItemId, ')
          ..write('name: $name, ')
          ..write('quantity: $quantity, ')
          ..write('priceDelta: $priceDelta, ')
          ..write('routeTo: $routeTo, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PaymentsTable extends Payments with TableInfo<$PaymentsTable, Payment> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PaymentsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _branchIdMeta = const VerificationMeta(
    'branchId',
  );
  @override
  late final GeneratedColumn<String> branchId = GeneratedColumn<String>(
    'branch_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('BRANCH-01'),
  );
  static const VerificationMeta _orderIdMeta = const VerificationMeta(
    'orderId',
  );
  @override
  late final GeneratedColumn<String> orderId = GeneratedColumn<String>(
    'order_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES orders (id)',
    ),
  );
  static const VerificationMeta _shiftIdMeta = const VerificationMeta(
    'shiftId',
  );
  @override
  late final GeneratedColumn<String> shiftId = GeneratedColumn<String>(
    'shift_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES shifts (id)',
    ),
  );
  static const VerificationMeta _methodMeta = const VerificationMeta('method');
  @override
  late final GeneratedColumn<String> method = GeneratedColumn<String>(
    'method',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _amountMeta = const VerificationMeta('amount');
  @override
  late final GeneratedColumn<double> amount = GeneratedColumn<double>(
    'amount',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _referenceMeta = const VerificationMeta(
    'reference',
  );
  @override
  late final GeneratedColumn<String> reference = GeneratedColumn<String>(
    'reference',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    branchId,
    orderId,
    shiftId,
    method,
    amount,
    reference,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'payments';
  @override
  VerificationContext validateIntegrity(
    Insertable<Payment> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('branch_id')) {
      context.handle(
        _branchIdMeta,
        branchId.isAcceptableOrUnknown(data['branch_id']!, _branchIdMeta),
      );
    }
    if (data.containsKey('order_id')) {
      context.handle(
        _orderIdMeta,
        orderId.isAcceptableOrUnknown(data['order_id']!, _orderIdMeta),
      );
    } else if (isInserting) {
      context.missing(_orderIdMeta);
    }
    if (data.containsKey('shift_id')) {
      context.handle(
        _shiftIdMeta,
        shiftId.isAcceptableOrUnknown(data['shift_id']!, _shiftIdMeta),
      );
    } else if (isInserting) {
      context.missing(_shiftIdMeta);
    }
    if (data.containsKey('method')) {
      context.handle(
        _methodMeta,
        method.isAcceptableOrUnknown(data['method']!, _methodMeta),
      );
    } else if (isInserting) {
      context.missing(_methodMeta);
    }
    if (data.containsKey('amount')) {
      context.handle(
        _amountMeta,
        amount.isAcceptableOrUnknown(data['amount']!, _amountMeta),
      );
    } else if (isInserting) {
      context.missing(_amountMeta);
    }
    if (data.containsKey('reference')) {
      context.handle(
        _referenceMeta,
        reference.isAcceptableOrUnknown(data['reference']!, _referenceMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Payment map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Payment(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      branchId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}branch_id'],
      )!,
      orderId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}order_id'],
      )!,
      shiftId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}shift_id'],
      )!,
      method: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}method'],
      )!,
      amount: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}amount'],
      )!,
      reference: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reference'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $PaymentsTable createAlias(String alias) {
    return $PaymentsTable(attachedDatabase, alias);
  }
}

class Payment extends DataClass implements Insertable<Payment> {
  final String id;
  final String branchId;
  final String orderId;
  final String shiftId;
  final String method;
  final double amount;
  final String? reference;
  final DateTime createdAt;
  const Payment({
    required this.id,
    required this.branchId,
    required this.orderId,
    required this.shiftId,
    required this.method,
    required this.amount,
    this.reference,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['branch_id'] = Variable<String>(branchId);
    map['order_id'] = Variable<String>(orderId);
    map['shift_id'] = Variable<String>(shiftId);
    map['method'] = Variable<String>(method);
    map['amount'] = Variable<double>(amount);
    if (!nullToAbsent || reference != null) {
      map['reference'] = Variable<String>(reference);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  PaymentsCompanion toCompanion(bool nullToAbsent) {
    return PaymentsCompanion(
      id: Value(id),
      branchId: Value(branchId),
      orderId: Value(orderId),
      shiftId: Value(shiftId),
      method: Value(method),
      amount: Value(amount),
      reference: reference == null && nullToAbsent
          ? const Value.absent()
          : Value(reference),
      createdAt: Value(createdAt),
    );
  }

  factory Payment.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Payment(
      id: serializer.fromJson<String>(json['id']),
      branchId: serializer.fromJson<String>(json['branchId']),
      orderId: serializer.fromJson<String>(json['orderId']),
      shiftId: serializer.fromJson<String>(json['shiftId']),
      method: serializer.fromJson<String>(json['method']),
      amount: serializer.fromJson<double>(json['amount']),
      reference: serializer.fromJson<String?>(json['reference']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'branchId': serializer.toJson<String>(branchId),
      'orderId': serializer.toJson<String>(orderId),
      'shiftId': serializer.toJson<String>(shiftId),
      'method': serializer.toJson<String>(method),
      'amount': serializer.toJson<double>(amount),
      'reference': serializer.toJson<String?>(reference),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  Payment copyWith({
    String? id,
    String? branchId,
    String? orderId,
    String? shiftId,
    String? method,
    double? amount,
    Value<String?> reference = const Value.absent(),
    DateTime? createdAt,
  }) => Payment(
    id: id ?? this.id,
    branchId: branchId ?? this.branchId,
    orderId: orderId ?? this.orderId,
    shiftId: shiftId ?? this.shiftId,
    method: method ?? this.method,
    amount: amount ?? this.amount,
    reference: reference.present ? reference.value : this.reference,
    createdAt: createdAt ?? this.createdAt,
  );
  Payment copyWithCompanion(PaymentsCompanion data) {
    return Payment(
      id: data.id.present ? data.id.value : this.id,
      branchId: data.branchId.present ? data.branchId.value : this.branchId,
      orderId: data.orderId.present ? data.orderId.value : this.orderId,
      shiftId: data.shiftId.present ? data.shiftId.value : this.shiftId,
      method: data.method.present ? data.method.value : this.method,
      amount: data.amount.present ? data.amount.value : this.amount,
      reference: data.reference.present ? data.reference.value : this.reference,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Payment(')
          ..write('id: $id, ')
          ..write('branchId: $branchId, ')
          ..write('orderId: $orderId, ')
          ..write('shiftId: $shiftId, ')
          ..write('method: $method, ')
          ..write('amount: $amount, ')
          ..write('reference: $reference, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    branchId,
    orderId,
    shiftId,
    method,
    amount,
    reference,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Payment &&
          other.id == this.id &&
          other.branchId == this.branchId &&
          other.orderId == this.orderId &&
          other.shiftId == this.shiftId &&
          other.method == this.method &&
          other.amount == this.amount &&
          other.reference == this.reference &&
          other.createdAt == this.createdAt);
}

class PaymentsCompanion extends UpdateCompanion<Payment> {
  final Value<String> id;
  final Value<String> branchId;
  final Value<String> orderId;
  final Value<String> shiftId;
  final Value<String> method;
  final Value<double> amount;
  final Value<String?> reference;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const PaymentsCompanion({
    this.id = const Value.absent(),
    this.branchId = const Value.absent(),
    this.orderId = const Value.absent(),
    this.shiftId = const Value.absent(),
    this.method = const Value.absent(),
    this.amount = const Value.absent(),
    this.reference = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PaymentsCompanion.insert({
    required String id,
    this.branchId = const Value.absent(),
    required String orderId,
    required String shiftId,
    required String method,
    required double amount,
    this.reference = const Value.absent(),
    required DateTime createdAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       orderId = Value(orderId),
       shiftId = Value(shiftId),
       method = Value(method),
       amount = Value(amount),
       createdAt = Value(createdAt);
  static Insertable<Payment> custom({
    Expression<String>? id,
    Expression<String>? branchId,
    Expression<String>? orderId,
    Expression<String>? shiftId,
    Expression<String>? method,
    Expression<double>? amount,
    Expression<String>? reference,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (branchId != null) 'branch_id': branchId,
      if (orderId != null) 'order_id': orderId,
      if (shiftId != null) 'shift_id': shiftId,
      if (method != null) 'method': method,
      if (amount != null) 'amount': amount,
      if (reference != null) 'reference': reference,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PaymentsCompanion copyWith({
    Value<String>? id,
    Value<String>? branchId,
    Value<String>? orderId,
    Value<String>? shiftId,
    Value<String>? method,
    Value<double>? amount,
    Value<String?>? reference,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return PaymentsCompanion(
      id: id ?? this.id,
      branchId: branchId ?? this.branchId,
      orderId: orderId ?? this.orderId,
      shiftId: shiftId ?? this.shiftId,
      method: method ?? this.method,
      amount: amount ?? this.amount,
      reference: reference ?? this.reference,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (branchId.present) {
      map['branch_id'] = Variable<String>(branchId.value);
    }
    if (orderId.present) {
      map['order_id'] = Variable<String>(orderId.value);
    }
    if (shiftId.present) {
      map['shift_id'] = Variable<String>(shiftId.value);
    }
    if (method.present) {
      map['method'] = Variable<String>(method.value);
    }
    if (amount.present) {
      map['amount'] = Variable<double>(amount.value);
    }
    if (reference.present) {
      map['reference'] = Variable<String>(reference.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PaymentsCompanion(')
          ..write('id: $id, ')
          ..write('branchId: $branchId, ')
          ..write('orderId: $orderId, ')
          ..write('shiftId: $shiftId, ')
          ..write('method: $method, ')
          ..write('amount: $amount, ')
          ..write('reference: $reference, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SeatingTablesTable extends SeatingTables
    with TableInfo<$SeatingTablesTable, SeatingTable> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SeatingTablesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _branchIdMeta = const VerificationMeta(
    'branchId',
  );
  @override
  late final GeneratedColumn<String> branchId = GeneratedColumn<String>(
    'branch_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('BRANCH-01'),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('FREE'),
  );
  static const VerificationMeta _floorMeta = const VerificationMeta('floor');
  @override
  late final GeneratedColumn<String> floor = GeneratedColumn<String>(
    'floor',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('Main'),
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    branchId,
    name,
    status,
    floor,
    updatedAt,
    isSynced,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'seating_tables';
  @override
  VerificationContext validateIntegrity(
    Insertable<SeatingTable> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('branch_id')) {
      context.handle(
        _branchIdMeta,
        branchId.isAcceptableOrUnknown(data['branch_id']!, _branchIdMeta),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('floor')) {
      context.handle(
        _floorMeta,
        floor.isAcceptableOrUnknown(data['floor']!, _floorMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SeatingTable map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SeatingTable(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      branchId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}branch_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      floor: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}floor'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      ),
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
    );
  }

  @override
  $SeatingTablesTable createAlias(String alias) {
    return $SeatingTablesTable(attachedDatabase, alias);
  }
}

class SeatingTable extends DataClass implements Insertable<SeatingTable> {
  final String id;
  final String branchId;
  final String name;
  final String status;
  final String floor;
  final DateTime? updatedAt;
  final bool isSynced;
  const SeatingTable({
    required this.id,
    required this.branchId,
    required this.name,
    required this.status,
    required this.floor,
    this.updatedAt,
    required this.isSynced,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['branch_id'] = Variable<String>(branchId);
    map['name'] = Variable<String>(name);
    map['status'] = Variable<String>(status);
    map['floor'] = Variable<String>(floor);
    if (!nullToAbsent || updatedAt != null) {
      map['updated_at'] = Variable<DateTime>(updatedAt);
    }
    map['is_synced'] = Variable<bool>(isSynced);
    return map;
  }

  SeatingTablesCompanion toCompanion(bool nullToAbsent) {
    return SeatingTablesCompanion(
      id: Value(id),
      branchId: Value(branchId),
      name: Value(name),
      status: Value(status),
      floor: Value(floor),
      updatedAt: updatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAt),
      isSynced: Value(isSynced),
    );
  }

  factory SeatingTable.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SeatingTable(
      id: serializer.fromJson<String>(json['id']),
      branchId: serializer.fromJson<String>(json['branchId']),
      name: serializer.fromJson<String>(json['name']),
      status: serializer.fromJson<String>(json['status']),
      floor: serializer.fromJson<String>(json['floor']),
      updatedAt: serializer.fromJson<DateTime?>(json['updatedAt']),
      isSynced: serializer.fromJson<bool>(json['isSynced']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'branchId': serializer.toJson<String>(branchId),
      'name': serializer.toJson<String>(name),
      'status': serializer.toJson<String>(status),
      'floor': serializer.toJson<String>(floor),
      'updatedAt': serializer.toJson<DateTime?>(updatedAt),
      'isSynced': serializer.toJson<bool>(isSynced),
    };
  }

  SeatingTable copyWith({
    String? id,
    String? branchId,
    String? name,
    String? status,
    String? floor,
    Value<DateTime?> updatedAt = const Value.absent(),
    bool? isSynced,
  }) => SeatingTable(
    id: id ?? this.id,
    branchId: branchId ?? this.branchId,
    name: name ?? this.name,
    status: status ?? this.status,
    floor: floor ?? this.floor,
    updatedAt: updatedAt.present ? updatedAt.value : this.updatedAt,
    isSynced: isSynced ?? this.isSynced,
  );
  SeatingTable copyWithCompanion(SeatingTablesCompanion data) {
    return SeatingTable(
      id: data.id.present ? data.id.value : this.id,
      branchId: data.branchId.present ? data.branchId.value : this.branchId,
      name: data.name.present ? data.name.value : this.name,
      status: data.status.present ? data.status.value : this.status,
      floor: data.floor.present ? data.floor.value : this.floor,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SeatingTable(')
          ..write('id: $id, ')
          ..write('branchId: $branchId, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('floor: $floor, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, branchId, name, status, floor, updatedAt, isSynced);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SeatingTable &&
          other.id == this.id &&
          other.branchId == this.branchId &&
          other.name == this.name &&
          other.status == this.status &&
          other.floor == this.floor &&
          other.updatedAt == this.updatedAt &&
          other.isSynced == this.isSynced);
}

class SeatingTablesCompanion extends UpdateCompanion<SeatingTable> {
  final Value<String> id;
  final Value<String> branchId;
  final Value<String> name;
  final Value<String> status;
  final Value<String> floor;
  final Value<DateTime?> updatedAt;
  final Value<bool> isSynced;
  final Value<int> rowid;
  const SeatingTablesCompanion({
    this.id = const Value.absent(),
    this.branchId = const Value.absent(),
    this.name = const Value.absent(),
    this.status = const Value.absent(),
    this.floor = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isSynced = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SeatingTablesCompanion.insert({
    required String id,
    this.branchId = const Value.absent(),
    required String name,
    this.status = const Value.absent(),
    this.floor = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isSynced = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name);
  static Insertable<SeatingTable> custom({
    Expression<String>? id,
    Expression<String>? branchId,
    Expression<String>? name,
    Expression<String>? status,
    Expression<String>? floor,
    Expression<DateTime>? updatedAt,
    Expression<bool>? isSynced,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (branchId != null) 'branch_id': branchId,
      if (name != null) 'name': name,
      if (status != null) 'status': status,
      if (floor != null) 'floor': floor,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (isSynced != null) 'is_synced': isSynced,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SeatingTablesCompanion copyWith({
    Value<String>? id,
    Value<String>? branchId,
    Value<String>? name,
    Value<String>? status,
    Value<String>? floor,
    Value<DateTime?>? updatedAt,
    Value<bool>? isSynced,
    Value<int>? rowid,
  }) {
    return SeatingTablesCompanion(
      id: id ?? this.id,
      branchId: branchId ?? this.branchId,
      name: name ?? this.name,
      status: status ?? this.status,
      floor: floor ?? this.floor,
      updatedAt: updatedAt ?? this.updatedAt,
      isSynced: isSynced ?? this.isSynced,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (branchId.present) {
      map['branch_id'] = Variable<String>(branchId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (floor.present) {
      map['floor'] = Variable<String>(floor.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SeatingTablesCompanion(')
          ..write('id: $id, ')
          ..write('branchId: $branchId, ')
          ..write('name: $name, ')
          ..write('status: $status, ')
          ..write('floor: $floor, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isSynced: $isSynced, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $CategoriesTable categories = $CategoriesTable(this);
  late final $ProductsTable products = $ProductsTable(this);
  late final $ShiftsTable shifts = $ShiftsTable(this);
  late final $OrdersTable orders = $OrdersTable(this);
  late final $OrderItemsTable orderItems = $OrderItemsTable(this);
  late final $OrderItemModifiersTable orderItemModifiers =
      $OrderItemModifiersTable(this);
  late final $OrderItemSidesTable orderItemSides = $OrderItemSidesTable(this);
  late final $PaymentsTable payments = $PaymentsTable(this);
  late final $SeatingTablesTable seatingTables = $SeatingTablesTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    categories,
    products,
    shifts,
    orders,
    orderItems,
    orderItemModifiers,
    orderItemSides,
    payments,
    seatingTables,
  ];
}

typedef $$CategoriesTableCreateCompanionBuilder =
    CategoriesCompanion Function({
      required String id,
      Value<String> branchId,
      required String name,
      Value<String?> colorHex,
      Value<int> sortOrder,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });
typedef $$CategoriesTableUpdateCompanionBuilder =
    CategoriesCompanion Function({
      Value<String> id,
      Value<String> branchId,
      Value<String> name,
      Value<String?> colorHex,
      Value<int> sortOrder,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });

final class $$CategoriesTableReferences
    extends BaseReferences<_$AppDatabase, $CategoriesTable, Category> {
  $$CategoriesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$ProductsTable, List<Product>> _productsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.products,
    aliasName: $_aliasNameGenerator(db.categories.id, db.products.categoryId),
  );

  $$ProductsTableProcessedTableManager get productsRefs {
    final manager = $$ProductsTableTableManager(
      $_db,
      $_db.products,
    ).filter((f) => f.categoryId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_productsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$CategoriesTableFilterComposer
    extends Composer<_$AppDatabase, $CategoriesTable> {
  $$CategoriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get branchId => $composableBuilder(
    column: $table.branchId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get colorHex => $composableBuilder(
    column: $table.colorHex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> productsRefs(
    Expression<bool> Function($$ProductsTableFilterComposer f) f,
  ) {
    final $$ProductsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.categoryId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableFilterComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CategoriesTableOrderingComposer
    extends Composer<_$AppDatabase, $CategoriesTable> {
  $$CategoriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get branchId => $composableBuilder(
    column: $table.branchId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get colorHex => $composableBuilder(
    column: $table.colorHex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sortOrder => $composableBuilder(
    column: $table.sortOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$CategoriesTableAnnotationComposer
    extends Composer<_$AppDatabase, $CategoriesTable> {
  $$CategoriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get branchId =>
      $composableBuilder(column: $table.branchId, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get colorHex =>
      $composableBuilder(column: $table.colorHex, builder: (column) => column);

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> productsRefs<T extends Object>(
    Expression<T> Function($$ProductsTableAnnotationComposer a) f,
  ) {
    final $$ProductsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.categoryId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableAnnotationComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CategoriesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CategoriesTable,
          Category,
          $$CategoriesTableFilterComposer,
          $$CategoriesTableOrderingComposer,
          $$CategoriesTableAnnotationComposer,
          $$CategoriesTableCreateCompanionBuilder,
          $$CategoriesTableUpdateCompanionBuilder,
          (Category, $$CategoriesTableReferences),
          Category,
          PrefetchHooks Function({bool productsRefs})
        > {
  $$CategoriesTableTableManager(_$AppDatabase db, $CategoriesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CategoriesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CategoriesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CategoriesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> branchId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> colorHex = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CategoriesCompanion(
                id: id,
                branchId: branchId,
                name: name,
                colorHex: colorHex,
                sortOrder: sortOrder,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String> branchId = const Value.absent(),
                required String name,
                Value<String?> colorHex = const Value.absent(),
                Value<int> sortOrder = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CategoriesCompanion.insert(
                id: id,
                branchId: branchId,
                name: name,
                colorHex: colorHex,
                sortOrder: sortOrder,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$CategoriesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({productsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (productsRefs) db.products],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (productsRefs)
                    await $_getPrefetchedData<
                      Category,
                      $CategoriesTable,
                      Product
                    >(
                      currentTable: table,
                      referencedTable: $$CategoriesTableReferences
                          ._productsRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$CategoriesTableReferences(
                            db,
                            table,
                            p0,
                          ).productsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.categoryId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$CategoriesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CategoriesTable,
      Category,
      $$CategoriesTableFilterComposer,
      $$CategoriesTableOrderingComposer,
      $$CategoriesTableAnnotationComposer,
      $$CategoriesTableCreateCompanionBuilder,
      $$CategoriesTableUpdateCompanionBuilder,
      (Category, $$CategoriesTableReferences),
      Category,
      PrefetchHooks Function({bool productsRefs})
    >;
typedef $$ProductsTableCreateCompanionBuilder =
    ProductsCompanion Function({
      required String id,
      Value<String> branchId,
      required String categoryId,
      required String name,
      required double price,
      Value<bool> isAvailable,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });
typedef $$ProductsTableUpdateCompanionBuilder =
    ProductsCompanion Function({
      Value<String> id,
      Value<String> branchId,
      Value<String> categoryId,
      Value<String> name,
      Value<double> price,
      Value<bool> isAvailable,
      Value<DateTime?> updatedAt,
      Value<int> rowid,
    });

final class $$ProductsTableReferences
    extends BaseReferences<_$AppDatabase, $ProductsTable, Product> {
  $$ProductsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $CategoriesTable _categoryIdTable(_$AppDatabase db) =>
      db.categories.createAlias(
        $_aliasNameGenerator(db.products.categoryId, db.categories.id),
      );

  $$CategoriesTableProcessedTableManager get categoryId {
    final $_column = $_itemColumn<String>('category_id')!;

    final manager = $$CategoriesTableTableManager(
      $_db,
      $_db.categories,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_categoryIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$OrderItemsTable, List<OrderItem>>
  _orderItemsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.orderItems,
    aliasName: $_aliasNameGenerator(db.products.id, db.orderItems.productId),
  );

  $$OrderItemsTableProcessedTableManager get orderItemsRefs {
    final manager = $$OrderItemsTableTableManager(
      $_db,
      $_db.orderItems,
    ).filter((f) => f.productId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_orderItemsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ProductsTableFilterComposer
    extends Composer<_$AppDatabase, $ProductsTable> {
  $$ProductsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get branchId => $composableBuilder(
    column: $table.branchId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isAvailable => $composableBuilder(
    column: $table.isAvailable,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$CategoriesTableFilterComposer get categoryId {
    final $$CategoriesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.categoryId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableFilterComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> orderItemsRefs(
    Expression<bool> Function($$OrderItemsTableFilterComposer f) f,
  ) {
    final $$OrderItemsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.orderItems,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemsTableFilterComposer(
            $db: $db,
            $table: $db.orderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ProductsTableOrderingComposer
    extends Composer<_$AppDatabase, $ProductsTable> {
  $$ProductsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get branchId => $composableBuilder(
    column: $table.branchId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isAvailable => $composableBuilder(
    column: $table.isAvailable,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$CategoriesTableOrderingComposer get categoryId {
    final $$CategoriesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.categoryId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableOrderingComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ProductsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ProductsTable> {
  $$ProductsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get branchId =>
      $composableBuilder(column: $table.branchId, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<bool> get isAvailable => $composableBuilder(
    column: $table.isAvailable,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$CategoriesTableAnnotationComposer get categoryId {
    final $$CategoriesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.categoryId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableAnnotationComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> orderItemsRefs<T extends Object>(
    Expression<T> Function($$OrderItemsTableAnnotationComposer a) f,
  ) {
    final $$OrderItemsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.orderItems,
      getReferencedColumn: (t) => t.productId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemsTableAnnotationComposer(
            $db: $db,
            $table: $db.orderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ProductsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ProductsTable,
          Product,
          $$ProductsTableFilterComposer,
          $$ProductsTableOrderingComposer,
          $$ProductsTableAnnotationComposer,
          $$ProductsTableCreateCompanionBuilder,
          $$ProductsTableUpdateCompanionBuilder,
          (Product, $$ProductsTableReferences),
          Product,
          PrefetchHooks Function({bool categoryId, bool orderItemsRefs})
        > {
  $$ProductsTableTableManager(_$AppDatabase db, $ProductsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ProductsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ProductsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ProductsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> branchId = const Value.absent(),
                Value<String> categoryId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<double> price = const Value.absent(),
                Value<bool> isAvailable = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ProductsCompanion(
                id: id,
                branchId: branchId,
                categoryId: categoryId,
                name: name,
                price: price,
                isAvailable: isAvailable,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String> branchId = const Value.absent(),
                required String categoryId,
                required String name,
                required double price,
                Value<bool> isAvailable = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ProductsCompanion.insert(
                id: id,
                branchId: branchId,
                categoryId: categoryId,
                name: name,
                price: price,
                isAvailable: isAvailable,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ProductsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({categoryId = false, orderItemsRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [if (orderItemsRefs) db.orderItems],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (categoryId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.categoryId,
                                    referencedTable: $$ProductsTableReferences
                                        ._categoryIdTable(db),
                                    referencedColumn: $$ProductsTableReferences
                                        ._categoryIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (orderItemsRefs)
                        await $_getPrefetchedData<
                          Product,
                          $ProductsTable,
                          OrderItem
                        >(
                          currentTable: table,
                          referencedTable: $$ProductsTableReferences
                              ._orderItemsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ProductsTableReferences(
                                db,
                                table,
                                p0,
                              ).orderItemsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.productId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ProductsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ProductsTable,
      Product,
      $$ProductsTableFilterComposer,
      $$ProductsTableOrderingComposer,
      $$ProductsTableAnnotationComposer,
      $$ProductsTableCreateCompanionBuilder,
      $$ProductsTableUpdateCompanionBuilder,
      (Product, $$ProductsTableReferences),
      Product,
      PrefetchHooks Function({bool categoryId, bool orderItemsRefs})
    >;
typedef $$ShiftsTableCreateCompanionBuilder =
    ShiftsCompanion Function({
      required String id,
      Value<String> branchId,
      required String userId,
      required DateTime openingTime,
      Value<DateTime?> closingTime,
      Value<double> startingCash,
      Value<double?> expectedCash,
      Value<double?> actualCash,
      Value<String?> notes,
      Value<bool> isSynced,
      Value<int> rowid,
    });
typedef $$ShiftsTableUpdateCompanionBuilder =
    ShiftsCompanion Function({
      Value<String> id,
      Value<String> branchId,
      Value<String> userId,
      Value<DateTime> openingTime,
      Value<DateTime?> closingTime,
      Value<double> startingCash,
      Value<double?> expectedCash,
      Value<double?> actualCash,
      Value<String?> notes,
      Value<bool> isSynced,
      Value<int> rowid,
    });

final class $$ShiftsTableReferences
    extends BaseReferences<_$AppDatabase, $ShiftsTable, Shift> {
  $$ShiftsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$OrdersTable, List<Order>> _ordersRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.orders,
    aliasName: $_aliasNameGenerator(db.shifts.id, db.orders.shiftId),
  );

  $$OrdersTableProcessedTableManager get ordersRefs {
    final manager = $$OrdersTableTableManager(
      $_db,
      $_db.orders,
    ).filter((f) => f.shiftId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_ordersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$PaymentsTable, List<Payment>> _paymentsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.payments,
    aliasName: $_aliasNameGenerator(db.shifts.id, db.payments.shiftId),
  );

  $$PaymentsTableProcessedTableManager get paymentsRefs {
    final manager = $$PaymentsTableTableManager(
      $_db,
      $_db.payments,
    ).filter((f) => f.shiftId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_paymentsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ShiftsTableFilterComposer
    extends Composer<_$AppDatabase, $ShiftsTable> {
  $$ShiftsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get branchId => $composableBuilder(
    column: $table.branchId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get openingTime => $composableBuilder(
    column: $table.openingTime,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get closingTime => $composableBuilder(
    column: $table.closingTime,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get startingCash => $composableBuilder(
    column: $table.startingCash,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get expectedCash => $composableBuilder(
    column: $table.expectedCash,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get actualCash => $composableBuilder(
    column: $table.actualCash,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> ordersRefs(
    Expression<bool> Function($$OrdersTableFilterComposer f) f,
  ) {
    final $$OrdersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.orders,
      getReferencedColumn: (t) => t.shiftId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrdersTableFilterComposer(
            $db: $db,
            $table: $db.orders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> paymentsRefs(
    Expression<bool> Function($$PaymentsTableFilterComposer f) f,
  ) {
    final $$PaymentsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.payments,
      getReferencedColumn: (t) => t.shiftId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PaymentsTableFilterComposer(
            $db: $db,
            $table: $db.payments,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ShiftsTableOrderingComposer
    extends Composer<_$AppDatabase, $ShiftsTable> {
  $$ShiftsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get branchId => $composableBuilder(
    column: $table.branchId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get openingTime => $composableBuilder(
    column: $table.openingTime,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get closingTime => $composableBuilder(
    column: $table.closingTime,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get startingCash => $composableBuilder(
    column: $table.startingCash,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get expectedCash => $composableBuilder(
    column: $table.expectedCash,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get actualCash => $composableBuilder(
    column: $table.actualCash,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ShiftsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ShiftsTable> {
  $$ShiftsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get branchId =>
      $composableBuilder(column: $table.branchId, builder: (column) => column);

  GeneratedColumn<String> get userId =>
      $composableBuilder(column: $table.userId, builder: (column) => column);

  GeneratedColumn<DateTime> get openingTime => $composableBuilder(
    column: $table.openingTime,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get closingTime => $composableBuilder(
    column: $table.closingTime,
    builder: (column) => column,
  );

  GeneratedColumn<double> get startingCash => $composableBuilder(
    column: $table.startingCash,
    builder: (column) => column,
  );

  GeneratedColumn<double> get expectedCash => $composableBuilder(
    column: $table.expectedCash,
    builder: (column) => column,
  );

  GeneratedColumn<double> get actualCash => $composableBuilder(
    column: $table.actualCash,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  Expression<T> ordersRefs<T extends Object>(
    Expression<T> Function($$OrdersTableAnnotationComposer a) f,
  ) {
    final $$OrdersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.orders,
      getReferencedColumn: (t) => t.shiftId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrdersTableAnnotationComposer(
            $db: $db,
            $table: $db.orders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> paymentsRefs<T extends Object>(
    Expression<T> Function($$PaymentsTableAnnotationComposer a) f,
  ) {
    final $$PaymentsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.payments,
      getReferencedColumn: (t) => t.shiftId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PaymentsTableAnnotationComposer(
            $db: $db,
            $table: $db.payments,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ShiftsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ShiftsTable,
          Shift,
          $$ShiftsTableFilterComposer,
          $$ShiftsTableOrderingComposer,
          $$ShiftsTableAnnotationComposer,
          $$ShiftsTableCreateCompanionBuilder,
          $$ShiftsTableUpdateCompanionBuilder,
          (Shift, $$ShiftsTableReferences),
          Shift,
          PrefetchHooks Function({bool ordersRefs, bool paymentsRefs})
        > {
  $$ShiftsTableTableManager(_$AppDatabase db, $ShiftsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ShiftsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ShiftsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ShiftsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> branchId = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<DateTime> openingTime = const Value.absent(),
                Value<DateTime?> closingTime = const Value.absent(),
                Value<double> startingCash = const Value.absent(),
                Value<double?> expectedCash = const Value.absent(),
                Value<double?> actualCash = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<bool> isSynced = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ShiftsCompanion(
                id: id,
                branchId: branchId,
                userId: userId,
                openingTime: openingTime,
                closingTime: closingTime,
                startingCash: startingCash,
                expectedCash: expectedCash,
                actualCash: actualCash,
                notes: notes,
                isSynced: isSynced,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String> branchId = const Value.absent(),
                required String userId,
                required DateTime openingTime,
                Value<DateTime?> closingTime = const Value.absent(),
                Value<double> startingCash = const Value.absent(),
                Value<double?> expectedCash = const Value.absent(),
                Value<double?> actualCash = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<bool> isSynced = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ShiftsCompanion.insert(
                id: id,
                branchId: branchId,
                userId: userId,
                openingTime: openingTime,
                closingTime: closingTime,
                startingCash: startingCash,
                expectedCash: expectedCash,
                actualCash: actualCash,
                notes: notes,
                isSynced: isSynced,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$ShiftsTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback: ({ordersRefs = false, paymentsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (ordersRefs) db.orders,
                if (paymentsRefs) db.payments,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (ordersRefs)
                    await $_getPrefetchedData<Shift, $ShiftsTable, Order>(
                      currentTable: table,
                      referencedTable: $$ShiftsTableReferences._ordersRefsTable(
                        db,
                      ),
                      managerFromTypedResult: (p0) =>
                          $$ShiftsTableReferences(db, table, p0).ordersRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.shiftId == item.id),
                      typedResults: items,
                    ),
                  if (paymentsRefs)
                    await $_getPrefetchedData<Shift, $ShiftsTable, Payment>(
                      currentTable: table,
                      referencedTable: $$ShiftsTableReferences
                          ._paymentsRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$ShiftsTableReferences(db, table, p0).paymentsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.shiftId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$ShiftsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ShiftsTable,
      Shift,
      $$ShiftsTableFilterComposer,
      $$ShiftsTableOrderingComposer,
      $$ShiftsTableAnnotationComposer,
      $$ShiftsTableCreateCompanionBuilder,
      $$ShiftsTableUpdateCompanionBuilder,
      (Shift, $$ShiftsTableReferences),
      Shift,
      PrefetchHooks Function({bool ordersRefs, bool paymentsRefs})
    >;
typedef $$OrdersTableCreateCompanionBuilder =
    OrdersCompanion Function({
      required String id,
      Value<String> branchId,
      required String receiptNumber,
      required String userId,
      Value<String?> tableId,
      required double totalAmount,
      required String status,
      required DateTime createdAt,
      required DateTime updatedAt,
      required String shiftId,
      Value<bool> isSynced,
      Value<int> rowid,
    });
typedef $$OrdersTableUpdateCompanionBuilder =
    OrdersCompanion Function({
      Value<String> id,
      Value<String> branchId,
      Value<String> receiptNumber,
      Value<String> userId,
      Value<String?> tableId,
      Value<double> totalAmount,
      Value<String> status,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<String> shiftId,
      Value<bool> isSynced,
      Value<int> rowid,
    });

final class $$OrdersTableReferences
    extends BaseReferences<_$AppDatabase, $OrdersTable, Order> {
  $$OrdersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ShiftsTable _shiftIdTable(_$AppDatabase db) => db.shifts.createAlias(
    $_aliasNameGenerator(db.orders.shiftId, db.shifts.id),
  );

  $$ShiftsTableProcessedTableManager get shiftId {
    final $_column = $_itemColumn<String>('shift_id')!;

    final manager = $$ShiftsTableTableManager(
      $_db,
      $_db.shifts,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_shiftIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$OrderItemsTable, List<OrderItem>>
  _orderItemsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.orderItems,
    aliasName: $_aliasNameGenerator(db.orders.id, db.orderItems.orderId),
  );

  $$OrderItemsTableProcessedTableManager get orderItemsRefs {
    final manager = $$OrderItemsTableTableManager(
      $_db,
      $_db.orderItems,
    ).filter((f) => f.orderId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_orderItemsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$PaymentsTable, List<Payment>> _paymentsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.payments,
    aliasName: $_aliasNameGenerator(db.orders.id, db.payments.orderId),
  );

  $$PaymentsTableProcessedTableManager get paymentsRefs {
    final manager = $$PaymentsTableTableManager(
      $_db,
      $_db.payments,
    ).filter((f) => f.orderId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_paymentsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$OrdersTableFilterComposer
    extends Composer<_$AppDatabase, $OrdersTable> {
  $$OrdersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get branchId => $composableBuilder(
    column: $table.branchId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get receiptNumber => $composableBuilder(
    column: $table.receiptNumber,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get tableId => $composableBuilder(
    column: $table.tableId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  $$ShiftsTableFilterComposer get shiftId {
    final $$ShiftsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shiftId,
      referencedTable: $db.shifts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShiftsTableFilterComposer(
            $db: $db,
            $table: $db.shifts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> orderItemsRefs(
    Expression<bool> Function($$OrderItemsTableFilterComposer f) f,
  ) {
    final $$OrderItemsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.orderItems,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemsTableFilterComposer(
            $db: $db,
            $table: $db.orderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> paymentsRefs(
    Expression<bool> Function($$PaymentsTableFilterComposer f) f,
  ) {
    final $$PaymentsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.payments,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PaymentsTableFilterComposer(
            $db: $db,
            $table: $db.payments,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$OrdersTableOrderingComposer
    extends Composer<_$AppDatabase, $OrdersTable> {
  $$OrdersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get branchId => $composableBuilder(
    column: $table.branchId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get receiptNumber => $composableBuilder(
    column: $table.receiptNumber,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get userId => $composableBuilder(
    column: $table.userId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get tableId => $composableBuilder(
    column: $table.tableId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  $$ShiftsTableOrderingComposer get shiftId {
    final $$ShiftsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shiftId,
      referencedTable: $db.shifts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShiftsTableOrderingComposer(
            $db: $db,
            $table: $db.shifts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OrdersTableAnnotationComposer
    extends Composer<_$AppDatabase, $OrdersTable> {
  $$OrdersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get branchId =>
      $composableBuilder(column: $table.branchId, builder: (column) => column);

  GeneratedColumn<String> get receiptNumber => $composableBuilder(
    column: $table.receiptNumber,
    builder: (column) => column,
  );

  GeneratedColumn<String> get userId =>
      $composableBuilder(column: $table.userId, builder: (column) => column);

  GeneratedColumn<String> get tableId =>
      $composableBuilder(column: $table.tableId, builder: (column) => column);

  GeneratedColumn<double> get totalAmount => $composableBuilder(
    column: $table.totalAmount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  $$ShiftsTableAnnotationComposer get shiftId {
    final $$ShiftsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shiftId,
      referencedTable: $db.shifts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShiftsTableAnnotationComposer(
            $db: $db,
            $table: $db.shifts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> orderItemsRefs<T extends Object>(
    Expression<T> Function($$OrderItemsTableAnnotationComposer a) f,
  ) {
    final $$OrderItemsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.orderItems,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemsTableAnnotationComposer(
            $db: $db,
            $table: $db.orderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> paymentsRefs<T extends Object>(
    Expression<T> Function($$PaymentsTableAnnotationComposer a) f,
  ) {
    final $$PaymentsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.payments,
      getReferencedColumn: (t) => t.orderId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$PaymentsTableAnnotationComposer(
            $db: $db,
            $table: $db.payments,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$OrdersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OrdersTable,
          Order,
          $$OrdersTableFilterComposer,
          $$OrdersTableOrderingComposer,
          $$OrdersTableAnnotationComposer,
          $$OrdersTableCreateCompanionBuilder,
          $$OrdersTableUpdateCompanionBuilder,
          (Order, $$OrdersTableReferences),
          Order,
          PrefetchHooks Function({
            bool shiftId,
            bool orderItemsRefs,
            bool paymentsRefs,
          })
        > {
  $$OrdersTableTableManager(_$AppDatabase db, $OrdersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OrdersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OrdersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OrdersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> branchId = const Value.absent(),
                Value<String> receiptNumber = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String?> tableId = const Value.absent(),
                Value<double> totalAmount = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<String> shiftId = const Value.absent(),
                Value<bool> isSynced = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OrdersCompanion(
                id: id,
                branchId: branchId,
                receiptNumber: receiptNumber,
                userId: userId,
                tableId: tableId,
                totalAmount: totalAmount,
                status: status,
                createdAt: createdAt,
                updatedAt: updatedAt,
                shiftId: shiftId,
                isSynced: isSynced,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String> branchId = const Value.absent(),
                required String receiptNumber,
                required String userId,
                Value<String?> tableId = const Value.absent(),
                required double totalAmount,
                required String status,
                required DateTime createdAt,
                required DateTime updatedAt,
                required String shiftId,
                Value<bool> isSynced = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OrdersCompanion.insert(
                id: id,
                branchId: branchId,
                receiptNumber: receiptNumber,
                userId: userId,
                tableId: tableId,
                totalAmount: totalAmount,
                status: status,
                createdAt: createdAt,
                updatedAt: updatedAt,
                shiftId: shiftId,
                isSynced: isSynced,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$OrdersTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                shiftId = false,
                orderItemsRefs = false,
                paymentsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (orderItemsRefs) db.orderItems,
                    if (paymentsRefs) db.payments,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (shiftId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.shiftId,
                                    referencedTable: $$OrdersTableReferences
                                        ._shiftIdTable(db),
                                    referencedColumn: $$OrdersTableReferences
                                        ._shiftIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (orderItemsRefs)
                        await $_getPrefetchedData<
                          Order,
                          $OrdersTable,
                          OrderItem
                        >(
                          currentTable: table,
                          referencedTable: $$OrdersTableReferences
                              ._orderItemsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$OrdersTableReferences(
                                db,
                                table,
                                p0,
                              ).orderItemsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.orderId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (paymentsRefs)
                        await $_getPrefetchedData<Order, $OrdersTable, Payment>(
                          currentTable: table,
                          referencedTable: $$OrdersTableReferences
                              ._paymentsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$OrdersTableReferences(
                                db,
                                table,
                                p0,
                              ).paymentsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.orderId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$OrdersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OrdersTable,
      Order,
      $$OrdersTableFilterComposer,
      $$OrdersTableOrderingComposer,
      $$OrdersTableAnnotationComposer,
      $$OrdersTableCreateCompanionBuilder,
      $$OrdersTableUpdateCompanionBuilder,
      (Order, $$OrdersTableReferences),
      Order,
      PrefetchHooks Function({
        bool shiftId,
        bool orderItemsRefs,
        bool paymentsRefs,
      })
    >;
typedef $$OrderItemsTableCreateCompanionBuilder =
    OrderItemsCompanion Function({
      required String id,
      required String orderId,
      required String productId,
      required int quantity,
      required double priceAtTimeOfOrder,
      Value<String?> routeTo,
      Value<String?> notes,
      Value<int> rowid,
    });
typedef $$OrderItemsTableUpdateCompanionBuilder =
    OrderItemsCompanion Function({
      Value<String> id,
      Value<String> orderId,
      Value<String> productId,
      Value<int> quantity,
      Value<double> priceAtTimeOfOrder,
      Value<String?> routeTo,
      Value<String?> notes,
      Value<int> rowid,
    });

final class $$OrderItemsTableReferences
    extends BaseReferences<_$AppDatabase, $OrderItemsTable, OrderItem> {
  $$OrderItemsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $OrdersTable _orderIdTable(_$AppDatabase db) => db.orders.createAlias(
    $_aliasNameGenerator(db.orderItems.orderId, db.orders.id),
  );

  $$OrdersTableProcessedTableManager get orderId {
    final $_column = $_itemColumn<String>('order_id')!;

    final manager = $$OrdersTableTableManager(
      $_db,
      $_db.orders,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orderIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ProductsTable _productIdTable(_$AppDatabase db) =>
      db.products.createAlias(
        $_aliasNameGenerator(db.orderItems.productId, db.products.id),
      );

  $$ProductsTableProcessedTableManager get productId {
    final $_column = $_itemColumn<String>('product_id')!;

    final manager = $$ProductsTableTableManager(
      $_db,
      $_db.products,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$OrderItemModifiersTable, List<OrderItemModifier>>
  _orderItemModifiersRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.orderItemModifiers,
        aliasName: $_aliasNameGenerator(
          db.orderItems.id,
          db.orderItemModifiers.orderItemId,
        ),
      );

  $$OrderItemModifiersTableProcessedTableManager get orderItemModifiersRefs {
    final manager = $$OrderItemModifiersTableTableManager(
      $_db,
      $_db.orderItemModifiers,
    ).filter((f) => f.orderItemId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _orderItemModifiersRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$OrderItemSidesTable, List<OrderItemSide>>
  _orderItemSidesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.orderItemSides,
    aliasName: $_aliasNameGenerator(
      db.orderItems.id,
      db.orderItemSides.orderItemId,
    ),
  );

  $$OrderItemSidesTableProcessedTableManager get orderItemSidesRefs {
    final manager = $$OrderItemSidesTableTableManager(
      $_db,
      $_db.orderItemSides,
    ).filter((f) => f.orderItemId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_orderItemSidesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$OrderItemsTableFilterComposer
    extends Composer<_$AppDatabase, $OrderItemsTable> {
  $$OrderItemsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get priceAtTimeOfOrder => $composableBuilder(
    column: $table.priceAtTimeOfOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get routeTo => $composableBuilder(
    column: $table.routeTo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  $$OrdersTableFilterComposer get orderId {
    final $$OrdersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.orders,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrdersTableFilterComposer(
            $db: $db,
            $table: $db.orders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductsTableFilterComposer get productId {
    final $$ProductsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableFilterComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> orderItemModifiersRefs(
    Expression<bool> Function($$OrderItemModifiersTableFilterComposer f) f,
  ) {
    final $$OrderItemModifiersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.orderItemModifiers,
      getReferencedColumn: (t) => t.orderItemId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemModifiersTableFilterComposer(
            $db: $db,
            $table: $db.orderItemModifiers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> orderItemSidesRefs(
    Expression<bool> Function($$OrderItemSidesTableFilterComposer f) f,
  ) {
    final $$OrderItemSidesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.orderItemSides,
      getReferencedColumn: (t) => t.orderItemId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemSidesTableFilterComposer(
            $db: $db,
            $table: $db.orderItemSides,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$OrderItemsTableOrderingComposer
    extends Composer<_$AppDatabase, $OrderItemsTable> {
  $$OrderItemsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get priceAtTimeOfOrder => $composableBuilder(
    column: $table.priceAtTimeOfOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get routeTo => $composableBuilder(
    column: $table.routeTo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  $$OrdersTableOrderingComposer get orderId {
    final $$OrdersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.orders,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrdersTableOrderingComposer(
            $db: $db,
            $table: $db.orders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductsTableOrderingComposer get productId {
    final $$ProductsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableOrderingComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OrderItemsTableAnnotationComposer
    extends Composer<_$AppDatabase, $OrderItemsTable> {
  $$OrderItemsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<double> get priceAtTimeOfOrder => $composableBuilder(
    column: $table.priceAtTimeOfOrder,
    builder: (column) => column,
  );

  GeneratedColumn<String> get routeTo =>
      $composableBuilder(column: $table.routeTo, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  $$OrdersTableAnnotationComposer get orderId {
    final $$OrdersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.orders,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrdersTableAnnotationComposer(
            $db: $db,
            $table: $db.orders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ProductsTableAnnotationComposer get productId {
    final $$ProductsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.productId,
      referencedTable: $db.products,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ProductsTableAnnotationComposer(
            $db: $db,
            $table: $db.products,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> orderItemModifiersRefs<T extends Object>(
    Expression<T> Function($$OrderItemModifiersTableAnnotationComposer a) f,
  ) {
    final $$OrderItemModifiersTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.orderItemModifiers,
          getReferencedColumn: (t) => t.orderItemId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$OrderItemModifiersTableAnnotationComposer(
                $db: $db,
                $table: $db.orderItemModifiers,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> orderItemSidesRefs<T extends Object>(
    Expression<T> Function($$OrderItemSidesTableAnnotationComposer a) f,
  ) {
    final $$OrderItemSidesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.orderItemSides,
      getReferencedColumn: (t) => t.orderItemId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemSidesTableAnnotationComposer(
            $db: $db,
            $table: $db.orderItemSides,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$OrderItemsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OrderItemsTable,
          OrderItem,
          $$OrderItemsTableFilterComposer,
          $$OrderItemsTableOrderingComposer,
          $$OrderItemsTableAnnotationComposer,
          $$OrderItemsTableCreateCompanionBuilder,
          $$OrderItemsTableUpdateCompanionBuilder,
          (OrderItem, $$OrderItemsTableReferences),
          OrderItem,
          PrefetchHooks Function({
            bool orderId,
            bool productId,
            bool orderItemModifiersRefs,
            bool orderItemSidesRefs,
          })
        > {
  $$OrderItemsTableTableManager(_$AppDatabase db, $OrderItemsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OrderItemsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OrderItemsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OrderItemsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> orderId = const Value.absent(),
                Value<String> productId = const Value.absent(),
                Value<int> quantity = const Value.absent(),
                Value<double> priceAtTimeOfOrder = const Value.absent(),
                Value<String?> routeTo = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OrderItemsCompanion(
                id: id,
                orderId: orderId,
                productId: productId,
                quantity: quantity,
                priceAtTimeOfOrder: priceAtTimeOfOrder,
                routeTo: routeTo,
                notes: notes,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String orderId,
                required String productId,
                required int quantity,
                required double priceAtTimeOfOrder,
                Value<String?> routeTo = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OrderItemsCompanion.insert(
                id: id,
                orderId: orderId,
                productId: productId,
                quantity: quantity,
                priceAtTimeOfOrder: priceAtTimeOfOrder,
                routeTo: routeTo,
                notes: notes,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$OrderItemsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                orderId = false,
                productId = false,
                orderItemModifiersRefs = false,
                orderItemSidesRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (orderItemModifiersRefs) db.orderItemModifiers,
                    if (orderItemSidesRefs) db.orderItemSides,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (orderId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.orderId,
                                    referencedTable: $$OrderItemsTableReferences
                                        ._orderIdTable(db),
                                    referencedColumn:
                                        $$OrderItemsTableReferences
                                            ._orderIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (productId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.productId,
                                    referencedTable: $$OrderItemsTableReferences
                                        ._productIdTable(db),
                                    referencedColumn:
                                        $$OrderItemsTableReferences
                                            ._productIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (orderItemModifiersRefs)
                        await $_getPrefetchedData<
                          OrderItem,
                          $OrderItemsTable,
                          OrderItemModifier
                        >(
                          currentTable: table,
                          referencedTable: $$OrderItemsTableReferences
                              ._orderItemModifiersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$OrderItemsTableReferences(
                                db,
                                table,
                                p0,
                              ).orderItemModifiersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.orderItemId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (orderItemSidesRefs)
                        await $_getPrefetchedData<
                          OrderItem,
                          $OrderItemsTable,
                          OrderItemSide
                        >(
                          currentTable: table,
                          referencedTable: $$OrderItemsTableReferences
                              ._orderItemSidesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$OrderItemsTableReferences(
                                db,
                                table,
                                p0,
                              ).orderItemSidesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.orderItemId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$OrderItemsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OrderItemsTable,
      OrderItem,
      $$OrderItemsTableFilterComposer,
      $$OrderItemsTableOrderingComposer,
      $$OrderItemsTableAnnotationComposer,
      $$OrderItemsTableCreateCompanionBuilder,
      $$OrderItemsTableUpdateCompanionBuilder,
      (OrderItem, $$OrderItemsTableReferences),
      OrderItem,
      PrefetchHooks Function({
        bool orderId,
        bool productId,
        bool orderItemModifiersRefs,
        bool orderItemSidesRefs,
      })
    >;
typedef $$OrderItemModifiersTableCreateCompanionBuilder =
    OrderItemModifiersCompanion Function({
      required String id,
      required String orderItemId,
      required String name,
      Value<double> priceDelta,
      Value<String?> routeTo,
      Value<int> rowid,
    });
typedef $$OrderItemModifiersTableUpdateCompanionBuilder =
    OrderItemModifiersCompanion Function({
      Value<String> id,
      Value<String> orderItemId,
      Value<String> name,
      Value<double> priceDelta,
      Value<String?> routeTo,
      Value<int> rowid,
    });

final class $$OrderItemModifiersTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $OrderItemModifiersTable,
          OrderItemModifier
        > {
  $$OrderItemModifiersTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $OrderItemsTable _orderItemIdTable(_$AppDatabase db) =>
      db.orderItems.createAlias(
        $_aliasNameGenerator(
          db.orderItemModifiers.orderItemId,
          db.orderItems.id,
        ),
      );

  $$OrderItemsTableProcessedTableManager get orderItemId {
    final $_column = $_itemColumn<String>('order_item_id')!;

    final manager = $$OrderItemsTableTableManager(
      $_db,
      $_db.orderItems,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orderItemIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$OrderItemModifiersTableFilterComposer
    extends Composer<_$AppDatabase, $OrderItemModifiersTable> {
  $$OrderItemModifiersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get priceDelta => $composableBuilder(
    column: $table.priceDelta,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get routeTo => $composableBuilder(
    column: $table.routeTo,
    builder: (column) => ColumnFilters(column),
  );

  $$OrderItemsTableFilterComposer get orderItemId {
    final $$OrderItemsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderItemId,
      referencedTable: $db.orderItems,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemsTableFilterComposer(
            $db: $db,
            $table: $db.orderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OrderItemModifiersTableOrderingComposer
    extends Composer<_$AppDatabase, $OrderItemModifiersTable> {
  $$OrderItemModifiersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get priceDelta => $composableBuilder(
    column: $table.priceDelta,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get routeTo => $composableBuilder(
    column: $table.routeTo,
    builder: (column) => ColumnOrderings(column),
  );

  $$OrderItemsTableOrderingComposer get orderItemId {
    final $$OrderItemsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderItemId,
      referencedTable: $db.orderItems,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemsTableOrderingComposer(
            $db: $db,
            $table: $db.orderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OrderItemModifiersTableAnnotationComposer
    extends Composer<_$AppDatabase, $OrderItemModifiersTable> {
  $$OrderItemModifiersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<double> get priceDelta => $composableBuilder(
    column: $table.priceDelta,
    builder: (column) => column,
  );

  GeneratedColumn<String> get routeTo =>
      $composableBuilder(column: $table.routeTo, builder: (column) => column);

  $$OrderItemsTableAnnotationComposer get orderItemId {
    final $$OrderItemsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderItemId,
      referencedTable: $db.orderItems,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemsTableAnnotationComposer(
            $db: $db,
            $table: $db.orderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OrderItemModifiersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OrderItemModifiersTable,
          OrderItemModifier,
          $$OrderItemModifiersTableFilterComposer,
          $$OrderItemModifiersTableOrderingComposer,
          $$OrderItemModifiersTableAnnotationComposer,
          $$OrderItemModifiersTableCreateCompanionBuilder,
          $$OrderItemModifiersTableUpdateCompanionBuilder,
          (OrderItemModifier, $$OrderItemModifiersTableReferences),
          OrderItemModifier,
          PrefetchHooks Function({bool orderItemId})
        > {
  $$OrderItemModifiersTableTableManager(
    _$AppDatabase db,
    $OrderItemModifiersTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OrderItemModifiersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OrderItemModifiersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OrderItemModifiersTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> orderItemId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<double> priceDelta = const Value.absent(),
                Value<String?> routeTo = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OrderItemModifiersCompanion(
                id: id,
                orderItemId: orderItemId,
                name: name,
                priceDelta: priceDelta,
                routeTo: routeTo,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String orderItemId,
                required String name,
                Value<double> priceDelta = const Value.absent(),
                Value<String?> routeTo = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OrderItemModifiersCompanion.insert(
                id: id,
                orderItemId: orderItemId,
                name: name,
                priceDelta: priceDelta,
                routeTo: routeTo,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$OrderItemModifiersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({orderItemId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (orderItemId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.orderItemId,
                                referencedTable:
                                    $$OrderItemModifiersTableReferences
                                        ._orderItemIdTable(db),
                                referencedColumn:
                                    $$OrderItemModifiersTableReferences
                                        ._orderItemIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$OrderItemModifiersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OrderItemModifiersTable,
      OrderItemModifier,
      $$OrderItemModifiersTableFilterComposer,
      $$OrderItemModifiersTableOrderingComposer,
      $$OrderItemModifiersTableAnnotationComposer,
      $$OrderItemModifiersTableCreateCompanionBuilder,
      $$OrderItemModifiersTableUpdateCompanionBuilder,
      (OrderItemModifier, $$OrderItemModifiersTableReferences),
      OrderItemModifier,
      PrefetchHooks Function({bool orderItemId})
    >;
typedef $$OrderItemSidesTableCreateCompanionBuilder =
    OrderItemSidesCompanion Function({
      required String id,
      required String orderItemId,
      required String name,
      Value<int> quantity,
      Value<double> priceDelta,
      Value<String?> routeTo,
      Value<int> rowid,
    });
typedef $$OrderItemSidesTableUpdateCompanionBuilder =
    OrderItemSidesCompanion Function({
      Value<String> id,
      Value<String> orderItemId,
      Value<String> name,
      Value<int> quantity,
      Value<double> priceDelta,
      Value<String?> routeTo,
      Value<int> rowid,
    });

final class $$OrderItemSidesTableReferences
    extends BaseReferences<_$AppDatabase, $OrderItemSidesTable, OrderItemSide> {
  $$OrderItemSidesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $OrderItemsTable _orderItemIdTable(_$AppDatabase db) =>
      db.orderItems.createAlias(
        $_aliasNameGenerator(db.orderItemSides.orderItemId, db.orderItems.id),
      );

  $$OrderItemsTableProcessedTableManager get orderItemId {
    final $_column = $_itemColumn<String>('order_item_id')!;

    final manager = $$OrderItemsTableTableManager(
      $_db,
      $_db.orderItems,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orderItemIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$OrderItemSidesTableFilterComposer
    extends Composer<_$AppDatabase, $OrderItemSidesTable> {
  $$OrderItemSidesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get priceDelta => $composableBuilder(
    column: $table.priceDelta,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get routeTo => $composableBuilder(
    column: $table.routeTo,
    builder: (column) => ColumnFilters(column),
  );

  $$OrderItemsTableFilterComposer get orderItemId {
    final $$OrderItemsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderItemId,
      referencedTable: $db.orderItems,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemsTableFilterComposer(
            $db: $db,
            $table: $db.orderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OrderItemSidesTableOrderingComposer
    extends Composer<_$AppDatabase, $OrderItemSidesTable> {
  $$OrderItemSidesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get priceDelta => $composableBuilder(
    column: $table.priceDelta,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get routeTo => $composableBuilder(
    column: $table.routeTo,
    builder: (column) => ColumnOrderings(column),
  );

  $$OrderItemsTableOrderingComposer get orderItemId {
    final $$OrderItemsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderItemId,
      referencedTable: $db.orderItems,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemsTableOrderingComposer(
            $db: $db,
            $table: $db.orderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OrderItemSidesTableAnnotationComposer
    extends Composer<_$AppDatabase, $OrderItemSidesTable> {
  $$OrderItemSidesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<double> get priceDelta => $composableBuilder(
    column: $table.priceDelta,
    builder: (column) => column,
  );

  GeneratedColumn<String> get routeTo =>
      $composableBuilder(column: $table.routeTo, builder: (column) => column);

  $$OrderItemsTableAnnotationComposer get orderItemId {
    final $$OrderItemsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderItemId,
      referencedTable: $db.orderItems,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrderItemsTableAnnotationComposer(
            $db: $db,
            $table: $db.orderItems,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$OrderItemSidesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OrderItemSidesTable,
          OrderItemSide,
          $$OrderItemSidesTableFilterComposer,
          $$OrderItemSidesTableOrderingComposer,
          $$OrderItemSidesTableAnnotationComposer,
          $$OrderItemSidesTableCreateCompanionBuilder,
          $$OrderItemSidesTableUpdateCompanionBuilder,
          (OrderItemSide, $$OrderItemSidesTableReferences),
          OrderItemSide,
          PrefetchHooks Function({bool orderItemId})
        > {
  $$OrderItemSidesTableTableManager(
    _$AppDatabase db,
    $OrderItemSidesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OrderItemSidesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OrderItemSidesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OrderItemSidesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> orderItemId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<int> quantity = const Value.absent(),
                Value<double> priceDelta = const Value.absent(),
                Value<String?> routeTo = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OrderItemSidesCompanion(
                id: id,
                orderItemId: orderItemId,
                name: name,
                quantity: quantity,
                priceDelta: priceDelta,
                routeTo: routeTo,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String orderItemId,
                required String name,
                Value<int> quantity = const Value.absent(),
                Value<double> priceDelta = const Value.absent(),
                Value<String?> routeTo = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OrderItemSidesCompanion.insert(
                id: id,
                orderItemId: orderItemId,
                name: name,
                quantity: quantity,
                priceDelta: priceDelta,
                routeTo: routeTo,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$OrderItemSidesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({orderItemId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (orderItemId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.orderItemId,
                                referencedTable: $$OrderItemSidesTableReferences
                                    ._orderItemIdTable(db),
                                referencedColumn:
                                    $$OrderItemSidesTableReferences
                                        ._orderItemIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$OrderItemSidesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OrderItemSidesTable,
      OrderItemSide,
      $$OrderItemSidesTableFilterComposer,
      $$OrderItemSidesTableOrderingComposer,
      $$OrderItemSidesTableAnnotationComposer,
      $$OrderItemSidesTableCreateCompanionBuilder,
      $$OrderItemSidesTableUpdateCompanionBuilder,
      (OrderItemSide, $$OrderItemSidesTableReferences),
      OrderItemSide,
      PrefetchHooks Function({bool orderItemId})
    >;
typedef $$PaymentsTableCreateCompanionBuilder =
    PaymentsCompanion Function({
      required String id,
      Value<String> branchId,
      required String orderId,
      required String shiftId,
      required String method,
      required double amount,
      Value<String?> reference,
      required DateTime createdAt,
      Value<int> rowid,
    });
typedef $$PaymentsTableUpdateCompanionBuilder =
    PaymentsCompanion Function({
      Value<String> id,
      Value<String> branchId,
      Value<String> orderId,
      Value<String> shiftId,
      Value<String> method,
      Value<double> amount,
      Value<String?> reference,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$PaymentsTableReferences
    extends BaseReferences<_$AppDatabase, $PaymentsTable, Payment> {
  $$PaymentsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $OrdersTable _orderIdTable(_$AppDatabase db) => db.orders.createAlias(
    $_aliasNameGenerator(db.payments.orderId, db.orders.id),
  );

  $$OrdersTableProcessedTableManager get orderId {
    final $_column = $_itemColumn<String>('order_id')!;

    final manager = $$OrdersTableTableManager(
      $_db,
      $_db.orders,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orderIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ShiftsTable _shiftIdTable(_$AppDatabase db) => db.shifts.createAlias(
    $_aliasNameGenerator(db.payments.shiftId, db.shifts.id),
  );

  $$ShiftsTableProcessedTableManager get shiftId {
    final $_column = $_itemColumn<String>('shift_id')!;

    final manager = $$ShiftsTableTableManager(
      $_db,
      $_db.shifts,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_shiftIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$PaymentsTableFilterComposer
    extends Composer<_$AppDatabase, $PaymentsTable> {
  $$PaymentsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get branchId => $composableBuilder(
    column: $table.branchId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get method => $composableBuilder(
    column: $table.method,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reference => $composableBuilder(
    column: $table.reference,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$OrdersTableFilterComposer get orderId {
    final $$OrdersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.orders,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrdersTableFilterComposer(
            $db: $db,
            $table: $db.orders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShiftsTableFilterComposer get shiftId {
    final $$ShiftsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shiftId,
      referencedTable: $db.shifts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShiftsTableFilterComposer(
            $db: $db,
            $table: $db.shifts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PaymentsTableOrderingComposer
    extends Composer<_$AppDatabase, $PaymentsTable> {
  $$PaymentsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get branchId => $composableBuilder(
    column: $table.branchId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get method => $composableBuilder(
    column: $table.method,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reference => $composableBuilder(
    column: $table.reference,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$OrdersTableOrderingComposer get orderId {
    final $$OrdersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.orders,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrdersTableOrderingComposer(
            $db: $db,
            $table: $db.orders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShiftsTableOrderingComposer get shiftId {
    final $$ShiftsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shiftId,
      referencedTable: $db.shifts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShiftsTableOrderingComposer(
            $db: $db,
            $table: $db.shifts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PaymentsTableAnnotationComposer
    extends Composer<_$AppDatabase, $PaymentsTable> {
  $$PaymentsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get branchId =>
      $composableBuilder(column: $table.branchId, builder: (column) => column);

  GeneratedColumn<String> get method =>
      $composableBuilder(column: $table.method, builder: (column) => column);

  GeneratedColumn<double> get amount =>
      $composableBuilder(column: $table.amount, builder: (column) => column);

  GeneratedColumn<String> get reference =>
      $composableBuilder(column: $table.reference, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$OrdersTableAnnotationComposer get orderId {
    final $$OrdersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.orderId,
      referencedTable: $db.orders,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$OrdersTableAnnotationComposer(
            $db: $db,
            $table: $db.orders,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ShiftsTableAnnotationComposer get shiftId {
    final $$ShiftsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.shiftId,
      referencedTable: $db.shifts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ShiftsTableAnnotationComposer(
            $db: $db,
            $table: $db.shifts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$PaymentsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PaymentsTable,
          Payment,
          $$PaymentsTableFilterComposer,
          $$PaymentsTableOrderingComposer,
          $$PaymentsTableAnnotationComposer,
          $$PaymentsTableCreateCompanionBuilder,
          $$PaymentsTableUpdateCompanionBuilder,
          (Payment, $$PaymentsTableReferences),
          Payment,
          PrefetchHooks Function({bool orderId, bool shiftId})
        > {
  $$PaymentsTableTableManager(_$AppDatabase db, $PaymentsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PaymentsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PaymentsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PaymentsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> branchId = const Value.absent(),
                Value<String> orderId = const Value.absent(),
                Value<String> shiftId = const Value.absent(),
                Value<String> method = const Value.absent(),
                Value<double> amount = const Value.absent(),
                Value<String?> reference = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PaymentsCompanion(
                id: id,
                branchId: branchId,
                orderId: orderId,
                shiftId: shiftId,
                method: method,
                amount: amount,
                reference: reference,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String> branchId = const Value.absent(),
                required String orderId,
                required String shiftId,
                required String method,
                required double amount,
                Value<String?> reference = const Value.absent(),
                required DateTime createdAt,
                Value<int> rowid = const Value.absent(),
              }) => PaymentsCompanion.insert(
                id: id,
                branchId: branchId,
                orderId: orderId,
                shiftId: shiftId,
                method: method,
                amount: amount,
                reference: reference,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$PaymentsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({orderId = false, shiftId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (orderId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.orderId,
                                referencedTable: $$PaymentsTableReferences
                                    ._orderIdTable(db),
                                referencedColumn: $$PaymentsTableReferences
                                    ._orderIdTable(db)
                                    .id,
                              )
                              as T;
                    }
                    if (shiftId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.shiftId,
                                referencedTable: $$PaymentsTableReferences
                                    ._shiftIdTable(db),
                                referencedColumn: $$PaymentsTableReferences
                                    ._shiftIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$PaymentsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PaymentsTable,
      Payment,
      $$PaymentsTableFilterComposer,
      $$PaymentsTableOrderingComposer,
      $$PaymentsTableAnnotationComposer,
      $$PaymentsTableCreateCompanionBuilder,
      $$PaymentsTableUpdateCompanionBuilder,
      (Payment, $$PaymentsTableReferences),
      Payment,
      PrefetchHooks Function({bool orderId, bool shiftId})
    >;
typedef $$SeatingTablesTableCreateCompanionBuilder =
    SeatingTablesCompanion Function({
      required String id,
      Value<String> branchId,
      required String name,
      Value<String> status,
      Value<String> floor,
      Value<DateTime?> updatedAt,
      Value<bool> isSynced,
      Value<int> rowid,
    });
typedef $$SeatingTablesTableUpdateCompanionBuilder =
    SeatingTablesCompanion Function({
      Value<String> id,
      Value<String> branchId,
      Value<String> name,
      Value<String> status,
      Value<String> floor,
      Value<DateTime?> updatedAt,
      Value<bool> isSynced,
      Value<int> rowid,
    });

class $$SeatingTablesTableFilterComposer
    extends Composer<_$AppDatabase, $SeatingTablesTable> {
  $$SeatingTablesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get branchId => $composableBuilder(
    column: $table.branchId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get floor => $composableBuilder(
    column: $table.floor,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SeatingTablesTableOrderingComposer
    extends Composer<_$AppDatabase, $SeatingTablesTable> {
  $$SeatingTablesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get branchId => $composableBuilder(
    column: $table.branchId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get floor => $composableBuilder(
    column: $table.floor,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SeatingTablesTableAnnotationComposer
    extends Composer<_$AppDatabase, $SeatingTablesTable> {
  $$SeatingTablesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get branchId =>
      $composableBuilder(column: $table.branchId, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get floor =>
      $composableBuilder(column: $table.floor, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);
}

class $$SeatingTablesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SeatingTablesTable,
          SeatingTable,
          $$SeatingTablesTableFilterComposer,
          $$SeatingTablesTableOrderingComposer,
          $$SeatingTablesTableAnnotationComposer,
          $$SeatingTablesTableCreateCompanionBuilder,
          $$SeatingTablesTableUpdateCompanionBuilder,
          (
            SeatingTable,
            BaseReferences<_$AppDatabase, $SeatingTablesTable, SeatingTable>,
          ),
          SeatingTable,
          PrefetchHooks Function()
        > {
  $$SeatingTablesTableTableManager(_$AppDatabase db, $SeatingTablesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SeatingTablesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SeatingTablesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SeatingTablesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> branchId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String> floor = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<bool> isSynced = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SeatingTablesCompanion(
                id: id,
                branchId: branchId,
                name: name,
                status: status,
                floor: floor,
                updatedAt: updatedAt,
                isSynced: isSynced,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String> branchId = const Value.absent(),
                required String name,
                Value<String> status = const Value.absent(),
                Value<String> floor = const Value.absent(),
                Value<DateTime?> updatedAt = const Value.absent(),
                Value<bool> isSynced = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SeatingTablesCompanion.insert(
                id: id,
                branchId: branchId,
                name: name,
                status: status,
                floor: floor,
                updatedAt: updatedAt,
                isSynced: isSynced,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SeatingTablesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SeatingTablesTable,
      SeatingTable,
      $$SeatingTablesTableFilterComposer,
      $$SeatingTablesTableOrderingComposer,
      $$SeatingTablesTableAnnotationComposer,
      $$SeatingTablesTableCreateCompanionBuilder,
      $$SeatingTablesTableUpdateCompanionBuilder,
      (
        SeatingTable,
        BaseReferences<_$AppDatabase, $SeatingTablesTable, SeatingTable>,
      ),
      SeatingTable,
      PrefetchHooks Function()
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$CategoriesTableTableManager get categories =>
      $$CategoriesTableTableManager(_db, _db.categories);
  $$ProductsTableTableManager get products =>
      $$ProductsTableTableManager(_db, _db.products);
  $$ShiftsTableTableManager get shifts =>
      $$ShiftsTableTableManager(_db, _db.shifts);
  $$OrdersTableTableManager get orders =>
      $$OrdersTableTableManager(_db, _db.orders);
  $$OrderItemsTableTableManager get orderItems =>
      $$OrderItemsTableTableManager(_db, _db.orderItems);
  $$OrderItemModifiersTableTableManager get orderItemModifiers =>
      $$OrderItemModifiersTableTableManager(_db, _db.orderItemModifiers);
  $$OrderItemSidesTableTableManager get orderItemSides =>
      $$OrderItemSidesTableTableManager(_db, _db.orderItemSides);
  $$PaymentsTableTableManager get payments =>
      $$PaymentsTableTableManager(_db, _db.payments);
  $$SeatingTablesTableTableManager get seatingTables =>
      $$SeatingTablesTableTableManager(_db, _db.seatingTables);
}

================
File: qristal_mobile/pubspec.lock
================
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  _fe_analyzer_shared:
    dependency: transitive
    description:
      name: _fe_analyzer_shared
      sha256: "8d7ff3948166b8ec5da0fbb5962000926b8e02f2ed9b3e51d1738905fbd4c98d"
      url: "https://pub.dev"
    source: hosted
    version: "93.0.0"
  analyzer:
    dependency: transitive
    description:
      name: analyzer
      sha256: de7148ed2fcec579b19f122c1800933dfa028f6d9fd38a152b04b1516cec120b
      url: "https://pub.dev"
    source: hosted
    version: "10.0.1"
  ansicolor:
    dependency: transitive
    description:
      name: ansicolor
      sha256: "50e982d500bc863e1d703448afdbf9e5a72eb48840a4f766fa361ffd6877055f"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.3"
  archive:
    dependency: transitive
    description:
      name: archive
      sha256: a96e8b390886ee8abb49b7bd3ac8df6f451c621619f52a26e815fdcf568959ff
      url: "https://pub.dev"
    source: hosted
    version: "4.0.9"
  args:
    dependency: transitive
    description:
      name: args
      sha256: d0481093c50b1da8910eb0bb301626d4d8eb7284aa739614d2b394ee09e3ea04
      url: "https://pub.dev"
    source: hosted
    version: "2.7.0"
  async:
    dependency: transitive
    description:
      name: async
      sha256: "758e6d74e971c3e5aceb4110bfd6698efc7f501675bcfe0c775459a8140750eb"
      url: "https://pub.dev"
    source: hosted
    version: "2.13.0"
  barcode:
    dependency: transitive
    description:
      name: barcode
      sha256: "7b6729c37e3b7f34233e2318d866e8c48ddb46c1f7ad01ff7bb2a8de1da2b9f4"
      url: "https://pub.dev"
    source: hosted
    version: "2.2.9"
  bidi:
    dependency: transitive
    description:
      name: bidi
      sha256: "77f475165e94b261745cf1032c751e2032b8ed92ccb2bf5716036db79320637d"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.13"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      sha256: "8aab1771e1243a5063b8b0ff68042d67334e3feab9e95b9490f9a6ebf73b42ea"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  build:
    dependency: transitive
    description:
      name: build
      sha256: "275bf6bb2a00a9852c28d4e0b410da1d833a734d57d39d44f94bfc895a484ec3"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.4"
  build_config:
    dependency: transitive
    description:
      name: build_config
      sha256: "4f64382b97504dc2fcdf487d5aae33418e08b4703fc21249e4db6d804a4d0187"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.0"
  build_daemon:
    dependency: transitive
    description:
      name: build_daemon
      sha256: bf05f6e12cfea92d3c09308d7bcdab1906cd8a179b023269eed00c071004b957
      url: "https://pub.dev"
    source: hosted
    version: "4.1.1"
  build_runner:
    dependency: "direct dev"
    description:
      name: build_runner
      sha256: "39ad4ca8a2876779737c60e4228b4bcd35d4352ef7e14e47514093edc012c734"
      url: "https://pub.dev"
    source: hosted
    version: "2.11.1"
  built_collection:
    dependency: transitive
    description:
      name: built_collection
      sha256: "376e3dd27b51ea877c28d525560790aee2e6fbb5f20e2f85d5081027d94e2100"
      url: "https://pub.dev"
    source: hosted
    version: "5.1.1"
  built_value:
    dependency: transitive
    description:
      name: built_value
      sha256: "6ae8a6435a8c6520c7077b107e77f1fb4ba7009633259a4d49a8afd8e7efc5e9"
      url: "https://pub.dev"
    source: hosted
    version: "8.12.4"
  characters:
    dependency: transitive
    description:
      name: characters
      sha256: f71061c654a3380576a52b451dd5532377954cf9dbd272a78fc8479606670803
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  charcode:
    dependency: transitive
    description:
      name: charcode
      sha256: fb0f1107cac15a5ea6ef0a6ef71a807b9e4267c713bb93e00e92d737cc8dbd8a
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  checked_yaml:
    dependency: transitive
    description:
      name: checked_yaml
      sha256: "959525d3162f249993882720d52b7e0c833978df229be20702b33d48d91de70f"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.4"
  cli_util:
    dependency: transitive
    description:
      name: cli_util
      sha256: ff6785f7e9e3c38ac98b2fb035701789de90154024a75b6cb926445e83197d1c
      url: "https://pub.dev"
    source: hosted
    version: "0.4.2"
  clock:
    dependency: transitive
    description:
      name: clock
      sha256: fddb70d9b5277016c77a80201021d40a2247104d9f4aa7bab7157b7e3f05b84b
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  code_builder:
    dependency: transitive
    description:
      name: code_builder
      sha256: "6a6cab2ba4680d6423f34a9b972a4c9a94ebe1b62ecec4e1a1f2cba91fd1319d"
      url: "https://pub.dev"
    source: hosted
    version: "4.11.1"
  collection:
    dependency: transitive
    description:
      name: collection
      sha256: "2f5709ae4d3d59dd8f7cd309b4e023046b57d8a6c82130785d2b0e5868084e76"
      url: "https://pub.dev"
    source: hosted
    version: "1.19.1"
  connectivity_plus:
    dependency: "direct main"
    description:
      name: connectivity_plus
      sha256: "33bae12a398f841c6cda09d1064212957265869104c478e5ad51e2fb26c3973c"
      url: "https://pub.dev"
    source: hosted
    version: "7.0.0"
  connectivity_plus_platform_interface:
    dependency: transitive
    description:
      name: connectivity_plus_platform_interface
      sha256: "42657c1715d48b167930d5f34d00222ac100475f73d10162ddf43e714932f204"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.1"
  convert:
    dependency: transitive
    description:
      name: convert
      sha256: b30acd5944035672bc15c6b7a8b47d773e41e2f17de064350988c5d02adb1c68
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
  crypto:
    dependency: transitive
    description:
      name: crypto
      sha256: c8ea0233063ba03258fbcf2ca4d6dadfefe14f02fab57702265467a19f27fadf
      url: "https://pub.dev"
    source: hosted
    version: "3.0.7"
  csslib:
    dependency: transitive
    description:
      name: csslib
      sha256: "09bad715f418841f976c77db72d5398dc1253c21fb9c0c7f0b0b985860b2d58e"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.2"
  cupertino_icons:
    dependency: "direct main"
    description:
      name: cupertino_icons
      sha256: ba631d1c7f7bef6b729a622b7b752645a2d076dba9976925b8f25725a30e1ee6
      url: "https://pub.dev"
    source: hosted
    version: "1.0.8"
  dart_style:
    dependency: transitive
    description:
      name: dart_style
      sha256: "15a7db352c8fc6a4d2bc475ba901c25b39fe7157541da4c16eacce6f8be83e49"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.5"
  dbus:
    dependency: transitive
    description:
      name: dbus
      sha256: d0c98dcd4f5169878b6cf8f6e0a52403a9dff371a3e2f019697accbf6f44a270
      url: "https://pub.dev"
    source: hosted
    version: "0.7.12"
  drift:
    dependency: "direct main"
    description:
      name: drift
      sha256: "970cd188fddb111b26ea6a9b07a62bf5c2432d74147b8122c67044ae3b97e99e"
      url: "https://pub.dev"
    source: hosted
    version: "2.31.0"
  drift_dev:
    dependency: "direct dev"
    description:
      name: drift_dev
      sha256: "917184b2fb867b70a548a83bf0d36268423b38d39968c06cce4905683da49587"
      url: "https://pub.dev"
    source: hosted
    version: "2.31.0"
  esc_pos_utils_plus:
    dependency: "direct main"
    description:
      name: esc_pos_utils_plus
      sha256: "2a22d281cb6f04600ba3ebd607ad8df03a4b2446d814007d22525bab4d50c2ff"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.4"
  fake_async:
    dependency: transitive
    description:
      name: fake_async
      sha256: "5368f224a74523e8d2e7399ea1638b37aecfca824a3cc4dfdf77bf1fa905ac44"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.3"
  ffi:
    dependency: transitive
    description:
      name: ffi
      sha256: "6d7fd89431262d8f3125e81b50d3847a091d846eafcd4fdb88dd06f36d705a45"
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  file:
    dependency: transitive
    description:
      name: file
      sha256: a3b4f84adafef897088c160faf7dfffb7696046cb13ae90b508c2cbc95d3b8d4
      url: "https://pub.dev"
    source: hosted
    version: "7.0.1"
  fixnum:
    dependency: transitive
    description:
      name: fixnum
      sha256: b6dc7065e46c974bc7c5f143080a6764ec7a4be6da1285ececdc37be96de53be
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  flutter:
    dependency: "direct main"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_lints:
    dependency: "direct dev"
    description:
      name: flutter_lints
      sha256: "5398f14efa795ffb7a33e9b6a08798b26a180edac4ad7db3f231e40f82ce11e1"
      url: "https://pub.dev"
    source: hosted
    version: "5.0.0"
  flutter_riverpod:
    dependency: "direct main"
    description:
      name: flutter_riverpod
      sha256: "9532ee6db4a943a1ed8383072a2e3eeda041db5657cdf6d2acecf3c21ecbe7e1"
      url: "https://pub.dev"
    source: hosted
    version: "2.6.1"
  flutter_secure_storage:
    dependency: "direct main"
    description:
      name: flutter_secure_storage
      sha256: da922f2aab2d733db7e011a6bcc4a825b844892d4edd6df83ff156b09a9b2e40
      url: "https://pub.dev"
    source: hosted
    version: "10.0.0"
  flutter_secure_storage_darwin:
    dependency: transitive
    description:
      name: flutter_secure_storage_darwin
      sha256: "8878c25136a79def1668c75985e8e193d9d7d095453ec28730da0315dc69aee3"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.0"
  flutter_secure_storage_linux:
    dependency: transitive
    description:
      name: flutter_secure_storage_linux
      sha256: "2b5c76dce569ab752d55a1cee6a2242bcc11fdba927078fb88c503f150767cda"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.0"
  flutter_secure_storage_platform_interface:
    dependency: transitive
    description:
      name: flutter_secure_storage_platform_interface
      sha256: "8ceea1223bee3c6ac1a22dabd8feefc550e4729b3675de4b5900f55afcb435d6"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.1"
  flutter_secure_storage_web:
    dependency: transitive
    description:
      name: flutter_secure_storage_web
      sha256: "6a1137df62b84b54261dca582c1c09ea72f4f9a4b2fcee21b025964132d5d0c3"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.0"
  flutter_secure_storage_windows:
    dependency: transitive
    description:
      name: flutter_secure_storage_windows
      sha256: "3b7c8e068875dfd46719ff57c90d8c459c87f2302ed6b00ff006b3c9fcad1613"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.0"
  flutter_test:
    dependency: "direct dev"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_web_plugins:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  glob:
    dependency: transitive
    description:
      name: glob
      sha256: c3f1ee72c96f8f78935e18aa8cecced9ab132419e8625dc187e1c2408efc20de
      url: "https://pub.dev"
    source: hosted
    version: "2.1.3"
  globbing:
    dependency: transitive
    description:
      name: globbing
      sha256: "4f89cfaf6fa74c9c1740a96259da06bd45411ede56744e28017cc534a12b6e2d"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  graphs:
    dependency: transitive
    description:
      name: graphs
      sha256: "741bbf84165310a68ff28fe9e727332eef1407342fca52759cb21ad8177bb8d0"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.2"
  html:
    dependency: transitive
    description:
      name: html
      sha256: "6d1264f2dffa1b1101c25a91dff0dc2daee4c18e87cd8538729773c073dbf602"
      url: "https://pub.dev"
    source: hosted
    version: "0.15.6"
  http:
    dependency: "direct main"
    description:
      name: http
      sha256: "87721a4a50b19c7f1d49001e51409bddc46303966ce89a65af4f4e6004896412"
      url: "https://pub.dev"
    source: hosted
    version: "1.6.0"
  http_multi_server:
    dependency: transitive
    description:
      name: http_multi_server
      sha256: aa6199f908078bb1c5efb8d8638d4ae191aac11b311132c3ef48ce352fb52ef8
      url: "https://pub.dev"
    source: hosted
    version: "3.2.2"
  http_parser:
    dependency: transitive
    description:
      name: http_parser
      sha256: "178d74305e7866013777bab2c3d8726205dc5a4dd935297175b19a23a2e66571"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.2"
  image:
    dependency: transitive
    description:
      name: image
      sha256: "4e973fcf4caae1a4be2fa0a13157aa38a8f9cb049db6529aa00b4d71abc4d928"
      url: "https://pub.dev"
    source: hosted
    version: "4.5.4"
  injector:
    dependency: transitive
    description:
      name: injector
      sha256: ed389bed5b48a699d5b9561c985023d0d5cc88dd5ff2237aadcce5a5ab433e4e
      url: "https://pub.dev"
    source: hosted
    version: "3.0.0"
  intl:
    dependency: "direct main"
    description:
      name: intl
      sha256: "3df61194eb431efc39c4ceba583b95633a403f46c9fd341e550ce0bfa50e9aa5"
      url: "https://pub.dev"
    source: hosted
    version: "0.20.2"
  io:
    dependency: transitive
    description:
      name: io
      sha256: dfd5a80599cf0165756e3181807ed3e77daf6dd4137caaad72d0b7931597650b
      url: "https://pub.dev"
    source: hosted
    version: "1.0.5"
  jni:
    dependency: transitive
    description:
      name: jni
      sha256: d2c361082d554d4593c3012e26f6b188f902acd291330f13d6427641a92b3da1
      url: "https://pub.dev"
    source: hosted
    version: "0.14.2"
  json_annotation:
    dependency: transitive
    description:
      name: json_annotation
      sha256: cb09e7dac6210041fad964ed7fbee004f14258b4eca4040f72d1234062ace4c8
      url: "https://pub.dev"
    source: hosted
    version: "4.11.0"
  json_serializable:
    dependency: "direct dev"
    description:
      name: json_serializable
      sha256: "44729f5c45748e6748f6b9a57ab8f7e4336edc8ae41fc295070e3814e616a6c0"
      url: "https://pub.dev"
    source: hosted
    version: "6.13.0"
  leak_tracker:
    dependency: transitive
    description:
      name: leak_tracker
      sha256: "33e2e26bdd85a0112ec15400c8cbffea70d0f9c3407491f672a2fad47915e2de"
      url: "https://pub.dev"
    source: hosted
    version: "11.0.2"
  leak_tracker_flutter_testing:
    dependency: transitive
    description:
      name: leak_tracker_flutter_testing
      sha256: "1dbc140bb5a23c75ea9c4811222756104fbcd1a27173f0c34ca01e16bea473c1"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.10"
  leak_tracker_testing:
    dependency: transitive
    description:
      name: leak_tracker_testing
      sha256: "8d5a2d49f4a66b49744b23b018848400d23e54caf9463f4eb20df3eb8acb2eb1"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.2"
  lints:
    dependency: transitive
    description:
      name: lints
      sha256: c35bb79562d980e9a453fc715854e1ed39e24e7d0297a880ef54e17f9874a9d7
      url: "https://pub.dev"
    source: hosted
    version: "5.1.1"
  logging:
    dependency: transitive
    description:
      name: logging
      sha256: c8245ada5f1717ed44271ed1c26b8ce85ca3228fd2ffdb75468ab01979309d61
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  matcher:
    dependency: transitive
    description:
      name: matcher
      sha256: dc58c723c3c24bf8d3e2d3ad3f2f9d7bd9cf43ec6feaa64181775e60190153f2
      url: "https://pub.dev"
    source: hosted
    version: "0.12.17"
  material_color_utilities:
    dependency: transitive
    description:
      name: material_color_utilities
      sha256: f7142bb1154231d7ea5f96bc7bde4bda2a0945d2806bb11670e30b850d56bdec
      url: "https://pub.dev"
    source: hosted
    version: "0.11.1"
  meta:
    dependency: transitive
    description:
      name: meta
      sha256: "23f08335362185a5ea2ad3a4e597f1375e78bce8a040df5c600c8d3552ef2394"
      url: "https://pub.dev"
    source: hosted
    version: "1.17.0"
  mime:
    dependency: transitive
    description:
      name: mime
      sha256: "41a20518f0cb1256669420fdba0cd90d21561e560ac240f26ef8322e45bb7ed6"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
  nm:
    dependency: transitive
    description:
      name: nm
      sha256: "2c9aae4127bdc8993206464fcc063611e0e36e72018696cd9631023a31b24254"
      url: "https://pub.dev"
    source: hosted
    version: "0.5.0"
  package_config:
    dependency: transitive
    description:
      name: package_config
      sha256: f096c55ebb7deb7e384101542bfba8c52696c1b56fca2eb62827989ef2353bbc
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  package_info_plus:
    dependency: transitive
    description:
      name: package_info_plus
      sha256: f69da0d3189a4b4ceaeb1a3defb0f329b3b352517f52bed4290f83d4f06bc08d
      url: "https://pub.dev"
    source: hosted
    version: "9.0.0"
  package_info_plus_platform_interface:
    dependency: transitive
    description:
      name: package_info_plus_platform_interface
      sha256: "202a487f08836a592a6bd4f901ac69b3a8f146af552bbd14407b6b41e1c3f086"
      url: "https://pub.dev"
    source: hosted
    version: "3.2.1"
  path:
    dependency: "direct main"
    description:
      name: path
      sha256: "75cca69d1490965be98c73ceaea117e8a04dd21217b37b292c9ddbec0d955bc5"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.1"
  path_parsing:
    dependency: transitive
    description:
      name: path_parsing
      sha256: "883402936929eac138ee0a45da5b0f2c80f89913e6dc3bf77eb65b84b409c6ca"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  path_provider:
    dependency: "direct main"
    description:
      name: path_provider
      sha256: "50c5dd5b6e1aaf6fb3a78b33f6aa3afca52bf903a8a5298f53101fdaee55bbcd"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.5"
  path_provider_android:
    dependency: transitive
    description:
      name: path_provider_android
      sha256: f2c65e21139ce2c3dad46922be8272bb5963516045659e71bb16e151c93b580e
      url: "https://pub.dev"
    source: hosted
    version: "2.2.22"
  path_provider_foundation:
    dependency: transitive
    description:
      name: path_provider_foundation
      sha256: "6d13aece7b3f5c5a9731eaf553ff9dcbc2eff41087fd2df587fd0fed9a3eb0c4"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.1"
  path_provider_linux:
    dependency: transitive
    description:
      name: path_provider_linux
      sha256: f7a1fe3a634fe7734c8d3f2766ad746ae2a2884abe22e241a8b301bf5cac3279
      url: "https://pub.dev"
    source: hosted
    version: "2.2.1"
  path_provider_platform_interface:
    dependency: transitive
    description:
      name: path_provider_platform_interface
      sha256: "88f5779f72ba699763fa3a3b06aa4bf6de76c8e5de842cf6f29e2e06476c2334"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  path_provider_windows:
    dependency: transitive
    description:
      name: path_provider_windows
      sha256: bd6f00dbd873bfb70d0761682da2b3a2c2fccc2b9e84c495821639601d81afe7
      url: "https://pub.dev"
    source: hosted
    version: "2.3.0"
  pdf:
    dependency: "direct main"
    description:
      name: pdf
      sha256: "28eacad99bffcce2e05bba24e50153890ad0255294f4dd78a17075a2ba5c8416"
      url: "https://pub.dev"
    source: hosted
    version: "3.11.3"
  pdf_widget_wrapper:
    dependency: transitive
    description:
      name: pdf_widget_wrapper
      sha256: c930860d987213a3d58c7ec3b7ecf8085c3897f773e8dc23da9cae60a5d6d0f5
      url: "https://pub.dev"
    source: hosted
    version: "1.0.4"
  permission_handler:
    dependency: "direct main"
    description:
      name: permission_handler
      sha256: bc917da36261b00137bbc8896bf1482169cd76f866282368948f032c8c1caae1
      url: "https://pub.dev"
    source: hosted
    version: "12.0.1"
  permission_handler_android:
    dependency: transitive
    description:
      name: permission_handler_android
      sha256: "1e3bc410ca1bf84662104b100eb126e066cb55791b7451307f9708d4007350e6"
      url: "https://pub.dev"
    source: hosted
    version: "13.0.1"
  permission_handler_apple:
    dependency: transitive
    description:
      name: permission_handler_apple
      sha256: f000131e755c54cf4d84a5d8bd6e4149e262cc31c5a8b1d698de1ac85fa41023
      url: "https://pub.dev"
    source: hosted
    version: "9.4.7"
  permission_handler_html:
    dependency: transitive
    description:
      name: permission_handler_html
      sha256: "38f000e83355abb3392140f6bc3030660cfaef189e1f87824facb76300b4ff24"
      url: "https://pub.dev"
    source: hosted
    version: "0.1.3+5"
  permission_handler_platform_interface:
    dependency: transitive
    description:
      name: permission_handler_platform_interface
      sha256: eb99b295153abce5d683cac8c02e22faab63e50679b937fa1bf67d58bb282878
      url: "https://pub.dev"
    source: hosted
    version: "4.3.0"
  permission_handler_windows:
    dependency: transitive
    description:
      name: permission_handler_windows
      sha256: "1a790728016f79a41216d88672dbc5df30e686e811ad4e698bfc51f76ad91f1e"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.1"
  petitparser:
    dependency: transitive
    description:
      name: petitparser
      sha256: "91bd59303e9f769f108f8df05e371341b15d59e995e6806aefab827b58336675"
      url: "https://pub.dev"
    source: hosted
    version: "7.0.2"
  platform:
    dependency: transitive
    description:
      name: platform
      sha256: "5d6b1b0036a5f331ebc77c850ebc8506cbc1e9416c27e59b439f917a902a4984"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.6"
  plugin_platform_interface:
    dependency: transitive
    description:
      name: plugin_platform_interface
      sha256: "4820fbfdb9478b1ebae27888254d445073732dae3d6ea81f0b7e06d5dedc3f02"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.8"
  pool:
    dependency: transitive
    description:
      name: pool
      sha256: "978783255c543aa3586a1b3c21f6e9d720eb315376a915872c61ef8b5c20177d"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.2"
  posix:
    dependency: transitive
    description:
      name: posix
      sha256: "185ef7606574f789b40f289c233efa52e96dead518aed988e040a10737febb07"
      url: "https://pub.dev"
    source: hosted
    version: "6.5.0"
  print_bluetooth_thermal:
    dependency: "direct main"
    description:
      name: print_bluetooth_thermal
      sha256: "17b204a5340174c02acf5f6caf7279b5000344f1f1e1bcd01dbdbf912bce6e46"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.9"
  printing:
    dependency: "direct main"
    description:
      name: printing
      sha256: "482cd5a5196008f984bb43ed0e47cbfdca7373490b62f3b27b3299275bf22a93"
      url: "https://pub.dev"
    source: hosted
    version: "5.14.2"
  process:
    dependency: transitive
    description:
      name: process
      sha256: c6248e4526673988586e8c00bb22a49210c258dc91df5227d5da9748ecf79744
      url: "https://pub.dev"
    source: hosted
    version: "5.0.5"
  properties:
    dependency: transitive
    description:
      name: properties
      sha256: "333f427dd4ed07bdbe8c75b9ff864a1e70b5d7a8426a2e8bdd457b65ae5ac598"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  pub_semver:
    dependency: transitive
    description:
      name: pub_semver
      sha256: "5bfcf68ca79ef689f8990d1160781b4bad40a3bd5e5218ad4076ddb7f4081585"
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  pubspec_parse:
    dependency: transitive
    description:
      name: pubspec_parse
      sha256: "0560ba233314abbed0a48a2956f7f022cce7c3e1e73df540277da7544cad4082"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.0"
  qr:
    dependency: transitive
    description:
      name: qr
      sha256: "5a1d2586170e172b8a8c8470bbbffd5eb0cd38a66c0d77155ea138d3af3a4445"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.2"
  recase:
    dependency: transitive
    description:
      name: recase
      sha256: e4eb4ec2dcdee52dcf99cb4ceabaffc631d7424ee55e56f280bc039737f89213
      url: "https://pub.dev"
    source: hosted
    version: "4.1.0"
  riverpod:
    dependency: transitive
    description:
      name: riverpod
      sha256: "59062512288d3056b2321804332a13ffdd1bf16df70dcc8e506e411280a72959"
      url: "https://pub.dev"
    source: hosted
    version: "2.6.1"
  sentry:
    dependency: transitive
    description:
      name: sentry
      sha256: "605ad1f6f1ae5b72018cbe8fc20f490fa3bd53e58882e5579566776030d8c8c1"
      url: "https://pub.dev"
    source: hosted
    version: "9.14.0"
  sentry_dart_plugin:
    dependency: "direct dev"
    description:
      name: sentry_dart_plugin
      sha256: "514cd5cc5c022bed9c232d08dc126a081b8a965dbad78b819ae91bf3a06e622c"
      url: "https://pub.dev"
    source: hosted
    version: "3.2.1"
  sentry_flutter:
    dependency: "direct main"
    description:
      name: sentry_flutter
      sha256: "7fd0fb80050c1f6a77ae185bda997a76d384326d6777cf5137a6c38952c4ac7d"
      url: "https://pub.dev"
    source: hosted
    version: "9.14.0"
  shared_preferences:
    dependency: "direct main"
    description:
      name: shared_preferences
      sha256: "2939ae520c9024cb197fc20dee269cd8cdbf564c8b5746374ec6cacdc5169e64"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.4"
  shared_preferences_android:
    dependency: transitive
    description:
      name: shared_preferences_android
      sha256: cbc40be9be1c5af4dab4d6e0de4d5d3729e6f3d65b89d21e1815d57705644a6f
      url: "https://pub.dev"
    source: hosted
    version: "2.4.20"
  shared_preferences_foundation:
    dependency: transitive
    description:
      name: shared_preferences_foundation
      sha256: "4e7eaffc2b17ba398759f1151415869a34771ba11ebbccd1b0145472a619a64f"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.6"
  shared_preferences_linux:
    dependency: transitive
    description:
      name: shared_preferences_linux
      sha256: "580abfd40f415611503cae30adf626e6656dfb2f0cee8f465ece7b6defb40f2f"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shared_preferences_platform_interface:
    dependency: transitive
    description:
      name: shared_preferences_platform_interface
      sha256: "57cbf196c486bc2cf1f02b85784932c6094376284b3ad5779d1b1c6c6a816b80"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shared_preferences_web:
    dependency: transitive
    description:
      name: shared_preferences_web
      sha256: c49bd060261c9a3f0ff445892695d6212ff603ef3115edbb448509d407600019
      url: "https://pub.dev"
    source: hosted
    version: "2.4.3"
  shared_preferences_windows:
    dependency: transitive
    description:
      name: shared_preferences_windows
      sha256: "94ef0f72b2d71bc3e700e025db3710911bd51a71cefb65cc609dd0d9a982e3c1"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shelf:
    dependency: transitive
    description:
      name: shelf
      sha256: e7dd780a7ffb623c57850b33f43309312fc863fb6aa3d276a754bb299839ef12
      url: "https://pub.dev"
    source: hosted
    version: "1.4.2"
  shelf_web_socket:
    dependency: transitive
    description:
      name: shelf_web_socket
      sha256: "3632775c8e90d6c9712f883e633716432a27758216dfb61bd86a8321c0580925"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.0"
  sky_engine:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  socket_io_client:
    dependency: "direct main"
    description:
      name: socket_io_client
      sha256: ef6c989e5eee8d04baf18482ec3d7699b91bc41e279794a99d8e3bef897b074a
      url: "https://pub.dev"
    source: hosted
    version: "3.1.4"
  socket_io_common:
    dependency: transitive
    description:
      name: socket_io_common
      sha256: "162fbaecbf4bf9a9372a62a341b3550b51dcef2f02f3e5830a297fd48203d45b"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.1"
  source_gen:
    dependency: transitive
    description:
      name: source_gen
      sha256: "1d562a3c1f713904ebbed50d2760217fd8a51ca170ac4b05b0db490699dbac17"
      url: "https://pub.dev"
    source: hosted
    version: "4.2.0"
  source_helper:
    dependency: transitive
    description:
      name: source_helper
      sha256: "4a85e90b50694e652075cbe4575665539d253e6ec10e46e76b45368ab5e3caae"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.10"
  source_span:
    dependency: transitive
    description:
      name: source_span
      sha256: "56a02f1f4cd1a2d96303c0144c93bd6d909eea6bee6bf5a0e0b685edbd4c47ab"
      url: "https://pub.dev"
    source: hosted
    version: "1.10.2"
  sqlite3:
    dependency: "direct main"
    description:
      name: sqlite3
      sha256: "3145bd74dcdb4fd6f5c6dda4d4e4490a8087d7f286a14dee5d37087290f0f8a2"
      url: "https://pub.dev"
    source: hosted
    version: "2.9.4"
  sqlite3_flutter_libs:
    dependency: "direct main"
    description:
      name: sqlite3_flutter_libs
      sha256: "1e800ebe7f85a80a66adacaa6febe4d5f4d8b75f244e9838a27cb2ffc7aec08d"
      url: "https://pub.dev"
    source: hosted
    version: "0.5.41"
  sqlparser:
    dependency: transitive
    description:
      name: sqlparser
      sha256: "337e9997f7141ffdd054259128553c348635fa318f7ca492f07a4ab76f850d19"
      url: "https://pub.dev"
    source: hosted
    version: "0.43.1"
  stack_trace:
    dependency: transitive
    description:
      name: stack_trace
      sha256: "8b27215b45d22309b5cddda1aa2b19bdfec9df0e765f2de506401c071d38d1b1"
      url: "https://pub.dev"
    source: hosted
    version: "1.12.1"
  state_notifier:
    dependency: transitive
    description:
      name: state_notifier
      sha256: b8677376aa54f2d7c58280d5a007f9e8774f1968d1fb1c096adcb4792fba29bb
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  stream_channel:
    dependency: transitive
    description:
      name: stream_channel
      sha256: "969e04c80b8bcdf826f8f16579c7b14d780458bd97f56d107d3950fdbeef059d"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  stream_transform:
    dependency: transitive
    description:
      name: stream_transform
      sha256: ad47125e588cfd37a9a7f86c7d6356dde8dfe89d071d293f80ca9e9273a33871
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  string_scanner:
    dependency: transitive
    description:
      name: string_scanner
      sha256: "921cd31725b72fe181906c6a94d987c78e3b98c2e205b397ea399d4054872b43"
      url: "https://pub.dev"
    source: hosted
    version: "1.4.1"
  system_info2:
    dependency: transitive
    description:
      name: system_info2
      sha256: b937736ecfa63c45b10dde1ceb6bb30e5c0c340e14c441df024150679d65ac43
      url: "https://pub.dev"
    source: hosted
    version: "4.1.0"
  term_glyph:
    dependency: transitive
    description:
      name: term_glyph
      sha256: "7f554798625ea768a7518313e58f83891c7f5024f88e46e7182a4558850a4b8e"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.2"
  test_api:
    dependency: transitive
    description:
      name: test_api
      sha256: ab2726c1a94d3176a45960b6234466ec367179b87dd74f1611adb1f3b5fb9d55
      url: "https://pub.dev"
    source: hosted
    version: "0.7.7"
  typed_data:
    dependency: transitive
    description:
      name: typed_data
      sha256: f9049c039ebfeb4cf7a7104a675823cd72dba8297f264b6637062516699fa006
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  uuid:
    dependency: "direct main"
    description:
      name: uuid
      sha256: "1fef9e8e11e2991bb773070d4656b7bd5d850967a2456cfc83cf47925ba79489"
      url: "https://pub.dev"
    source: hosted
    version: "4.5.3"
  vector_math:
    dependency: transitive
    description:
      name: vector_math
      sha256: d530bd74fea330e6e364cda7a85019c434070188383e1cd8d9777ee586914c5b
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  vm_service:
    dependency: transitive
    description:
      name: vm_service
      sha256: "45caa6c5917fa127b5dbcfbd1fa60b14e583afdc08bfc96dda38886ca252eb60"
      url: "https://pub.dev"
    source: hosted
    version: "15.0.2"
  watcher:
    dependency: transitive
    description:
      name: watcher
      sha256: "1398c9f081a753f9226febe8900fce8f7d0a67163334e1c94a2438339d79d635"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.1"
  web:
    dependency: transitive
    description:
      name: web
      sha256: "868d88a33d8a87b18ffc05f9f030ba328ffefba92d6c127917a2ba740f9cfe4a"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  web_socket:
    dependency: transitive
    description:
      name: web_socket
      sha256: "34d64019aa8e36bf9842ac014bb5d2f5586ca73df5e4d9bf5c936975cae6982c"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.1"
  web_socket_channel:
    dependency: transitive
    description:
      name: web_socket_channel
      sha256: d645757fb0f4773d602444000a8131ff5d48c9e47adfe9772652dd1a4f2d45c8
      url: "https://pub.dev"
    source: hosted
    version: "3.0.3"
  win32:
    dependency: transitive
    description:
      name: win32
      sha256: d7cb55e04cd34096cd3a79b3330245f54cb96a370a1c27adb3c84b917de8b08e
      url: "https://pub.dev"
    source: hosted
    version: "5.15.0"
  win_ble:
    dependency: transitive
    description:
      name: win_ble
      sha256: "2a867e13c4b355b101fc2c6e2ac85eeebf965db34eca46856f8b478e93b41e96"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  xdg_directories:
    dependency: transitive
    description:
      name: xdg_directories
      sha256: "7a3f37b05d989967cdddcbb571f1ea834867ae2faa29725fd085180e0883aa15"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  xml:
    dependency: transitive
    description:
      name: xml
      sha256: "971043b3a0d3da28727e40ed3e0b5d18b742fa5a68665cca88e74b7876d5e025"
      url: "https://pub.dev"
    source: hosted
    version: "6.6.1"
  yaml:
    dependency: transitive
    description:
      name: yaml
      sha256: b9da305ac7c39faa3f030eccd175340f968459dae4af175130b3fc47e40d76ce
      url: "https://pub.dev"
    source: hosted
    version: "3.1.3"
sdks:
  dart: ">=3.9.0 <4.0.0"
  flutter: ">=3.35.0"

================
File: qristal_mobile/lib/features/auth/screens/login_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:qristal_mobile/core/theme/app_theme.dart';
import '../../kitchen/screens/kitchen_screen.dart';
import '../../sync/providers/sync_provider.dart';
import '../../tables/screens/floor_plan_screen.dart';
import '../providers/auth_provider.dart';



class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({super.key});

  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends ConsumerState<LoginScreen> {
  final TextEditingController _userController = TextEditingController();
  final TextEditingController _pinController = TextEditingController();

  // Listen to state changes
  void _listenToAuthChanges() {
    ref.listen(authControllerProvider, (previous, next) async {
      if (next.error != null) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(next.error!), backgroundColor: AppTheme.error),
        );
      }

      if (next.isAuthenticated) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text("Authentication successful. Syncing data..."),
          ),
        );

        await ref.read(syncControllerProvider.notifier).performSync();

        if (context.mounted) {
          // --- ROLE-BASED ROUTING ---
          if (next.role == 'KITCHEN') {
            Navigator.pushReplacement(
              context,
              MaterialPageRoute(builder: (_) => const KitchenScreen()),
            );
          } else {
            Navigator.pushReplacement(
              context,
              MaterialPageRoute(builder: (_) => const FloorPlanScreen()),
            );
          }
        }
      }
    });
  }
  
  void _handleLogin() {
    final userId =
        '20e712c3-e030-4bc5-ac2b-cafd92dc055f'; // _userController.text.trim();
    final pin = _pinController.text
        .trim(); // '1234'; // _pinController.text.trim();

    if (userId.isEmpty || pin.isEmpty) return;

    ref.read(authControllerProvider.notifier).login(userId, pin);
  }

  @override
  Widget build(BuildContext context) {
    _listenToAuthChanges();
    final authState = ref.watch(authControllerProvider);

    return Scaffold(
      body: Row(
        children: [
          // LEFT SIDE: Branding / Art
          Expanded(
            flex: 2,
            child: Container(
              color: AppTheme.surface,
              child: const Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      Icons.point_of_sale,
                      size: 100,
                      color: AppTheme.qristalBlue,
                    ),
                    SizedBox(height: 20),
                    Text(
                      "Qristal POS",
                      style: TextStyle(
                        fontSize: 40,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    ),
                    Text(
                      "Enterprise Grade. Startup Ready.",
                      style: TextStyle(color: Colors.grey),
                    ),
                  ],
                ),
              ),
            ),
          ),

          // RIGHT SIDE: Login Form
          Expanded(
            flex: 3,
            child: Padding(
              padding: const EdgeInsets.all(40.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  const Text(
                    "Staff Access",
                    style: TextStyle(fontSize: 24, fontWeight: FontWeight.w600),
                  ),
                  const SizedBox(height: 30),

                  // User ID Input (Paste your seeded UUID here)
                  TextField(
                    controller: _userController,
                    decoration: const InputDecoration(
                      labelText: "Operator ID",
                      prefixIcon: Icon(Icons.badge),
                    ),
                  ),
                  const SizedBox(height: 20),

                  // PIN Input
                  TextField(
                    controller: _pinController,
                    obscureText: true,
                    keyboardType: TextInputType.number,
                    decoration: const InputDecoration(
                      labelText: "Access PIN",
                      prefixIcon: Icon(Icons.lock),
                    ),
                    onSubmitted: (_) => _handleLogin(),
                  ),
                  const SizedBox(height: 40),
                
                  // Login Button
                  SizedBox(
                    height: 60,
                    child: ElevatedButton(
                      onPressed: authState.isLoading ? null : _handleLogin,
                      child: authState.isLoading
                          ? const CircularProgressIndicator(color: Colors.white)
                          : const Text("UNLOCK TERMINAL"),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

================
File: qristal_mobile/lib/database/database.dart
================
import 'dart:io';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import 'package:sqlite3/sqlite3.dart';
import 'package:sqlite3_flutter_libs/sqlite3_flutter_libs.dart';

part 'database.g.dart';

class Categories extends Table {
  TextColumn get id => text()();
  TextColumn get branchId => text().withDefault(const Constant('BRANCH-01'))();
  TextColumn get name => text()();
  TextColumn get colorHex => text().nullable()();
  IntColumn get sortOrder => integer().withDefault(const Constant(0))();
  DateTimeColumn get updatedAt => dateTime().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

class Products extends Table {
  TextColumn get id => text()();
  TextColumn get branchId => text().withDefault(const Constant('BRANCH-01'))();
  TextColumn get categoryId => text().references(Categories, #id)();
  TextColumn get name => text()();
  RealColumn get price => real()();
  BoolColumn get isAvailable => boolean().withDefault(const Constant(true))();
  DateTimeColumn get updatedAt => dateTime().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

class Orders extends Table {
  TextColumn get id => text()();
  TextColumn get branchId => text().withDefault(const Constant('BRANCH-01'))();
  TextColumn get receiptNumber => text()();
  TextColumn get userId => text()();
  TextColumn get tableId => text().nullable()();
  RealColumn get totalAmount => real()();
  TextColumn get status => text()();
  DateTimeColumn get createdAt => dateTime()();
  DateTimeColumn get updatedAt => dateTime()();
  TextColumn get shiftId => text().references(Shifts, #id)();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};
}

class OrderItems extends Table {
  TextColumn get id => text()();
  TextColumn get orderId => text().references(Orders, #id)();
  TextColumn get productId => text().references(Products, #id)();
  IntColumn get quantity => integer()();
  RealColumn get priceAtTimeOfOrder => real()();
  TextColumn get routeTo => text().nullable()();
  TextColumn get notes => text().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

class OrderItemModifiers extends Table {
  TextColumn get id => text()();
  TextColumn get orderItemId => text().references(OrderItems, #id)();
  TextColumn get name => text()();
  RealColumn get priceDelta => real().withDefault(const Constant(0))();
  TextColumn get routeTo => text().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

class OrderItemSides extends Table {
  TextColumn get id => text()();
  TextColumn get orderItemId => text().references(OrderItems, #id)();
  TextColumn get name => text()();
  IntColumn get quantity => integer().withDefault(const Constant(1))();
  RealColumn get priceDelta => real().withDefault(const Constant(0))();
  TextColumn get routeTo => text().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

class Payments extends Table {
  TextColumn get id => text()();
  TextColumn get branchId => text().withDefault(const Constant('BRANCH-01'))();
  TextColumn get orderId => text().references(Orders, #id)();
  TextColumn get shiftId => text().references(Shifts, #id)();
  TextColumn get method => text()();
  RealColumn get amount => real()();
  TextColumn get reference => text().nullable()();
  DateTimeColumn get createdAt => dateTime()();

  @override
  Set<Column> get primaryKey => {id};
}

class SeatingTables extends Table {
  TextColumn get id => text()();
  TextColumn get branchId => text().withDefault(const Constant('BRANCH-01'))();
  TextColumn get name => text()();
  TextColumn get status => text().withDefault(const Constant('FREE'))();
  TextColumn get floor => text().withDefault(const Constant('Main'))();
  DateTimeColumn get updatedAt => dateTime().nullable()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};
}

class Shifts extends Table {
  TextColumn get id => text()();
  TextColumn get branchId => text().withDefault(const Constant('BRANCH-01'))();
  TextColumn get userId => text()();
  DateTimeColumn get openingTime => dateTime()();
  DateTimeColumn get closingTime => dateTime().nullable()();
  RealColumn get startingCash => real().withDefault(const Constant(0.0))();
  RealColumn get expectedCash => real().nullable()();
  RealColumn get actualCash => real().nullable()();
  TextColumn get notes => text().nullable()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};
}

@DriftDatabase(
  tables: [
    Categories,
    Products,
    Orders,
    OrderItems,
    OrderItemModifiers,
    OrderItemSides,
    Payments,
    SeatingTables,
    Shifts,
  ],
)
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 5;

  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onUpgrade: (Migrator m, int from, int to) async {
        if (from < 3) {
          await m.createTable(seatingTables);
        }
        if (from < 5) {
          await m.addColumn(orderItems, orderItems.routeTo);
          await m.createTable(orderItemModifiers);
          await m.createTable(orderItemSides);
        }
      },
    );
  }

  Stream<List<Order>> watchKitchenOrders() {
    return (select(orders)
          ..where((t) => t.status.isIn(['KITCHEN', 'PREPARING']))
          ..orderBy([(t) => OrderingTerm(expression: t.createdAt)]))
        .watch();
  }

  Future<List<TypedOrderItem>> getOrderItems(String orderId) async {
    final query = select(orderItems).join([
      innerJoin(products, products.id.equalsExp(orderItems.productId)),
    ])..where(orderItems.orderId.equals(orderId));

    final rows = await query.get();
    final typedRows = <TypedOrderItem>[];

    for (final row in rows) {
      final item = row.readTable(orderItems);
      final modifierRows = await (select(orderItemModifiers)
            ..where((m) => m.orderItemId.equals(item.id)))
          .get();
      final sideRows =
          await (select(orderItemSides)..where((s) => s.orderItemId.equals(item.id)))
              .get();

      typedRows.add(
        TypedOrderItem(
          item: item,
          product: row.readTable(products),
          modifiers: modifierRows,
          sides: sideRows,
        ),
      );
    }

    return typedRows;
  }

  Future<void> updateOrderStatus(String id, String newStatus) async {
    await (update(orders)..where((t) => t.id.equals(id))).write(
      OrdersCompanion(
        status: Value(newStatus),
        updatedAt: Value(DateTime.now()),
        isSynced: const Value(false),
      ),
    );
  }
}

class TypedOrderItem {
  final OrderItem item;
  final Product product;
  final List<OrderItemModifier> modifiers;
  final List<OrderItemSide> sides;

  TypedOrderItem({
    required this.item,
    required this.product,
    this.modifiers = const [],
    this.sides = const [],
  });
}

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'db.sqlite'));

    if (Platform.isAndroid) {
      await applyWorkaroundToOpenSqlite3OnOldAndroidVersions();
      final cachebase = (await getTemporaryDirectory()).path;
      sqlite3.tempDirectory = cachebase;
    }

    return NativeDatabase.createInBackground(file);
  });
}

================
File: qristal_mobile/pubspec.yaml
================
name: qristal_mobile
description: "Qristal POS Mobile App."

publish_to: 'none' # Remove this line if you wish to publish to pub.dev


version: 1.1.1+2

environment:
  sdk: ^3.9.0


dependencies:
  sentry_flutter: ^9.14.0
  flutter:
    sdk: flutter


  cupertino_icons: ^1.0.6
  path_provider: ^2.1.5
  path: ^1.9.0
  drift: ^2.21.0
  http: ^1.6.0
  flutter_secure_storage: ^10.0.0
  flutter_riverpod: ^2.6.1
  uuid: ^4.5.2
  shared_preferences: ^2.3.3
  sqlite3_flutter_libs: ^0.5.41
  sqlite3: ^2.9.4
  
  intl: ^0.20.2
  permission_handler: ^12.0.1
  print_bluetooth_thermal: ^1.1.9
  esc_pos_utils_plus: ^2.0.4
  connectivity_plus: ^7.0.0
  socket_io_client: ^3.1.4
  printing: ^5.14.2
  pdf: ^3.11.3



dev_dependencies:
  sentry_dart_plugin: ^3.2.1
  flutter_test:
    sdk: flutter

  flutter_lints: ^5.0.0
  drift_dev: ^2.14.1
  build_runner: ^2.4.8
  json_serializable: ^6.7.1


# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/assets-and-images/#resolution-aware

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/assets-and-images/#from-packages

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/custom-fonts/#from-packages

sentry:
  upload_debug_symbols: true
  upload_source_maps: true
  project: flutter
  org: truthysystems

================
File: qristal_mobile/lib/features/pos/providers/cart_provider.dart
================
import 'dart:async';

import 'package:drift/drift.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import '../../../core/constants/role_constants.dart';
import '../../../core/providers/database_provider.dart';
import '../../../database/database.dart';
import '../../auth/providers/auth_provider.dart';
import '../../hardware/services/printer_service.dart';
import '../../shifts/providers/shift_provider.dart';
import '../../sync/providers/sync_provider.dart';
import '../../tables/screens/floor_plan_screen.dart';
import '../models/cart_item.dart';
import '../services/order_service.dart';
import '../widgets/payment_modal.dart';

class CartNotifier extends StateNotifier<List<CartItem>> {
  final AppDatabase db;
  final String? userId;
  final String userName;
  final PrinterService printerService;
  final Ref ref;

  String? _activeOrderId;
  final Map<String, int> _baselineQuantities = {};
  int _orderRevision = 0;
  int _lastPrintedRevision = -1;
  int _printsForCurrentRevision = 0;

  CartNotifier(
    this.db,
    this.userId,
    this.userName,
    this.printerService,
    this.ref,
  ) : super([]);

  void addToCart(
    Product product, {
    String? routeTo,
    List<CartModifier> modifiers = const [],
    List<CartSide> sides = const [],
  }) {
    final probe = CartItem(
      product: product,
      routeTo: routeTo,
      modifiers: modifiers,
      sides: sides,
    );
    final existingIndex = state.indexWhere(
      (item) => _cartKey(item) == _cartKey(probe),
    );

    if (existingIndex >= 0) {
      final existingItem = state[existingIndex];
      final updatedItem = existingItem.copyWith(
        quantity: existingItem.quantity + 1,
      );
      state = [
        ...state.sublist(0, existingIndex),
        updatedItem,
        ...state.sublist(existingIndex + 1),
      ];
    } else {
      state = [
        ...state,
        CartItem(
          product: product,
          routeTo: routeTo,
          modifiers: modifiers,
          sides: sides,
        ),
      ];
    }
    _markOrderModified();
  }

  Future<void> removeFromCart(Product product) async {
    final userRole = await ref.read(userRoleProvider.future);
    if (_activeOrderId != null &&
        (userRole != UserRole.MANAGER && userRole != UserRole.OWNER)) {
      return;
    }
    state = state.where((item) => item.product.id != product.id).toList();
    _markOrderModified();
  }

  Future<void> decreaseQuantity(CartItem item) async {
    final userRole = await ref.read(userRoleProvider.future);
    if (_activeOrderId != null &&
        (userRole != UserRole.MANAGER && userRole != UserRole.OWNER)) {
      final key = _cartKey(item);
      final baseline = _baselineQuantities[key] ?? 0;
      if ((item.quantity - 1) < baseline) {
        return;
      }
    }

    final existingIndex = state.indexWhere(
      (i) => i.product.id == item.product.id && i.notes == item.notes,
    );

    if (existingIndex != -1) {
      if (state[existingIndex].quantity > 1) {
        final updatedItem = state[existingIndex].copyWith(
          quantity: state[existingIndex].quantity - 1,
        );
        state = [
          ...state.sublist(0, existingIndex),
          updatedItem,
          ...state.sublist(existingIndex + 1),
        ];
        _markOrderModified();
      } else {
        await removeFromCart(item.product);
      }
    }
  }

  void clearCart() {
    state = [];
    _activeOrderId = null;
    _baselineQuantities.clear();
    _orderRevision = 0;
    _lastPrintedRevision = -1;
    _printsForCurrentRevision = 0;
  }

  double get totalAmount => state.fold(0, (sum, item) => sum + item.total);

  Future<void> loadTableCart(String? tableId) async {
    if (tableId == null) {
      clearCart();
      return;
    }

    final existingOrder =
        await (db.select(db.orders)
              ..where(
                (o) =>
                    o.tableId.equals(tableId) &
                    o.status.isIn(const ['KITCHEN', 'PREPARING']),
              )
              ..orderBy([(o) => OrderingTerm.desc(o.createdAt)])
              ..limit(1))
            .getSingleOrNull();

    if (existingOrder == null) {
      clearCart();
      return;
    }

    final typedItems = await db.getOrderItems(existingOrder.id);
    final recalled = typedItems
        .map(
          (row) => CartItem(
            product: row.product,
            quantity: row.item.quantity,
            notes: row.item.notes ?? '',
            routeTo: row.item.routeTo,
            modifiers: row.modifiers
                .map(
                  (m) => CartModifier(
                    name: m.name,
                    priceDelta: m.priceDelta,
                    routeTo: m.routeTo,
                  ),
                )
                .toList(),
            sides: row.sides
                .map(
                  (side) => CartSide(
                    name: side.name,
                    quantity: side.quantity,
                    priceDelta: side.priceDelta,
                    routeTo: side.routeTo,
                  ),
                )
                .toList(),
          ),
        )
        .toList();

    _activeOrderId = existingOrder.id;
    _baselineQuantities
      ..clear()
      ..addAll(_toQuantityMap(recalled));
    _orderRevision = 0;
    _lastPrintedRevision = -1;
    _printsForCurrentRevision = 0;
    state = recalled;
  }

  Future<String?> printBillCheck() async {
    if (state.isEmpty || userId == null) {
      return 'Add items before printing a bill.';
    }

    final userRole = await ref.read(userRoleProvider.future);
    final maxPrints =
        (userRole == UserRole.MANAGER || userRole == UserRole.OWNER) ? 5 : 1;

    if (_lastPrintedRevision != _orderRevision) {
      _printsForCurrentRevision = 0;
    }

    if (_printsForCurrentRevision >= maxPrints) {
      return userRole == UserRole.MANAGER || userRole == UserRole.OWNER
          ? 'Bill already printed 5 times for this version of the order.'
          : 'Bill already printed once. Modify the order first to print again.';
    }

    final now = DateTime.now();
    final orderReference =
        _activeOrderId ??
        _buildOrderNumber(ref.read(activeTableIdProvider), now);

    try {
      await printerService.printReceipt(
        orderId: orderReference,
        items: state,
        total: totalAmount,
        tendered: 0,
        paymentMethod: 'BILL CHECK',
        cashierName: userName,
      );
      _lastPrintedRevision = _orderRevision;
      _printsForCurrentRevision += 1;
      return null;
    } catch (e) {
      return 'Printing failed: $e';
    }
  }

  Future<void> sendToKitchen() async {
    if (state.isEmpty || userId == null) return;

    final shiftId = ref.read(activeShiftIdProvider);
    if (shiftId == null) {
      throw Exception("No active shift found. Please clock in.");
    }

    final now = DateTime.now();
    final tableId = ref.read(activeTableIdProvider);
    final currentQuantities = _toQuantityMap(state);

    if (_activeOrderId == null) {
      final orderId = const Uuid().v4();
      await db.transaction(() async {
        await db
            .into(db.orders)
            .insert(
              OrdersCompanion(
                id: Value(orderId),
                receiptNumber: Value(_buildOrderNumber(tableId, now)),
                userId: Value(userId!),
                tableId: Value(tableId),
                shiftId: Value(shiftId),
                totalAmount: Value(totalAmount),
                status: const Value('KITCHEN'),
                isSynced: const Value(false),
                createdAt: Value(now),
                updatedAt: Value(now),
              ),
            );

        if (tableId != null) {
          await (db.update(db.seatingTables)
                ..where((t) => t.id.equals(tableId)))
              .write(const SeatingTablesCompanion(status: Value('OCCUPIED')));
        }

        for (final cartItem in state) {
          final orderItemId = const Uuid().v4();
          await db
              .into(db.orderItems)
              .insert(
                OrderItemsCompanion(
                  id: Value(orderItemId),
                  orderId: Value(orderId),
                  productId: Value(cartItem.product.id),
                  quantity: Value(cartItem.quantity),
                  priceAtTimeOfOrder: Value(cartItem.product.price),
                  routeTo: Value(cartItem.routeTo),
                  notes: Value(cartItem.notes.isEmpty ? null : cartItem.notes),
                ),
              );
          await _insertOrderItemRelations(cartItem, orderItemId);
        }
      });

      _activeOrderId = orderId;
      _baselineQuantities
        ..clear()
        ..addAll(currentQuantities);
      state = [];
      ref.read(syncControllerProvider.notifier).performSync();
      return;
    }

    final newItems = <CartItem>[];
    for (final item in state) {
      final key = _cartKey(item);
      final baseline = _baselineQuantities[key] ?? 0;
      final delta = item.quantity - baseline;
      if (delta > 0) {
        newItems.add(item.copyWith(quantity: delta));
      }
    }

    if (newItems.isEmpty) return;

    await db.transaction(() async {
      for (final item in newItems) {
        final orderItemId = const Uuid().v4();
        await db
            .into(db.orderItems)
            .insert(
              OrderItemsCompanion(
                id: Value(orderItemId),
                orderId: Value(_activeOrderId!),
                productId: Value(item.product.id),
                quantity: Value(item.quantity),
                priceAtTimeOfOrder: Value(item.product.price),
                routeTo: Value(item.routeTo),
                notes: Value(item.notes.isEmpty ? null : item.notes),
              ),
            );
        await _insertOrderItemRelations(item, orderItemId);
      }

      await (db.update(
        db.orders,
      )..where((o) => o.id.equals(_activeOrderId!))).write(
        OrdersCompanion(
          totalAmount: Value(totalAmount),
          updatedAt: Value(now),
          isSynced: const Value(false),
        ),
      );
    });

    _baselineQuantities
      ..clear()
      ..addAll(currentQuantities);
    state = [];
    ref.read(syncControllerProvider.notifier).performSync();
  }

  Future<void> checkout(BuildContext context) async {
    if (state.isEmpty || userId == null) return;

    final shiftId = ref.read(activeShiftIdProvider);
    if (shiftId == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Error: No active shift found.")),
      );
      return;
    }

    final total = totalAmount;

    showDialog(
      context: context,
      builder: (_) => PaymentModal(
        totalAmount: total,
        onConfirmed: (method, tendered, refCode) async {
          await _finalizeOrder(total, method, tendered, refCode, shiftId);
        },
      ),
    );
  }

  Future<void> _finalizeOrder(
    double total,
    String method,
    double tendered,
    String? refCode,
    String shiftId,
  ) async {
    final orderId = const Uuid().v4();
    final now = DateTime.now();
    final tableId = ref.read(activeTableIdProvider);

    await db.transaction(() async {
      await db
          .into(db.orders)
          .insert(
            OrdersCompanion(
              id: Value(orderId),
              receiptNumber: Value(orderId.substring(0, 4).toUpperCase()),
              userId: Value(userId!),
              tableId: Value(tableId),
              shiftId: Value(shiftId),
              totalAmount: Value(total),
              status: const Value('CLOSED'),
              isSynced: const Value(false),
              createdAt: Value(now),
              updatedAt: Value(now),
            ),
          );

      if (tableId != null) {
        await (db.update(db.seatingTables)..where((t) => t.id.equals(tableId)))
            .write(const SeatingTablesCompanion(status: Value('FREE')));
      }

      for (var cartItem in state) {
        final orderItemId = const Uuid().v4();
        await db
            .into(db.orderItems)
            .insert(
              OrderItemsCompanion(
                id: Value(orderItemId),
                orderId: Value(orderId),
                productId: Value(cartItem.product.id),
                quantity: Value(cartItem.quantity),
                priceAtTimeOfOrder: Value(cartItem.product.price),
                routeTo: Value(cartItem.routeTo),
                notes: Value(cartItem.notes.isEmpty ? null : cartItem.notes),
              ),
            );
        await _insertOrderItemRelations(cartItem, orderItemId);
      }

      await db
          .into(db.payments)
          .insert(
            PaymentsCompanion(
              id: Value(const Uuid().v4()),
              orderId: Value(orderId),
              shiftId: Value(shiftId),
              method: Value(method),
              amount: Value(total),
              reference: Value(refCode),
              createdAt: Value(now),
            ),
          );
    });

    try {
      await printerService.printReceipt(
        orderId: orderId,
        items: state,
        total: total,
        tendered: tendered,
        paymentMethod: method,
        cashierName: userName,
      );
    } catch (e) {
      if (kDebugMode) print("Printing failed: $e");
    }

    clearCart();
    ref.read(syncControllerProvider.notifier).performSync();
  }

  void _markOrderModified() {
    _orderRevision += 1;
  }

  Map<String, int> _toQuantityMap(List<CartItem> items) {
    final map = <String, int>{};
    for (final item in items) {
      final key = _cartKey(item);
      map[key] = (map[key] ?? 0) + item.quantity;
    }
    return map;
  }

  String _cartKey(CartItem item) {
    final mods = item.modifiers
        .map((m) => '${m.name}:${m.priceDelta}:${m.routeTo ?? ''}')
        .join('|');
    final sides = item.sides
        .map(
          (s) => '${s.name}:${s.quantity}:${s.priceDelta}:${s.routeTo ?? ''}',
        )
        .join('|');
    return '${item.product.id}::${item.notes.trim()}::${item.routeTo ?? ''}::$mods::$sides';
  }

  Future<void> _insertOrderItemRelations(
    CartItem cartItem,
    String orderItemId,
  ) async {
    for (final modifier in cartItem.modifiers) {
      await db
          .into(db.orderItemModifiers)
          .insert(
            OrderItemModifiersCompanion(
              id: Value(const Uuid().v4()),
              orderItemId: Value(orderItemId),
              name: Value(modifier.name),
              priceDelta: Value(modifier.priceDelta),
              routeTo: Value(modifier.routeTo),
            ),
          );
    }

    for (final side in cartItem.sides) {
      await db
          .into(db.orderItemSides)
          .insert(
            OrderItemSidesCompanion(
              id: Value(const Uuid().v4()),
              orderItemId: Value(orderItemId),
              name: Value(side.name),
              quantity: Value(side.quantity),
              priceDelta: Value(side.priceDelta),
              routeTo: Value(side.routeTo),
            ),
          );
    }
  }

  String _buildOrderNumber(String? tableId, DateTime now) {
    if (tableId != null && tableId.isNotEmpty) {
      return tableId.substring(0, 4).toUpperCase();
    }

    final suffix = (now.millisecondsSinceEpoch % 10000).toString().padLeft(
      4,
      '0',
    );
    return 'TK$suffix';
  }
}

final cartProvider = StateNotifierProvider<CartNotifier, List<CartItem>>((ref) {
  final db = ref.watch(databaseProvider);
  final authState = ref.watch(authControllerProvider);
  final printerService = ref.watch(printerServiceProvider);

  final notifier = CartNotifier(
    db,
    authState.userId,
    'Cashier',
    printerService,
    ref,
  );

  final tableId = ref.watch(activeTableIdProvider);
  if (tableId != null) {
    Future.microtask(() => notifier.loadTableCart(tableId));
  }

  return notifier;
});

final orderServiceProvider = Provider(
  (ref) => OrderService(ref.watch(databaseProvider)),
);

final checkoutProvider = FutureProvider.family<void, String>((
  ref,
  userId,
) async {
  final cart = ref.read(cartProvider);
  if (cart.isEmpty) return;

  final orderService = ref.read(orderServiceProvider);
  final shiftId = ref.read(activeShiftIdProvider);
  if (shiftId == null) return;

  await orderService.placeOrder(
    cartItems: cart,
    userId: userId,
    shiftId: shiftId,
  );

  ref.read(cartProvider.notifier).clearCart();
});

================
File: qristal_mobile/lib/features/pos/screens/dashboard_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/theme/app_theme.dart';
import '../../auth/providers/auth_provider.dart';
import '../../hardware/screens/printer_settings_screen.dart';
import '../../kitchen/screens/kitchen_screen.dart';
import '../../shifts/providers/shift_provider.dart';
import '../../shifts/screens/close_shift_screen.dart';
import '../../shifts/screens/open_shift_dialog.dart';
import '../../sync/providers/sync_queue_provider.dart';
import '../providers/menu_provider.dart';
import '../providers/cart_provider.dart';

class DashboardScreen extends ConsumerStatefulWidget {
  const DashboardScreen({super.key});

  @override
  ConsumerState<DashboardScreen> createState() => _DashboardScreenState();
}

class _DashboardScreenState extends ConsumerState<DashboardScreen> {
  @override
  void initState() {
    super.initState();
    // Schedule the check for after the first frame build
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _checkAndEnforceShift();
    });
  }

  Future<void> _checkAndEnforceShift() async {
    final userId = ref.read(authControllerProvider).userId;
    if (userId == null) return;

    final shiftService = ref.read(shiftServiceProvider);

    // 1. Check if we already have an ID in memory state
    if (ref.read(activeShiftIdProvider) != null) return;

    // 2. Check Database for an existing open shift for this user
    final existingShiftId = await shiftService.getActiveShift(userId);

    if (existingShiftId != null) {
      // Restore the shift
      ref.read(activeShiftIdProvider.notifier).state = existingShiftId;
    } else {
      // 3. Force Open Shift
      if (mounted) {
        showDialog(
          context: context,
          barrierDismissible: false, // User must open shift or logout
          builder: (context) => OpenShiftDialog(userId: userId),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final userRole = ref.watch(authControllerProvider).role;

    // UI GUARDRAILS
    final isAdmin = userRole == 'OWNER' || userRole == 'MANAGER';
    final canManageCash = isAdmin || userRole == 'CASHIER';

    final syncQueue = ref.watch(syncQueueProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text("Qristal POS - Cashier"),
        backgroundColor: AppTheme.surface,
        actions: [
          // Shift Indicator
          Consumer(builder: (context, ref, _) {
            final shiftId = ref.watch(activeShiftIdProvider);
            return Padding(
                padding: const EdgeInsets.only(right: 12),
                child: Chip(
                  label: Text(shiftId != null ? "SHIFT OPEN" : "NO SHIFT"),
                  backgroundColor: shiftId != null
                      ? Colors.green.withOpacity(0.2)
                      : Colors.red.withOpacity(0.2),
                  labelStyle: TextStyle(
                      color: shiftId != null ? Colors.green : Colors.red,
                      fontSize: 10),
                ));
          }),

          if (canManageCash)
            PopupMenuButton<String>(
              onSelected: (value) {
                if (value == 'close_shift') {
                  Navigator.push(
                      context,
                      MaterialPageRoute(
                          builder: (_) => const CloseShiftScreen()));
                }
              },
              itemBuilder: (BuildContext context) {
                return [
                  const PopupMenuItem(
                    value: 'close_shift',
                    child: Row(
                      children: [
                        Icon(Icons.assignment_turned_in, color: Colors.black),
                        SizedBox(width: 8),
                        Text('End Shift / Z-Report',
                            style: TextStyle(color: Colors.black)),
                      ],
                    ),
                  ),
                ];
              },
            ),

          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Row(
              children: [
                if (syncQueue.pendingOrders > 0)
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 2,
                    ),
                    decoration: BoxDecoration(
                      color: Colors.orange,
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      "${syncQueue.pendingOrders} Pending",
                      style: const TextStyle(fontWeight: FontWeight.bold),
                    ),
                  ),
                const SizedBox(width: 8),
                _buildSyncIcon(syncQueue.status),
              ],
            ),
          ),
          // Navigation to Kitchen Display System
          IconButton(
            icon: const Icon(Icons.soup_kitchen),
            tooltip: 'Kitchen Display',
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(builder: (_) => const KitchenScreen()),
              );
            },
          ),
          // Navigation to Printer Settings
          if (isAdmin)
            IconButton(
              icon: const Icon(Icons.print),
              tooltip: 'Printer Settings',
              onPressed: () {
                Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder: (_) => const PrinterSettingsScreen(),
                  ),
                );
              },
            ),

          const SizedBox(width: 20),
        ],
      ),
      body: Row(
        children: [
          // 1. LEFT COLUMN: Categories
          Expanded(
            flex: 2,
            child: Container(
              color: AppTheme.surface,
              child: const CategoryListWidget(),
            ),
          ),

          // 2. MIDDLE COLUMN: Products Grid
          Expanded(
            flex: 5,
            child: Container(
              color: AppTheme.background,
              padding: const EdgeInsets.all(8),
              child: const ProductGridWidget(),
            ),
          ),

          // 3. RIGHT COLUMN: Cart / Ticket
          Expanded(
            flex: 3,
            child: Container(color: Colors.white, child: const CartWidget()),
          ),
        ],
      ),
    );
  }
}

// --- WIDGETS ---

Widget _buildSyncIcon(ConnectionStatus status) {
  switch (status) {
    case ConnectionStatus.syncing:
      return const SizedBox(
        width: 20,
        height: 20,
        child: CircularProgressIndicator(
          color: AppTheme.qristalBlue,
          strokeWidth: 2,
        ),
      );
    case ConnectionStatus.offline:
      return const Icon(Icons.cloud_off, color: Colors.grey);
    case ConnectionStatus.error:
      return const Icon(Icons.error_outline, color: AppTheme.error);
    case ConnectionStatus.online:
      return const Icon(Icons.cloud_done, color: AppTheme.emerald);
  }
}

class CategoryListWidget extends ConsumerWidget {
  const CategoryListWidget({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final categoriesAsync = ref.watch(categoriesStreamProvider);
    final selectedId = ref.watch(selectedCategoryProvider);

    return categoriesAsync.when(
      data: (categories) => ListView.builder(
        itemCount: categories.length,
        itemBuilder: (context, index) {
          final cat = categories[index];
          final isSelected = cat.id == selectedId;

          return InkWell(
            onTap: () =>
                ref.read(selectedCategoryProvider.notifier).state = cat.id,
            child: Container(
              height: 80,
              alignment: Alignment.centerLeft,
              padding: const EdgeInsets.symmetric(horizontal: 16),
              color: isSelected ? AppTheme.qristalBlue.withOpacity(0.2) : null,
              child: Row(
                children: [
                  Container(
                    width: 6,
                    height: 80,
                    color: hexToColor(cat.colorHex) ?? Colors.grey,
                  ),
                  const SizedBox(width: 12),
                  Text(
                    cat.name,
                    style: TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 16,
                      color: isSelected ? AppTheme.qristalBlue : Colors.white,
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, stack) => Center(child: Text('Error: $err')),
    );
  }

  Color? hexToColor(String? hex) {
    if (hex == null) return null;
    return Color(int.parse(hex.replaceFirst('#', '0xFF')));
  }
}

class ProductGridWidget extends ConsumerWidget {
  const ProductGridWidget({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final productsAsync = ref.watch(productsStreamProvider);

    return productsAsync.when(
      data: (products) => GridView.builder(
        gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 3, // 3 Columns of products
          childAspectRatio: 1.2,
          crossAxisSpacing: 8,
          mainAxisSpacing: 8,
        ),
        itemCount: products.length,
        itemBuilder: (context, index) {
          final product = products[index];
          return Card(
            color: AppTheme.surface,
            elevation: 2,
            child: InkWell(
              onTap: () {
                // ADD TO CART ACTION
                ref.read(cartProvider.notifier).addToCart(product);
              },
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(
                    product.name,
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                    textAlign: TextAlign.center,
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    "UGX ${product.price.toStringAsFixed(0)}",
                    style: const TextStyle(
                      fontSize: 14,
                      color: AppTheme.emerald,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, stack) => Center(child: Text('Error: $err')),
    );
  }
}

class CartWidget extends ConsumerWidget {
  const CartWidget({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final cartItems = ref.watch(cartProvider);
    final cartNotifier = ref.read(cartProvider.notifier);

    // Check role for Checkout Button Guardrails
    final userRole = ref.watch(authControllerProvider).role;
    final canCheckout =
        userRole == 'OWNER' || userRole == 'MANAGER' || userRole == 'CASHIER';

    return Column(
      children: [
        Container(
          padding: const EdgeInsets.all(16),
          color: Colors.grey[100],
          width: double.infinity,
          child: Row(
            children: [
              const Text("Current Order",
                  style: TextStyle(
                      color: Colors.black,
                      fontSize: 20,
                      fontWeight: FontWeight.bold)),
              const Spacer(),
              IconButton(
                icon: const Icon(Icons.delete_sweep, color: Colors.red),
                onPressed: () => cartNotifier.clearCart(),
              ),
            ],
          ),
        ),
        Expanded(
          child: cartItems.isEmpty
              ? const Center(
                  child: Text("Cart is empty",
                      style: TextStyle(color: Colors.grey)))
              : ListView.separated(
                  padding: const EdgeInsets.all(8),
                  itemCount: cartItems.length,
                  separatorBuilder: (ctx, i) => const Divider(),
                  itemBuilder: (context, index) {
                    final item = cartItems[index];
                    return ListTile(
                      title: Text(item.product.name,
                          style: const TextStyle(color: Colors.black87)),
                      subtitle: Text(
                          "UGX ${item.product.price.toStringAsFixed(0)} x ${item.quantity}",
                          style: const TextStyle(color: Colors.black54)),
                      trailing: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text("UGX ${item.total.toStringAsFixed(0)}",
                              style: const TextStyle(
                                  color: Colors.black,
                                  fontWeight: FontWeight.bold)),
                          IconButton(
                            icon: const Icon(Icons.remove_circle_outline,
                                color: Colors.red),
                            onPressed: () =>
                                cartNotifier.removeFromCart(item.product),
                          ),
                        ],
                      ),
                    );
                  },
                ),
        ),
        Container(
          padding: const EdgeInsets.all(16),
          color: Colors.grey[200],
          child: Column(
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  const Text("TOTAL",
                      style: TextStyle(
                          color: Colors.black,
                          fontSize: 24,
                          fontWeight: FontWeight.bold)),
                  Text("UGX ${cartNotifier.totalAmount.toStringAsFixed(0)}",
                      style: const TextStyle(
                          color: AppTheme.emerald,
                          fontSize: 28,
                          fontWeight: FontWeight.bold)),
                ],
              ),
              const SizedBox(height: 16),
              Row(
                children: [
                  // FIRE TO KITCHEN BUTTON (Available to all, mostly Waiters)
                  Expanded(
                    child: SizedBox(
                      height: 60,
                      child: ElevatedButton(
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.orange,
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(8)),
                        ),
                        onPressed: cartItems.isEmpty
                            ? null
                            : () async {
                                await cartNotifier.sendToKitchen();
                                ScaffoldMessenger.of(context).showSnackBar(
                                  const SnackBar(
                                      content:
                                          Text("Order sent to kitchen! ")),
                                );
                              },
                        child: const Text(
                          "SEND TO KITCHEN",
                          style: TextStyle(
                              fontSize: 16,
                              color: Colors.white,
                              fontWeight: FontWeight.bold),
                          textAlign: TextAlign.center,
                        ),
                      ),
                    ),
                  ),

                  const SizedBox(width: 8),
                  Expanded(
                    child: SizedBox(
                      height: 60,
                      child: ElevatedButton(
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.blueGrey,
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(8)),
                        ),
                        onPressed: cartItems.isEmpty
                            ? null
                            : () async {
                                final message =
                                    await cartNotifier.printBillCheck();
                                if (!context.mounted) return;
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text(
                                      message ?? 'Bill printed successfully.',
                                    ),
                                  ),
                                );
                              },
                        child: const Text("PRINT BILL",
                            style: TextStyle(
                                fontSize: 16,
                                color: Colors.white,
                                fontWeight: FontWeight.bold),
                            textAlign: TextAlign.center),
                      ),
                    ),
                  ),

                  // PAY/CHECKOUT BUTTON (Only Cashiers/Managers/Owners)
                  if (canCheckout) ...[
                    const SizedBox(width: 8),
                    Expanded(
                      child: SizedBox(
                        height: 60,
                        child: ElevatedButton(
                          style: ElevatedButton.styleFrom(
                            backgroundColor: AppTheme.emerald,
                            shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(8)),
                          ),
                          onPressed: cartItems.isEmpty
                              ? null
                              : () async {
                                  await cartNotifier.checkout(context);
                                },
                          child: const Text("PAY & CLOSE",
                              style: TextStyle(
                                  fontSize: 16,
                                  color: Colors.white,
                                  fontWeight: FontWeight.bold),
                              textAlign: TextAlign.center),
                        ),
                      ),
                    ),
                  ]
                ],
              ),
            ],
          ),
        ),
      ],
    );
  }
}

================
File: qristal_mobile/lib/services/sync_service.dart
================
import 'dart:convert';
import 'package:drift/drift.dart';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:drift/drift.dart' as drift;
import 'package:sentry_flutter/sentry_flutter.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import '../core/constants/api_constants.dart';
import '../database/database.dart';

class SyncService {
  final AppDatabase db;
  final _storage = const FlutterSecureStorage();

  SyncService(this.db);

  Future<void> syncData() async {
    final token = await _storage.read(key: 'jwt_token');
    if (token == null) throw Exception("Not Authenticated");

    // 1. PUSH local changes first (so server has latest sales)
    await _pushToWeb(token);

    // 2. PULL remote changes (menu updates)
    await pullFromWeb(token);
  }

  Future<void> pullFromWeb(String token) async {
    final prefs = await SharedPreferences.getInstance();
    final String? lastSync = prefs.getString('last_sync_timestamp');

    // 1. Prepare Query Params
    String url = '${ApiConstants.baseUrl}/sync/pull';
    if (lastSync != null) {
      url += '?lastSyncTimestamp=$lastSync';
    }

    try {
      // 2. Fetch Data
      final response = await http.get(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $token',
        },
      );

      if (response.statusCode != 200) {
        throw Exception('Sync failed: ${response.body}');
      }

      final data = jsonDecode(response.body);
      final changes = data['changes'];
      final newTimestamp = data['timestamp'];

      List<dynamic> _readChangeList(List<String> keys) {
        for (final key in keys) {
          final value = changes[key];
          if (value is List) return value;
        }
        return const [];
      }

      String? _readString(Map<String, dynamic> item, List<String> keys) {
        for (final key in keys) {
          final value = item[key];
          if (value != null) return value.toString();
        }
        return null;
      }

      double _readDouble(
        Map<String, dynamic> item,
        List<String> keys, {
        double fallback = 0.0,
      }) {
        final raw = _readString(item, keys);
        return double.tryParse(raw ?? '') ?? fallback;
      }

      // 3. Insert into SQLite (Batch Transaction for Performance)
      await db.batch((batch) {
        // --- Categories ---
        if (changes['categories'] != null) {
          for (var item in changes['categories']) {
            batch.insert(
              db.categories,
              CategoriesCompanion(
                id: drift.Value(item['id']),
                name: drift.Value(item['name']),
                colorHex: drift.Value(item['colorHex']),
                sortOrder: drift.Value(item['sortOrder']),
                updatedAt: drift.Value(DateTime.parse(item['updatedAt'])),
              ),
              mode: drift.InsertMode.insertOrReplace,
            );
          }
        }

        // --- Products ---
        if (changes['products'] != null) {
          for (var item in changes['products']) {
            // Ensure price is treated as double
            double price = double.tryParse(item['price'].toString()) ?? 0.0;

            batch.insert(
              db.products,
              ProductsCompanion(
                id: drift.Value(item['id']),
                categoryId: drift.Value(item['categoryId']),
                name: drift.Value(item['name']),
                price: drift.Value(price),
                isAvailable: drift.Value(item['isAvailable']),
                updatedAt: drift.Value(DateTime.parse(item['updatedAt'])),
              ),
              mode: drift.InsertMode.insertOrReplace,
            );
          }
        }

        // --- Users (Optional, for offline login check later) ---
        // You would handle users similarly here

        // --- Orders ---
        final orders = _readChangeList(['orders']);
        for (final raw in orders) {
          final item = Map<String, dynamic>.from(raw as Map);
          final orderId = _readString(item, ['id']);
          final receiptNumber = _readString(item, [
            'receiptNumber',
            'receipt_number',
          ]);
          final userId = _readString(item, ['userId', 'user_id']);
          final createdAt = _readString(item, ['createdAt', 'created_at']);
          final shiftId = _readString(item, ['shiftId', 'shift_id']);
          if (orderId == null ||
              receiptNumber == null ||
              userId == null ||
              createdAt == null ||
              shiftId == null ||
              shiftId.isEmpty) {
            continue;
          }

          batch.insert(
            db.orders,
            OrdersCompanion(
              id: drift.Value(orderId),
              receiptNumber: drift.Value(receiptNumber),
              userId: drift.Value(userId),
              tableId: drift.Value(_readString(item, ['tableId', 'table_id'])),
              totalAmount: drift.Value(
                _readDouble(item, ['totalAmount', 'total_amount']),
              ),
              status: drift.Value(_readString(item, ['status']) ?? 'KITCHEN'),
              shiftId: drift.Value(shiftId),
              createdAt: drift.Value(DateTime.parse(createdAt)),
              updatedAt: drift.Value(
                DateTime.parse(
                  _readString(item, ['updatedAt', 'updated_at']) ?? createdAt,
                ),
              ),
              isSynced: const drift.Value(true),
            ),
            mode: drift.InsertMode.insertOrReplace,
          );
        }

        // --- Order Items ---
        if (changes['orderItems'] != null) {
          for (var item in changes['orderItems']) {
            batch.insert(
              db.orderItems,
              OrderItemsCompanion(
                id: drift.Value(item['id']),
                orderId: drift.Value(item['orderId']),
                productId: drift.Value(item['productId']),
                quantity: drift.Value(item['quantity']),
                priceAtTimeOfOrder: drift.Value(
                  double.tryParse(item['priceAtTimeOfOrder'].toString()) ?? 0.0,
                ),
                routeTo: drift.Value(item['routeTo'] ?? item['route_to']),
                notes: drift.Value(item['notes']),
              ),
              mode: drift.InsertMode.insertOrReplace,
            );
          }
        }


        // --- Order Item Modifiers ---
        final orderItemModifiers = _readChangeList([
          'orderItemModifiers',
          'order_item_modifiers',
        ]);
        for (final raw in orderItemModifiers) {
          final item = Map<String, dynamic>.from(raw as Map);
          final id = _readString(item, ['id']);
          final orderItemId = _readString(item, ['orderItemId', 'order_item_id']);
          final name = _readString(item, ['name']);
          if (id == null || orderItemId == null || name == null) continue;

          batch.insert(
            db.orderItemModifiers,
            OrderItemModifiersCompanion(
              id: drift.Value(id),
              orderItemId: drift.Value(orderItemId),
              name: drift.Value(name),
              priceDelta: drift.Value(_readDouble(item, ['priceDelta', 'price_delta'])),
              routeTo: drift.Value(_readString(item, ['routeTo', 'route_to'])),
            ),
            mode: drift.InsertMode.insertOrReplace,
          );
        }

        // --- Order Item Sides ---
        final orderItemSides = _readChangeList([
          'orderItemSides',
          'order_item_sides',
        ]);
        for (final raw in orderItemSides) {
          final item = Map<String, dynamic>.from(raw as Map);
          final id = _readString(item, ['id']);
          final orderItemId = _readString(item, ['orderItemId', 'order_item_id']);
          final name = _readString(item, ['name']);
          if (id == null || orderItemId == null || name == null) continue;

          batch.insert(
            db.orderItemSides,
            OrderItemSidesCompanion(
              id: drift.Value(id),
              orderItemId: drift.Value(orderItemId),
              name: drift.Value(name),
              quantity: drift.Value(int.tryParse(_readString(item, ['quantity']) ?? '') ?? 1),
              priceDelta: drift.Value(_readDouble(item, ['priceDelta', 'price_delta'])),
              routeTo: drift.Value(_readString(item, ['routeTo', 'route_to'])),
            ),
            mode: drift.InsertMode.insertOrReplace,
          );
        }

        // --- Payments ---
        if (changes['payments'] != null) {
          for (var item in changes['payments']) {
            batch.insert(
              db.payments,
              PaymentsCompanion(
                id: drift.Value(item['id']),
                orderId: drift.Value(item['orderId']),
                method: drift.Value(item['method']),
                amount: drift.Value(
                  double.tryParse(item['amount'].toString()) ?? 0.0,
                ),
                reference: drift.Value(item['reference']),
                createdAt: drift.Value(DateTime.parse(item['createdAt'])),
              ),
              mode: drift.InsertMode.insertOrReplace,
            );
          }
        }

        // --- Tables ---
        final seatingTables = _readChangeList([
          'seatingTables',
          'seating_tables',
          'tables',
        ]);
        for (final raw in seatingTables) {
          final item = Map<String, dynamic>.from(raw as Map);
          final tableId = _readString(item, ['id']);
          final tableName = _readString(item, ['name']);
          final updatedAt = _readString(item, ['updatedAt', 'updated_at']);

          if (tableId == null || tableName == null || updatedAt == null) {
            continue;
          }

          batch.insert(
            db.seatingTables,
            SeatingTablesCompanion(
              id: drift.Value(tableId),
              name: drift.Value(tableName),
              status: drift.Value(_readString(item, ['status']) ?? 'FREE'),
              floor: drift.Value(_readString(item, ['floor']) ?? 'Main'),
              updatedAt: drift.Value(DateTime.parse(updatedAt)),
            ),
            mode: drift.InsertMode.insertOrReplace,
          );
        }
        
        // --- Shifts ---
        if (changes['shifts'] != null) {
          for (var item in changes['shifts']) {
            batch.insert(
              db.shifts,
              ShiftsCompanion(
                id: drift.Value(item['id']),
                userId: drift.Value(item['userId']),
                openingTime: drift.Value(DateTime.parse(item['openingTime'])),
                closingTime: drift.Value(item['closingTime'] != null ? DateTime.parse(item['closingTime']) : null),
                startingCash: drift.Value(double.tryParse(item['startingCash'].toString()) ?? 0.0),
                expectedCash: drift.Value(double.tryParse(item['expectedCash'].toString()) ?? 0.0),
                actualCash: drift.Value(double.tryParse(item['actualCash'].toString()) ?? 0.0),
                notes: drift.Value(item['notes']),
                isSynced: const drift.Value(true),
              ),
              mode: drift.InsertMode.insertOrReplace,
            );
          }
        }
      });

      // 4. Save new timestamp
      await prefs.setString('last_sync_timestamp', newTimestamp);
      if (kDebugMode) {
        print("Sync Completed Successfully. Timestamp: $newTimestamp");
      }
    } catch (exception, stackTrace) {
      await Sentry.captureException(exception, stackTrace: stackTrace);
      if (kDebugMode) {
        print("Sync Error: $exception");
      }
      rethrow;
    }
  }

  Future<void> _pushToWeb(String token) async {
    // 1. Find unsynced data
    final unsyncedOrders = await (db.select(db.orders)..where((t) => t.isSynced.equals(false))).get();
    final unsyncedShifts = await (db.select(db.shifts)..where((t) => t.isSynced.equals(false))).get();
    final unsyncedTables = await (db.select(db.seatingTables)..where((t) => t.isSynced.equals(false))).get();

    if (unsyncedOrders.isEmpty && unsyncedShifts.isEmpty && unsyncedTables.isEmpty) return;

    if (kDebugMode) {
      print("Found ${unsyncedOrders.length} orders, ${unsyncedShifts.length} shifts, and ${unsyncedTables.length} tables to push.");
    }

    List<Map<String, dynamic>> ordersPayload = [];
    List<Map<String, dynamic>> itemsPayload = [];
    List<Map<String, dynamic>> paymentsPayload = [];
    List<Map<String, dynamic>> orderItemModifiersPayload = [];
    List<Map<String, dynamic>> orderItemSidesPayload = [];
    List<Map<String, dynamic>> shiftsPayload = [];
    List<Map<String, dynamic>> tablesPayload = [];

    if (unsyncedOrders.isNotEmpty) {
      final orderIds = unsyncedOrders.map((order) => order.id).toList();
      final relatedItems = await (db.select(db.orderItems)..where((t) => t.orderId.isIn(orderIds))).get();
      final itemIds = relatedItems.map((item) => item.id).toList();
      final relatedModifiers = itemIds.isEmpty
          ? <OrderItemModifier>[]
          : await (db.select(db.orderItemModifiers)..where((t) => t.orderItemId.isIn(itemIds))).get();
      final relatedSides = itemIds.isEmpty
          ? <OrderItemSide>[]
          : await (db.select(db.orderItemSides)..where((t) => t.orderItemId.isIn(itemIds))).get();

      for (final item in relatedItems) {
        itemsPayload.add({
          'id': item.id,
          'orderId': item.orderId,
          'productId': item.productId,
          'quantity': item.quantity,
          'priceAtTimeOfOrder': item.priceAtTimeOfOrder,
          'routeTo': item.routeTo,
          'notes': item.notes,
        });
      }

      for (final modifier in relatedModifiers) {
        orderItemModifiersPayload.add({
          'id': modifier.id,
          'orderItemId': modifier.orderItemId,
          'name': modifier.name,
          'priceDelta': modifier.priceDelta,
          'routeTo': modifier.routeTo,
        });
      }

      for (final side in relatedSides) {
        orderItemSidesPayload.add({
          'id': side.id,
          'orderItemId': side.orderItemId,
          'name': side.name,
          'quantity': side.quantity,
          'priceDelta': side.priceDelta,
          'routeTo': side.routeTo,
        });
      }

      for (final order in unsyncedOrders) {
        ordersPayload.add({
          'id': order.id,
          'receiptNumber': order.receiptNumber,
          'userId': order.userId,
          'tableId': order.tableId,
          'totalAmount': order.totalAmount,
          'status': order.status,
          'createdAt': order.createdAt.toIso8601String(),
          'updatedAt': order.updatedAt.toIso8601String(),
        });

        final payments = await (db.select(db.payments)..where((t) => t.orderId.equals(order.id))).get();
        for (final pay in payments) {
          paymentsPayload.add({
            'id': pay.id,
            'orderId': pay.orderId,
            'method': pay.method,
            'amount': pay.amount,
            'reference': pay.reference,
            'createdAt': pay.createdAt.toIso8601String(),
          });
        }
      }
    }

    if (unsyncedShifts.isNotEmpty) {
      for (final shift in unsyncedShifts) {
        shiftsPayload.add({
          'id': shift.id,
          'userId': shift.userId,
          'openingTime': shift.openingTime.toIso8601String(),
          'closingTime': shift.closingTime?.toIso8601String(),
          'startingCash': shift.startingCash,
          'expectedCash': shift.expectedCash,
          'actualCash': shift.actualCash,
          'notes': shift.notes,
        });
      }
    }

    if (unsyncedTables.isNotEmpty) {
      for (final table in unsyncedTables) {
        tablesPayload.add({
          'id': table.id,
          'name': table.name,
          'status': table.status,
          'floor': table.floor,
          'updatedAt': table.updatedAt?.toIso8601String(),
        });
      }
    }

    if (kDebugMode) {
      print(
        'Prepared sync payload: '
        '${ordersPayload.length} orders, '
        '${itemsPayload.length} orderItems, '
        '${paymentsPayload.length} payments, '
        '${orderItemModifiersPayload.length} orderItemModifiers, '
        '${orderItemSidesPayload.length} orderItemSides, '
        '${shiftsPayload.length} shifts, '
        '${tablesPayload.length} tables.'
      );
    }

    try {
      final response = await http
          .post(
            Uri.parse('${ApiConstants.baseUrl}${ApiConstants.syncPushEndpoint}'),
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer $token',
            },
            body: jsonEncode({
              'orders': ordersPayload,
              'orderItems': itemsPayload,
              'payments': paymentsPayload,
              'orderItemModifiers': orderItemModifiersPayload,
              'orderItemSides': orderItemSidesPayload,
              'shifts': shiftsPayload,
              'seatingTables': tablesPayload,
            }),
          )
          .timeout(const Duration(seconds: 20));

      if (response.statusCode == 201 || response.statusCode == 200) {
        await db.transaction(() async {
          for (final order in unsyncedOrders) {
            await (db.update(db.orders)..where((t) => t.id.equals(order.id)))
                .write(const OrdersCompanion(isSynced: Value(true)));
          }
          for (final shift in unsyncedShifts) {
            await (db.update(db.shifts)..where((t) => t.id.equals(shift.id)))
                .write(const ShiftsCompanion(isSynced: Value(true)));
          }
          for (final table in unsyncedTables) {
            await (db.update(db.seatingTables)..where((t) => t.id.equals(table.id)))
                .write(const SeatingTablesCompanion(isSynced: Value(true)));
          }
        });
        if (kDebugMode) print(" Sync Push Successful!");
      } else {
        if (kDebugMode) {
          print(" Push failed: ${response.statusCode} - ${response.body}");
        }
        throw Exception(
          'Push failed: ${response.statusCode} - ${response.body}',
        );
      }
    } catch (e, stackTrace) {
      await Sentry.captureException(e, stackTrace: stackTrace);
      if (kDebugMode) print(" Connection error during push: $e");
      rethrow;
    }
  }
}





================================================================
End of Codebase
================================================================
